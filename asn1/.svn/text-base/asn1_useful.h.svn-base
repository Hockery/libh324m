//
// asn1_useful.h
//
// Code automatically generated by asnparser.
//

#ifndef __ASN_USEFUL_H
#define __ASN_USEFUL_H

//
// EXTERNAL
//

class EXTERNAL : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    EXTERNAL(const void* info) : Inherited(info) {}
  public:
    EXTERNAL() : Inherited(&theInfo) {}
    EXTERNAL(const EXTERNAL & other) : Inherited(other)
    {}
    EXTERNAL& operator = (const EXTERNAL& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_direct_reference,
      e_indirect_reference,
      e_data_value_descriptor
    };


    class direct_reference {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class direct_reference

    direct_reference::const_reference get_direct_reference () const
    { assert(hasOptionalField(e_direct_reference));
      return *static_cast<direct_reference::const_pointer>(fields[0]); }

    direct_reference::reference ref_direct_reference ()
    { assert(hasOptionalField(e_direct_reference));
      return *static_cast<direct_reference::pointer>(fields[0]); }

    direct_reference::reference set_direct_reference ()
    { includeOptionalField( e_direct_reference, 0);
      return *static_cast<direct_reference::pointer>(fields[0]); }

    direct_reference::reference set_direct_reference (const direct_reference::value_type& value)
    { includeOptionalField( e_direct_reference, 0);
      return *static_cast<direct_reference::pointer>(fields[0]) = value; }

    void omit_direct_reference () { removeOptionalField( e_direct_reference); }

    bool direct_reference_isPresent () const { return hasOptionalField( e_direct_reference); }


    class indirect_reference {
      public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class indirect_reference

    indirect_reference::const_reference get_indirect_reference () const
    { assert(hasOptionalField(e_indirect_reference));
      return *static_cast<indirect_reference::const_pointer>(fields[1]); }

    indirect_reference::reference ref_indirect_reference ()
    { assert(hasOptionalField(e_indirect_reference));
      return *static_cast<indirect_reference::pointer>(fields[1]); }

    indirect_reference::reference set_indirect_reference ()
    { includeOptionalField( e_indirect_reference, 1);
      return *static_cast<indirect_reference::pointer>(fields[1]); }

    indirect_reference::reference set_indirect_reference (indirect_reference::value_type::int_type value)
    { includeOptionalField( e_indirect_reference, 1);
      return *static_cast<indirect_reference::pointer>(fields[1]) = value; }

    void omit_indirect_reference () { removeOptionalField( e_indirect_reference); }

    bool indirect_reference_isPresent () const { return hasOptionalField( e_indirect_reference); }


    class data_value_descriptor {
      public:
        typedef ObjectDescriptor value_type;
        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class data_value_descriptor

    data_value_descriptor::const_reference get_data_value_descriptor () const
    { assert(hasOptionalField(e_data_value_descriptor));
      return *static_cast<data_value_descriptor::const_pointer>(fields[2]); }

    data_value_descriptor::reference ref_data_value_descriptor ()
    { assert(hasOptionalField(e_data_value_descriptor));
      return *static_cast<data_value_descriptor::pointer>(fields[2]); }

    data_value_descriptor::reference set_data_value_descriptor ()
    { includeOptionalField( e_data_value_descriptor, 2);
      return *static_cast<data_value_descriptor::pointer>(fields[2]); }

    data_value_descriptor::reference set_data_value_descriptor (const data_value_descriptor::value_type& value)
    { includeOptionalField( e_data_value_descriptor, 2);
      return *static_cast<data_value_descriptor::pointer>(fields[2]) = value; }

    void omit_data_value_descriptor () { removeOptionalField( e_data_value_descriptor); }

    bool data_value_descriptor_isPresent () const { return hasOptionalField( e_data_value_descriptor); }


    class encoding {
      public:
        class value_type : public ASN1::CHOICE
        {
            typedef ASN1::CHOICE Inherited;
          protected:
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) {}
            enum Id {
              unknownSelection_ = -2,
              unselected_ = -1,
              single_ASN1_type0 = 0,
              octet_aligned1 = 1,
              arbitrary2 = 2
            };

            class single_ASN1_type {
              public:
                enum Id { id = 0 };
                typedef ASN1::OpenData value_type;

                typedef value_type&        reference;
                typedef const value_type&  const_reference;
                typedef value_type*        pointer;
                typedef const value_type*  const_pointer;
            }; // end class single_ASN1_type

            single_ASN1_type::const_reference get_single_ASN1_type () const
            { assert(currentSelection() == single_ASN1_type::id);
              return *static_cast<const single_ASN1_type::const_pointer>(choice.get()); }

            single_ASN1_type::reference ref_single_ASN1_type ()
            { assert(currentSelection() == single_ASN1_type::id);
              return *static_cast<single_ASN1_type::pointer>(choice.get()); }

            single_ASN1_type::reference select_single_ASN1_type () { return *static_cast<single_ASN1_type::pointer>(setSelection(single_ASN1_type::id, ASN1::AbstractData::create( &single_ASN1_type::value_type::theInfo))); }

            single_ASN1_type::reference select_single_ASN1_type (const single_ASN1_type::value_type& value) { return select_single_ASN1_type() = value; }

            bool single_ASN1_type_isSelected() const { return currentSelection() == single_ASN1_type::id; }

            value_type(single_ASN1_type::Id id, const single_ASN1_type::value_type& value)  : Inherited(&theInfo, id, new single_ASN1_type::value_type(value) ) { }


            class octet_aligned {
              public:
                enum Id { id = 1 };
                typedef ASN1::OCTET_STRING value_type;

                typedef value_type&        reference;
                typedef const value_type&  const_reference;
                typedef value_type*        pointer;
                typedef const value_type*  const_pointer;
            }; // end class octet_aligned

            octet_aligned::const_reference get_octet_aligned () const
            { assert(currentSelection() == octet_aligned::id);
              return *static_cast<const octet_aligned::const_pointer>(choice.get()); }

            octet_aligned::reference ref_octet_aligned ()
            { assert(currentSelection() == octet_aligned::id);
              return *static_cast<octet_aligned::pointer>(choice.get()); }

            octet_aligned::reference select_octet_aligned () { return *static_cast<octet_aligned::pointer>(setSelection(octet_aligned::id, ASN1::AbstractData::create( &octet_aligned::value_type::theInfo))); }

            octet_aligned::reference select_octet_aligned (const ASN1_STD vector<char>& value) { return select_octet_aligned() = value; }

            bool octet_aligned_isSelected() const { return currentSelection() == octet_aligned::id; }

            value_type(octet_aligned::Id id, const ASN1_STD vector<char>& value)  : Inherited(&theInfo, id, new octet_aligned::value_type(value) ) { }


            class arbitrary {
              public:
                enum Id { id = 2 };
                typedef ASN1::BIT_STRING value_type;

                typedef value_type&        reference;
                typedef const value_type&  const_reference;
                typedef value_type*        pointer;
                typedef const value_type*  const_pointer;
            }; // end class arbitrary

            arbitrary::const_reference get_arbitrary () const
            { assert(currentSelection() == arbitrary::id);
              return *static_cast<const arbitrary::const_pointer>(choice.get()); }

            arbitrary::reference ref_arbitrary ()
            { assert(currentSelection() == arbitrary::id);
              return *static_cast<arbitrary::pointer>(choice.get()); }

            arbitrary::reference select_arbitrary () { return *static_cast<arbitrary::pointer>(setSelection(arbitrary::id, ASN1::AbstractData::create( &arbitrary::value_type::theInfo))); }

            arbitrary::reference select_arbitrary (const arbitrary::value_type& value) { return select_arbitrary() = value; }

            bool arbitrary_isSelected() const { return currentSelection() == arbitrary::id; }

            value_type(arbitrary::Id id, const arbitrary::value_type& value)  : Inherited(&theInfo, id, new arbitrary::value_type(value) ) { }

            value_type(const value_type & other)
            : Inherited(other) {} 

            value_type & operator = (const value_type & other)
            { Inherited::operator=(other); return *this; }

            void swap(value_type & other) {  Inherited::swap(other); }

                value_type * clone() const { return static_cast<value_type*> (Inherited::clone()); }

                static bool equal_type(const ASN1::AbstractData& type)
                { return type.info() == reinterpret_cast<const ASN1::AbstractData::InfoType*>(&theInfo); }

            static const InfoType theInfo;
          private:
            static const void* selectionInfos[3];
#ifdef ASN1_HAS_IOSTREAM
            static const char* selectionNames[3];
#endif
            }; //end class value_type

        typedef value_type&        reference;
        typedef const value_type&  const_reference;
        typedef value_type*        pointer;
        typedef const value_type*  const_pointer;
    }; // end class encoding

    encoding::const_reference get_encoding () const { return *static_cast<encoding::const_pointer>(fields[3]);}
    encoding::reference ref_encoding () { return *static_cast<encoding::pointer>(fields[3]);}
    encoding::reference set_encoding () { return *static_cast<encoding::pointer>(fields[3]);}
    encoding::reference set_encoding (const encoding::value_type& value) { return *static_cast<encoding::pointer>(fields[3]) = value ;}

    void swap(EXTERNAL& other) { Inherited::swap(other); }

    EXTERNAL * clone() const { return static_cast<EXTERNAL*> (Inherited::clone()); }

static const InfoType theInfo;
private:
static const void* fieldInfos[4];
static int fieldIds[4];
#ifdef ASN1_HAS_IOSTREAM
static const char* fieldNames[4];
#endif
}; //end class EXTERNAL


//
// ABSTRACT-SYNTAX
//

class ABSTRACT_SYNTAX
{
  public:
    typedef ASN1::OBJECT_IDENTIFIER key_type;
    class info_type
    {
      public:
        info_type();
        ASN1::AbstractData* get_Type() const { return m_Type ? ASN1::AbstractData::create(m_Type) : NULL; }
      protected:
        const void* m_Type;
    };

    typedef const info_type* mapped_type;

    class value_type : public ASN1_STD pair<key_type, mapped_type>
    {
        typedef ASN1_STD pair<key_type, mapped_type> Inherited;
      public:
        value_type(const key_type& key, mapped_type mt) : Inherited(key,mt) {}
        ASN1::AbstractData* get_Type() const { return second->get_Type(); }
    };

    typedef value_type& reference;
    typedef const value_type& const_reference;
    typedef value_type* pointer;
    typedef const value_type* const_pointer;
    typedef AssocVector<key_type, mapped_type> map_type;

  private:
#if defined(__HP_aCC)
	typedef bidirectional_iterator<value_type> my_iterator_traits;
	typedef bidirectional_iterator<const value_type> my_const_iterator_traits;
#else
    typedef ASN1_STD iterator<ASN1_STD bidirectional_iterator_tag, value_type> my_iterator_traits;
    typedef ASN1_STD iterator<ASN1_STD bidirectional_iterator_tag, const value_type> my_const_iterator_traits;
#endif
  public:
    class iterator : public my_iterator_traits
    {
      public:
        iterator() {}
        iterator(map_type::iterator i) : itsIter(i) {}
        map_type::iterator base() const {return itsIter;}
        const_reference operator*() const {return *static_cast<const_pointer>(&*itsIter);}
        const_pointer operator->() const {return static_cast<const_pointer>(&*itsIter);}
        iterator& operator++()          {++itsIter; return *this;}
        iterator& operator--()          {--itsIter; return *this;}
        iterator operator++(int)        {iterator t(*this); ++itsIter; return t;}
        iterator operator--(int)        {iterator t(*this); --itsIter; return t;}

        bool operator==(const iterator& r) const    {return itsIter == r.itsIter;}
        bool operator!=(const iterator& r) const    {return itsIter != r.itsIter;}
      private:
        map_type::iterator itsIter;
    };
    class const_iterator : public my_const_iterator_traits
    {
      public:
        const_iterator() {}
        //const_iterator(iterator i) : itsIter(i.base()) {}
        const_iterator(map_type::const_iterator i) : itsIter(i) {}
        map_type::const_iterator base() const {return itsIter;}

        const_reference operator*() const {return *static_cast<const_pointer>(&*itsIter);}
        const_pointer operator->() const {return static_cast<const_pointer>(&*itsIter);}

        const_iterator& operator++()          {++itsIter; return *this;}
        const_iterator& operator--()          {--itsIter; return *this;}
        const_iterator operator++(int)        {const_iterator t(*this); ++itsIter; return t;}
        const_iterator operator--(int)        {const_iterator t(*this); --itsIter; return t;}

        bool operator==(const const_iterator& r) const    {return itsIter == r.itsIter;}
        bool operator!=(const const_iterator& r) const    {return itsIter != r.itsIter;}
      private:
        map_type::const_iterator itsIter;
    };

    //typedef ASN1_STD reverse_bidirectional_iterator<iterator, value_type> reverse_iterator;
    //typedef ASN1_STD reverse_bidirectional_iterator<const_iterator, const value_type> const_reverse_iterator;

    typedef map_type::key_compare key_compare;
    typedef map_type::difference_type difference_type;
    typedef map_type::size_type size_type;

    ABSTRACT_SYNTAX(){}
#if !ASN_NO_MEMBER_TEMPLATES
    template <class InputIterator>
            ABSTRACT_SYNTAX(InputIterator first, InputIterator last)
        : rep(first, last) {}
#endif
    ABSTRACT_SYNTAX(const ABSTRACT_SYNTAX& other)
        : rep(other.rep) {}

    ABSTRACT_SYNTAX& operator = (const ABSTRACT_SYNTAX& other)
        { ABSTRACT_SYNTAX tmp(other); swap(tmp);  return *this; }

    // iterators
    iterator begin() { return iterator(rep.begin());}
    const_iterator begin() const { return const_iterator(rep.begin());}
    iterator end() { return iterator(rep.end()); }
    const_iterator end() const { return const_iterator(rep.end()); }

    //reverse_iterator rbegin() { return reverse_iterator(end());}
    //const_reverse_iterator rbegin() const { return const_reverse_iterator(end());}
    //reverse_iterator rend() { return reverse_iterator(begin()); }
    //const_reverse_iterator rend() const { return const_reverse_iterator(begin()); }
    // capacity
    bool empty() const { return rep.empty(); }
    size_type size() const { return rep.size(); }
    // modifiers
    ASN1_STD pair<iterator, bool> insert(const value_type& x)
    { 
        ASN1_STD pair<map_type::iterator, bool> r = rep.insert(x); 
        return ASN1_STD pair<iterator, bool>(r.first, r.second);
    }
    iterator insert(iterator position, const value_type& x)
    { return iterator(rep.insert(position.base(), x)); }
    void insert(const_iterator first, const_iterator last)
    { rep.insert(first.base(), last.base()); }
    void erase(iterator position) { rep.erase(position.base()); }
    void erase(const key_type& key) { rep.erase(key); }
    void erase(iterator first, iterator last) { rep.erase(first.base(), last.base()); }
    void swap(ABSTRACT_SYNTAX& other) { rep.swap(other.rep); }
    void clear() { rep.clear(); }
    key_compare key_comp() const { return rep.key_comp(); }
    // operations
    iterator find(const key_type& key) { return iterator(rep.find(key)); }
    const_iterator find(const key_type& key) const { return const_iterator(rep.find(key)); }
    size_type count(const key_type& key) const { return rep.count(key); }
  private:
    map_type rep;
};

#endif // __ASN1_USEFUL_H
// End of asn1_useful.h
