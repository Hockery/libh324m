//
// multimedia_system_control.h
//
// Code automatically generated by asnparser.
//

#ifndef __MULTIMEDIA_SYSTEM_CONTROL_H
#define __MULTIMEDIA_SYSTEM_CONTROL_H

#include <asn1.h>

namespace MULTIMEDIA_SYSTEM_CONTROL {

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  SequenceNumber;

//
// MasterSlaveDetermination
//

class MasterSlaveDetermination : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MasterSlaveDetermination(const void* info) : Inherited(info) {}
  public:
    MasterSlaveDetermination() : Inherited(&theInfo) {}
    MasterSlaveDetermination(const MasterSlaveDetermination & other) : Inherited(other)
    {}
    MasterSlaveDetermination& operator = (const MasterSlaveDetermination& other)
    { Inherited::operator = (other); return *this; } 
    class terminalType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalType
    terminalType::const_reference get_terminalType () const;
    terminalType::reference ref_terminalType ();
    terminalType::reference set_terminalType ();
    terminalType::reference set_terminalType (terminalType::value_type::int_type value);
    class statusDeterminationNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16777215>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class statusDeterminationNumber
    statusDeterminationNumber::const_reference get_statusDeterminationNumber () const;
    statusDeterminationNumber::reference ref_statusDeterminationNumber ();
    statusDeterminationNumber::reference set_statusDeterminationNumber ();
    statusDeterminationNumber::reference set_statusDeterminationNumber (statusDeterminationNumber::value_type::int_type value);
    void swap(MasterSlaveDetermination& other);
    MasterSlaveDetermination * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MasterSlaveDeterminationRelease
//

class MasterSlaveDeterminationRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MasterSlaveDeterminationRelease(const void* info) : Inherited(info) {}
  public:
    MasterSlaveDeterminationRelease() : Inherited(&theInfo) {}
    MasterSlaveDeterminationRelease(const MasterSlaveDeterminationRelease & other) : Inherited(other)
    {}
    MasterSlaveDeterminationRelease& operator = (const MasterSlaveDeterminationRelease& other)
    { Inherited::operator = (other); return *this; } 
    void swap(MasterSlaveDeterminationRelease& other);
    MasterSlaveDeterminationRelease * clone() const;
    static const InfoType theInfo;
  private:
};

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  CapabilityTableEntryNumber;

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  CapabilityDescriptorNumber;

//
// TerminalCapabilitySetRelease
//

class TerminalCapabilitySetRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalCapabilitySetRelease(const void* info) : Inherited(info) {}
  public:
    TerminalCapabilitySetRelease() : Inherited(&theInfo) {}
    TerminalCapabilitySetRelease(const TerminalCapabilitySetRelease & other) : Inherited(other)
    {}
    TerminalCapabilitySetRelease& operator = (const TerminalCapabilitySetRelease& other)
    { Inherited::operator = (other); return *this; } 
    void swap(TerminalCapabilitySetRelease& other);
    TerminalCapabilitySetRelease * clone() const;
    static const InfoType theInfo;
  private:
};

//
// H223AnnexCCapability
//

class H223AnnexCCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AnnexCCapability(const void* info) : Inherited(info) {}
  public:
    H223AnnexCCapability() : Inherited(&theInfo) {}
    H223AnnexCCapability(const H223AnnexCCapability & other) : Inherited(other)
    {}
    H223AnnexCCapability& operator = (const H223AnnexCCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_rsCodeCapability
    };

    class videoWithAL1M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoWithAL1M
    videoWithAL1M::const_reference get_videoWithAL1M () const;
    videoWithAL1M::reference ref_videoWithAL1M ();
    videoWithAL1M::reference set_videoWithAL1M ();
    videoWithAL1M::reference set_videoWithAL1M (bool value);
    class videoWithAL2M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoWithAL2M
    videoWithAL2M::const_reference get_videoWithAL2M () const;
    videoWithAL2M::reference ref_videoWithAL2M ();
    videoWithAL2M::reference set_videoWithAL2M ();
    videoWithAL2M::reference set_videoWithAL2M (bool value);
    class videoWithAL3M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoWithAL3M
    videoWithAL3M::const_reference get_videoWithAL3M () const;
    videoWithAL3M::reference ref_videoWithAL3M ();
    videoWithAL3M::reference set_videoWithAL3M ();
    videoWithAL3M::reference set_videoWithAL3M (bool value);
    class audioWithAL1M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioWithAL1M
    audioWithAL1M::const_reference get_audioWithAL1M () const;
    audioWithAL1M::reference ref_audioWithAL1M ();
    audioWithAL1M::reference set_audioWithAL1M ();
    audioWithAL1M::reference set_audioWithAL1M (bool value);
    class audioWithAL2M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioWithAL2M
    audioWithAL2M::const_reference get_audioWithAL2M () const;
    audioWithAL2M::reference ref_audioWithAL2M ();
    audioWithAL2M::reference set_audioWithAL2M ();
    audioWithAL2M::reference set_audioWithAL2M (bool value);
    class audioWithAL3M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioWithAL3M
    audioWithAL3M::const_reference get_audioWithAL3M () const;
    audioWithAL3M::reference ref_audioWithAL3M ();
    audioWithAL3M::reference set_audioWithAL3M ();
    audioWithAL3M::reference set_audioWithAL3M (bool value);
    class dataWithAL1M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataWithAL1M
    dataWithAL1M::const_reference get_dataWithAL1M () const;
    dataWithAL1M::reference ref_dataWithAL1M ();
    dataWithAL1M::reference set_dataWithAL1M ();
    dataWithAL1M::reference set_dataWithAL1M (bool value);
    class dataWithAL2M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataWithAL2M
    dataWithAL2M::const_reference get_dataWithAL2M () const;
    dataWithAL2M::reference ref_dataWithAL2M ();
    dataWithAL2M::reference set_dataWithAL2M ();
    dataWithAL2M::reference set_dataWithAL2M (bool value);
    class dataWithAL3M {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataWithAL3M
    dataWithAL3M::const_reference get_dataWithAL3M () const;
    dataWithAL3M::reference ref_dataWithAL3M ();
    dataWithAL3M::reference set_dataWithAL3M ();
    dataWithAL3M::reference set_dataWithAL3M (bool value);
    class alpduInterleaving {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alpduInterleaving
    alpduInterleaving::const_reference get_alpduInterleaving () const;
    alpduInterleaving::reference ref_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving (bool value);
    class maximumAL1MPDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumAL1MPDUSize
    maximumAL1MPDUSize::const_reference get_maximumAL1MPDUSize () const;
    maximumAL1MPDUSize::reference ref_maximumAL1MPDUSize ();
    maximumAL1MPDUSize::reference set_maximumAL1MPDUSize ();
    maximumAL1MPDUSize::reference set_maximumAL1MPDUSize (maximumAL1MPDUSize::value_type::int_type value);
    class maximumAL2MSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumAL2MSDUSize
    maximumAL2MSDUSize::const_reference get_maximumAL2MSDUSize () const;
    maximumAL2MSDUSize::reference ref_maximumAL2MSDUSize ();
    maximumAL2MSDUSize::reference set_maximumAL2MSDUSize ();
    maximumAL2MSDUSize::reference set_maximumAL2MSDUSize (maximumAL2MSDUSize::value_type::int_type value);
    class maximumAL3MSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumAL3MSDUSize
    maximumAL3MSDUSize::const_reference get_maximumAL3MSDUSize () const;
    maximumAL3MSDUSize::reference ref_maximumAL3MSDUSize ();
    maximumAL3MSDUSize::reference set_maximumAL3MSDUSize ();
    maximumAL3MSDUSize::reference set_maximumAL3MSDUSize (maximumAL3MSDUSize::value_type::int_type value);
    class rsCodeCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rsCodeCapability
    rsCodeCapability::const_reference get_rsCodeCapability () const;
    rsCodeCapability::reference ref_rsCodeCapability ();
    rsCodeCapability::reference set_rsCodeCapability ();
    rsCodeCapability::reference set_rsCodeCapability (bool value);
    void omit_rsCodeCapability ();
    bool rsCodeCapability_isPresent () const;
    void swap(H223AnnexCCapability& other);
    H223AnnexCCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[14];
    static int fieldIds[14];
    static const char* fieldNames[14];
};

//
// V75Capability
//

class V75Capability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V75Capability(const void* info) : Inherited(info) {}
  public:
    V75Capability() : Inherited(&theInfo) {}
    V75Capability(const V75Capability & other) : Inherited(other)
    {}
    V75Capability& operator = (const V75Capability& other)
    { Inherited::operator = (other); return *this; } 
    class audioHeader {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioHeader
    audioHeader::const_reference get_audioHeader () const;
    audioHeader::reference ref_audioHeader ();
    audioHeader::reference set_audioHeader ();
    audioHeader::reference set_audioHeader (bool value);
    void swap(V75Capability& other);
    V75Capability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// QOSMode
//

class QOSMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    QOSMode(const void* info) : Inherited(info) {}
  public:
    QOSMode() : Inherited(&theInfo) {}
    class guaranteedQOS {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class guaranteedQOS

    guaranteedQOS::reference select_guaranteedQOS (); 
    bool guaranteedQOS_isSelected() const;

    class controlledLoad {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class controlledLoad

    controlledLoad::reference select_controlledLoad (); 
    bool controlledLoad_isSelected() const;

    QOSMode(guaranteedQOS::Id id, guaranteedQOS::const_reference value);
    QOSMode(controlledLoad::Id id, controlledLoad::const_reference value);
    void swap(QOSMode & other);
    QOSMode(const QOSMode & other)
    : Inherited(other) {} 

    QOSMode & operator = (const QOSMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    QOSMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// ATMParameters
//

class ATMParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ATMParameters(const void* info) : Inherited(info) {}
  public:
    ATMParameters() : Inherited(&theInfo) {}
    ATMParameters(const ATMParameters & other) : Inherited(other)
    {}
    ATMParameters& operator = (const ATMParameters& other)
    { Inherited::operator = (other); return *this; } 
    class maxNTUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxNTUSize
    maxNTUSize::const_reference get_maxNTUSize () const;
    maxNTUSize::reference ref_maxNTUSize ();
    maxNTUSize::reference set_maxNTUSize ();
    maxNTUSize::reference set_maxNTUSize (maxNTUSize::value_type::int_type value);
    class atmUBR {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atmUBR
    atmUBR::const_reference get_atmUBR () const;
    atmUBR::reference ref_atmUBR ();
    atmUBR::reference set_atmUBR ();
    atmUBR::reference set_atmUBR (bool value);
    class atmrtVBR {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atmrtVBR
    atmrtVBR::const_reference get_atmrtVBR () const;
    atmrtVBR::reference ref_atmrtVBR ();
    atmrtVBR::reference set_atmrtVBR ();
    atmrtVBR::reference set_atmrtVBR (bool value);
    class atmnrtVBR {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atmnrtVBR
    atmnrtVBR::const_reference get_atmnrtVBR () const;
    atmnrtVBR::reference ref_atmnrtVBR ();
    atmnrtVBR::reference set_atmnrtVBR ();
    atmnrtVBR::reference set_atmnrtVBR (bool value);
    class atmABR {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atmABR
    atmABR::const_reference get_atmABR () const;
    atmABR::reference ref_atmABR ();
    atmABR::reference set_atmABR ();
    atmABR::reference set_atmABR (bool value);
    class atmCBR {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atmCBR
    atmCBR::const_reference get_atmCBR () const;
    atmCBR::reference ref_atmCBR ();
    atmCBR::reference set_atmCBR ();
    atmCBR::reference set_atmCBR (bool value);
    void swap(ATMParameters& other);
    ATMParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// H261VideoCapability
//

class H261VideoCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H261VideoCapability(const void* info) : Inherited(info) {}
  public:
    H261VideoCapability() : Inherited(&theInfo) {}
    H261VideoCapability(const H261VideoCapability & other) : Inherited(other)
    {}
    H261VideoCapability& operator = (const H261VideoCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_qcifMPI,
      e_cifMPI,
      e_videoBadMBsCap
    };

    class qcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcifMPI
    qcifMPI::const_reference get_qcifMPI () const;
    qcifMPI::reference ref_qcifMPI ();
    qcifMPI::reference set_qcifMPI ();
    qcifMPI::reference set_qcifMPI (qcifMPI::value_type::int_type value);
    void omit_qcifMPI ();
    bool qcifMPI_isPresent () const;
    class cifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cifMPI
    cifMPI::const_reference get_cifMPI () const;
    cifMPI::reference ref_cifMPI ();
    cifMPI::reference set_cifMPI ();
    cifMPI::reference set_cifMPI (cifMPI::value_type::int_type value);
    void omit_cifMPI ();
    bool cifMPI_isPresent () const;
    class temporalSpatialTradeOffCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class temporalSpatialTradeOffCapability
    temporalSpatialTradeOffCapability::const_reference get_temporalSpatialTradeOffCapability () const;
    temporalSpatialTradeOffCapability::reference ref_temporalSpatialTradeOffCapability ();
    temporalSpatialTradeOffCapability::reference set_temporalSpatialTradeOffCapability ();
    temporalSpatialTradeOffCapability::reference set_temporalSpatialTradeOffCapability (bool value);
    class maxBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 19200>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxBitRate
    maxBitRate::const_reference get_maxBitRate () const;
    maxBitRate::reference ref_maxBitRate ();
    maxBitRate::reference set_maxBitRate ();
    maxBitRate::reference set_maxBitRate (maxBitRate::value_type::int_type value);
    class stillImageTransmission {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class stillImageTransmission
    stillImageTransmission::const_reference get_stillImageTransmission () const;
    stillImageTransmission::reference ref_stillImageTransmission ();
    stillImageTransmission::reference set_stillImageTransmission ();
    stillImageTransmission::reference set_stillImageTransmission (bool value);
    class videoBadMBsCap {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBadMBsCap
    videoBadMBsCap::const_reference get_videoBadMBsCap () const;
    videoBadMBsCap::reference ref_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap (bool value);
    void omit_videoBadMBsCap ();
    bool videoBadMBsCap_isPresent () const;
    void swap(H261VideoCapability& other);
    H261VideoCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[6];
};

//
// H262VideoCapability
//

class H262VideoCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H262VideoCapability(const void* info) : Inherited(info) {}
  public:
    H262VideoCapability() : Inherited(&theInfo) {}
    H262VideoCapability(const H262VideoCapability & other) : Inherited(other)
    {}
    H262VideoCapability& operator = (const H262VideoCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_videoBitRate,
      e_vbvBufferSize,
      e_samplesPerLine,
      e_linesPerFrame,
      e_framesPerSecond,
      e_luminanceSampleRate
    };

    class profileAndLevel_SPatML {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SPatML
    profileAndLevel_SPatML::const_reference get_profileAndLevel_SPatML () const;
    profileAndLevel_SPatML::reference ref_profileAndLevel_SPatML ();
    profileAndLevel_SPatML::reference set_profileAndLevel_SPatML ();
    profileAndLevel_SPatML::reference set_profileAndLevel_SPatML (bool value);
    class profileAndLevel_MPatLL {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatLL
    profileAndLevel_MPatLL::const_reference get_profileAndLevel_MPatLL () const;
    profileAndLevel_MPatLL::reference ref_profileAndLevel_MPatLL ();
    profileAndLevel_MPatLL::reference set_profileAndLevel_MPatLL ();
    profileAndLevel_MPatLL::reference set_profileAndLevel_MPatLL (bool value);
    class profileAndLevel_MPatML {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatML
    profileAndLevel_MPatML::const_reference get_profileAndLevel_MPatML () const;
    profileAndLevel_MPatML::reference ref_profileAndLevel_MPatML ();
    profileAndLevel_MPatML::reference set_profileAndLevel_MPatML ();
    profileAndLevel_MPatML::reference set_profileAndLevel_MPatML (bool value);
    class profileAndLevel_MPatH_14 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatH_14
    profileAndLevel_MPatH_14::const_reference get_profileAndLevel_MPatH_14 () const;
    profileAndLevel_MPatH_14::reference ref_profileAndLevel_MPatH_14 ();
    profileAndLevel_MPatH_14::reference set_profileAndLevel_MPatH_14 ();
    profileAndLevel_MPatH_14::reference set_profileAndLevel_MPatH_14 (bool value);
    class profileAndLevel_MPatHL {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatHL
    profileAndLevel_MPatHL::const_reference get_profileAndLevel_MPatHL () const;
    profileAndLevel_MPatHL::reference ref_profileAndLevel_MPatHL ();
    profileAndLevel_MPatHL::reference set_profileAndLevel_MPatHL ();
    profileAndLevel_MPatHL::reference set_profileAndLevel_MPatHL (bool value);
    class profileAndLevel_SNRatLL {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SNRatLL
    profileAndLevel_SNRatLL::const_reference get_profileAndLevel_SNRatLL () const;
    profileAndLevel_SNRatLL::reference ref_profileAndLevel_SNRatLL ();
    profileAndLevel_SNRatLL::reference set_profileAndLevel_SNRatLL ();
    profileAndLevel_SNRatLL::reference set_profileAndLevel_SNRatLL (bool value);
    class profileAndLevel_SNRatML {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SNRatML
    profileAndLevel_SNRatML::const_reference get_profileAndLevel_SNRatML () const;
    profileAndLevel_SNRatML::reference ref_profileAndLevel_SNRatML ();
    profileAndLevel_SNRatML::reference set_profileAndLevel_SNRatML ();
    profileAndLevel_SNRatML::reference set_profileAndLevel_SNRatML (bool value);
    class profileAndLevel_SpatialatH_14 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SpatialatH_14
    profileAndLevel_SpatialatH_14::const_reference get_profileAndLevel_SpatialatH_14 () const;
    profileAndLevel_SpatialatH_14::reference ref_profileAndLevel_SpatialatH_14 ();
    profileAndLevel_SpatialatH_14::reference set_profileAndLevel_SpatialatH_14 ();
    profileAndLevel_SpatialatH_14::reference set_profileAndLevel_SpatialatH_14 (bool value);
    class profileAndLevel_HPatML {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_HPatML
    profileAndLevel_HPatML::const_reference get_profileAndLevel_HPatML () const;
    profileAndLevel_HPatML::reference ref_profileAndLevel_HPatML ();
    profileAndLevel_HPatML::reference set_profileAndLevel_HPatML ();
    profileAndLevel_HPatML::reference set_profileAndLevel_HPatML (bool value);
    class profileAndLevel_HPatH_14 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_HPatH_14
    profileAndLevel_HPatH_14::const_reference get_profileAndLevel_HPatH_14 () const;
    profileAndLevel_HPatH_14::reference ref_profileAndLevel_HPatH_14 ();
    profileAndLevel_HPatH_14::reference set_profileAndLevel_HPatH_14 ();
    profileAndLevel_HPatH_14::reference set_profileAndLevel_HPatH_14 (bool value);
    class profileAndLevel_HPatHL {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_HPatHL
    profileAndLevel_HPatHL::const_reference get_profileAndLevel_HPatHL () const;
    profileAndLevel_HPatHL::reference ref_profileAndLevel_HPatHL ();
    profileAndLevel_HPatHL::reference set_profileAndLevel_HPatHL ();
    profileAndLevel_HPatHL::reference set_profileAndLevel_HPatHL (bool value);
    class videoBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1073741823>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBitRate
    videoBitRate::const_reference get_videoBitRate () const;
    videoBitRate::reference ref_videoBitRate ();
    videoBitRate::reference set_videoBitRate ();
    videoBitRate::reference set_videoBitRate (videoBitRate::value_type::int_type value);
    void omit_videoBitRate ();
    bool videoBitRate_isPresent () const;
    class vbvBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vbvBufferSize
    vbvBufferSize::const_reference get_vbvBufferSize () const;
    vbvBufferSize::reference ref_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize (vbvBufferSize::value_type::int_type value);
    void omit_vbvBufferSize ();
    bool vbvBufferSize_isPresent () const;
    class samplesPerLine {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samplesPerLine
    samplesPerLine::const_reference get_samplesPerLine () const;
    samplesPerLine::reference ref_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine (samplesPerLine::value_type::int_type value);
    void omit_samplesPerLine ();
    bool samplesPerLine_isPresent () const;
    class linesPerFrame {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class linesPerFrame
    linesPerFrame::const_reference get_linesPerFrame () const;
    linesPerFrame::reference ref_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame (linesPerFrame::value_type::int_type value);
    void omit_linesPerFrame ();
    bool linesPerFrame_isPresent () const;
    class framesPerSecond {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class framesPerSecond
    framesPerSecond::const_reference get_framesPerSecond () const;
    framesPerSecond::reference ref_framesPerSecond ();
    framesPerSecond::reference set_framesPerSecond ();
    framesPerSecond::reference set_framesPerSecond (framesPerSecond::value_type::int_type value);
    void omit_framesPerSecond ();
    bool framesPerSecond_isPresent () const;
    class luminanceSampleRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class luminanceSampleRate
    luminanceSampleRate::const_reference get_luminanceSampleRate () const;
    luminanceSampleRate::reference ref_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate (luminanceSampleRate::value_type::int_type value);
    void omit_luminanceSampleRate ();
    bool luminanceSampleRate_isPresent () const;
    class videoBadMBsCap {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBadMBsCap
    videoBadMBsCap::const_reference get_videoBadMBsCap () const;
    videoBadMBsCap::reference ref_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap (bool value);
    void swap(H262VideoCapability& other);
    H262VideoCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[18];
    static int fieldIds[18];
    static const char* fieldNames[18];
};

//
// TransparencyParameters
//

class TransparencyParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TransparencyParameters(const void* info) : Inherited(info) {}
  public:
    TransparencyParameters() : Inherited(&theInfo) {}
    TransparencyParameters(const TransparencyParameters & other) : Inherited(other)
    {}
    TransparencyParameters& operator = (const TransparencyParameters& other)
    { Inherited::operator = (other); return *this; } 
    class presentationOrder {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class presentationOrder
    presentationOrder::const_reference get_presentationOrder () const;
    presentationOrder::reference ref_presentationOrder ();
    presentationOrder::reference set_presentationOrder ();
    presentationOrder::reference set_presentationOrder (presentationOrder::value_type::int_type value);
    class offset_x {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, -262144, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class offset_x
    offset_x::const_reference get_offset_x () const;
    offset_x::reference ref_offset_x ();
    offset_x::reference set_offset_x ();
    offset_x::reference set_offset_x (offset_x::value_type::int_type value);
    class offset_y {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, -262144, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class offset_y
    offset_y::const_reference get_offset_y () const;
    offset_y::reference ref_offset_y ();
    offset_y::reference set_offset_y ();
    offset_y::reference set_offset_y (offset_y::value_type::int_type value);
    class scale_x {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class scale_x
    scale_x::const_reference get_scale_x () const;
    scale_x::reference ref_scale_x ();
    scale_x::reference set_scale_x ();
    scale_x::reference set_scale_x (scale_x::value_type::int_type value);
    class scale_y {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class scale_y
    scale_y::const_reference get_scale_y () const;
    scale_y::reference ref_scale_y ();
    scale_y::reference set_scale_y ();
    scale_y::reference set_scale_y (scale_y::value_type::int_type value);
    void swap(TransparencyParameters& other);
    TransparencyParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// CustomPictureClockFrequency
//

class CustomPictureClockFrequency : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CustomPictureClockFrequency(const void* info) : Inherited(info) {}
  public:
    CustomPictureClockFrequency() : Inherited(&theInfo) {}
    CustomPictureClockFrequency(const CustomPictureClockFrequency & other) : Inherited(other)
    {}
    CustomPictureClockFrequency& operator = (const CustomPictureClockFrequency& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_sqcifMPI,
      e_qcifMPI,
      e_cifMPI,
      e_cif4MPI,
      e_cif16MPI
    };

    class clockConversionCode {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1000, 1001>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class clockConversionCode
    clockConversionCode::const_reference get_clockConversionCode () const;
    clockConversionCode::reference ref_clockConversionCode ();
    clockConversionCode::reference set_clockConversionCode ();
    clockConversionCode::reference set_clockConversionCode (clockConversionCode::value_type::int_type value);
    class clockDivisor {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class clockDivisor
    clockDivisor::const_reference get_clockDivisor () const;
    clockDivisor::reference ref_clockDivisor ();
    clockDivisor::reference set_clockDivisor ();
    clockDivisor::reference set_clockDivisor (clockDivisor::value_type::int_type value);
    class sqcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sqcifMPI
    sqcifMPI::const_reference get_sqcifMPI () const;
    sqcifMPI::reference ref_sqcifMPI ();
    sqcifMPI::reference set_sqcifMPI ();
    sqcifMPI::reference set_sqcifMPI (sqcifMPI::value_type::int_type value);
    void omit_sqcifMPI ();
    bool sqcifMPI_isPresent () const;
    class qcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcifMPI
    qcifMPI::const_reference get_qcifMPI () const;
    qcifMPI::reference ref_qcifMPI ();
    qcifMPI::reference set_qcifMPI ();
    qcifMPI::reference set_qcifMPI (qcifMPI::value_type::int_type value);
    void omit_qcifMPI ();
    bool qcifMPI_isPresent () const;
    class cifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cifMPI
    cifMPI::const_reference get_cifMPI () const;
    cifMPI::reference ref_cifMPI ();
    cifMPI::reference set_cifMPI ();
    cifMPI::reference set_cifMPI (cifMPI::value_type::int_type value);
    void omit_cifMPI ();
    bool cifMPI_isPresent () const;
    class cif4MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif4MPI
    cif4MPI::const_reference get_cif4MPI () const;
    cif4MPI::reference ref_cif4MPI ();
    cif4MPI::reference set_cif4MPI ();
    cif4MPI::reference set_cif4MPI (cif4MPI::value_type::int_type value);
    void omit_cif4MPI ();
    bool cif4MPI_isPresent () const;
    class cif16MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif16MPI
    cif16MPI::const_reference get_cif16MPI () const;
    cif16MPI::reference ref_cif16MPI ();
    cif16MPI::reference set_cif16MPI ();
    cif16MPI::reference set_cif16MPI (cif16MPI::value_type::int_type value);
    void omit_cif16MPI ();
    bool cif16MPI_isPresent () const;
    void swap(CustomPictureClockFrequency& other);
    CustomPictureClockFrequency * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* fieldNames[7];
};

//
// H263Version3Options
//

class H263Version3Options : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263Version3Options(const void* info) : Inherited(info) {}
  public:
    H263Version3Options() : Inherited(&theInfo) {}
    H263Version3Options(const H263Version3Options & other) : Inherited(other)
    {}
    H263Version3Options& operator = (const H263Version3Options& other)
    { Inherited::operator = (other); return *this; } 
    class dataPartitionedSlices {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataPartitionedSlices
    dataPartitionedSlices::const_reference get_dataPartitionedSlices () const;
    dataPartitionedSlices::reference ref_dataPartitionedSlices ();
    dataPartitionedSlices::reference set_dataPartitionedSlices ();
    dataPartitionedSlices::reference set_dataPartitionedSlices (bool value);
    class fixedPointIDCT0 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fixedPointIDCT0
    fixedPointIDCT0::const_reference get_fixedPointIDCT0 () const;
    fixedPointIDCT0::reference ref_fixedPointIDCT0 ();
    fixedPointIDCT0::reference set_fixedPointIDCT0 ();
    fixedPointIDCT0::reference set_fixedPointIDCT0 (bool value);
    class interlacedFields {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class interlacedFields
    interlacedFields::const_reference get_interlacedFields () const;
    interlacedFields::reference ref_interlacedFields ();
    interlacedFields::reference set_interlacedFields ();
    interlacedFields::reference set_interlacedFields (bool value);
    class currentPictureHeaderRepetition {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class currentPictureHeaderRepetition
    currentPictureHeaderRepetition::const_reference get_currentPictureHeaderRepetition () const;
    currentPictureHeaderRepetition::reference ref_currentPictureHeaderRepetition ();
    currentPictureHeaderRepetition::reference set_currentPictureHeaderRepetition ();
    currentPictureHeaderRepetition::reference set_currentPictureHeaderRepetition (bool value);
    class previousPictureHeaderRepetition {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class previousPictureHeaderRepetition
    previousPictureHeaderRepetition::const_reference get_previousPictureHeaderRepetition () const;
    previousPictureHeaderRepetition::reference ref_previousPictureHeaderRepetition ();
    previousPictureHeaderRepetition::reference set_previousPictureHeaderRepetition ();
    previousPictureHeaderRepetition::reference set_previousPictureHeaderRepetition (bool value);
    class nextPictureHeaderRepetition {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nextPictureHeaderRepetition
    nextPictureHeaderRepetition::const_reference get_nextPictureHeaderRepetition () const;
    nextPictureHeaderRepetition::reference ref_nextPictureHeaderRepetition ();
    nextPictureHeaderRepetition::reference set_nextPictureHeaderRepetition ();
    nextPictureHeaderRepetition::reference set_nextPictureHeaderRepetition (bool value);
    class pictureNumber {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pictureNumber
    pictureNumber::const_reference get_pictureNumber () const;
    pictureNumber::reference ref_pictureNumber ();
    pictureNumber::reference set_pictureNumber ();
    pictureNumber::reference set_pictureNumber (bool value);
    class spareReferencePictures {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class spareReferencePictures
    spareReferencePictures::const_reference get_spareReferencePictures () const;
    spareReferencePictures::reference ref_spareReferencePictures ();
    spareReferencePictures::reference set_spareReferencePictures ();
    spareReferencePictures::reference set_spareReferencePictures (bool value);
    void swap(H263Version3Options& other);
    H263Version3Options * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[8];
    static int fieldIds[8];
    static const char* fieldNames[8];
};

//
// IS11172VideoCapability
//

class IS11172VideoCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172VideoCapability(const void* info) : Inherited(info) {}
  public:
    IS11172VideoCapability() : Inherited(&theInfo) {}
    IS11172VideoCapability(const IS11172VideoCapability & other) : Inherited(other)
    {}
    IS11172VideoCapability& operator = (const IS11172VideoCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_videoBitRate,
      e_vbvBufferSize,
      e_samplesPerLine,
      e_linesPerFrame,
      e_pictureRate,
      e_luminanceSampleRate,
      e_videoBadMBsCap
    };

    class constrainedBitstream {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class constrainedBitstream
    constrainedBitstream::const_reference get_constrainedBitstream () const;
    constrainedBitstream::reference ref_constrainedBitstream ();
    constrainedBitstream::reference set_constrainedBitstream ();
    constrainedBitstream::reference set_constrainedBitstream (bool value);
    class videoBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1073741823>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBitRate
    videoBitRate::const_reference get_videoBitRate () const;
    videoBitRate::reference ref_videoBitRate ();
    videoBitRate::reference set_videoBitRate ();
    videoBitRate::reference set_videoBitRate (videoBitRate::value_type::int_type value);
    void omit_videoBitRate ();
    bool videoBitRate_isPresent () const;
    class vbvBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vbvBufferSize
    vbvBufferSize::const_reference get_vbvBufferSize () const;
    vbvBufferSize::reference ref_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize (vbvBufferSize::value_type::int_type value);
    void omit_vbvBufferSize ();
    bool vbvBufferSize_isPresent () const;
    class samplesPerLine {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samplesPerLine
    samplesPerLine::const_reference get_samplesPerLine () const;
    samplesPerLine::reference ref_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine (samplesPerLine::value_type::int_type value);
    void omit_samplesPerLine ();
    bool samplesPerLine_isPresent () const;
    class linesPerFrame {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class linesPerFrame
    linesPerFrame::const_reference get_linesPerFrame () const;
    linesPerFrame::reference ref_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame (linesPerFrame::value_type::int_type value);
    void omit_linesPerFrame ();
    bool linesPerFrame_isPresent () const;
    class pictureRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pictureRate
    pictureRate::const_reference get_pictureRate () const;
    pictureRate::reference ref_pictureRate ();
    pictureRate::reference set_pictureRate ();
    pictureRate::reference set_pictureRate (pictureRate::value_type::int_type value);
    void omit_pictureRate ();
    bool pictureRate_isPresent () const;
    class luminanceSampleRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class luminanceSampleRate
    luminanceSampleRate::const_reference get_luminanceSampleRate () const;
    luminanceSampleRate::reference ref_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate (luminanceSampleRate::value_type::int_type value);
    void omit_luminanceSampleRate ();
    bool luminanceSampleRate_isPresent () const;
    class videoBadMBsCap {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBadMBsCap
    videoBadMBsCap::const_reference get_videoBadMBsCap () const;
    videoBadMBsCap::reference ref_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap (bool value);
    void omit_videoBadMBsCap ();
    bool videoBadMBsCap_isPresent () const;
    void swap(IS11172VideoCapability& other);
    IS11172VideoCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[8];
    static int fieldIds[8];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[8];
};

//
// G729Extensions
//

class G729Extensions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    G729Extensions(const void* info) : Inherited(info) {}
  public:
    G729Extensions() : Inherited(&theInfo) {}
    G729Extensions(const G729Extensions & other) : Inherited(other)
    {}
    G729Extensions& operator = (const G729Extensions& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_audioUnit
    };

    class audioUnit {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioUnit
    audioUnit::const_reference get_audioUnit () const;
    audioUnit::reference ref_audioUnit ();
    audioUnit::reference set_audioUnit ();
    audioUnit::reference set_audioUnit (audioUnit::value_type::int_type value);
    void omit_audioUnit ();
    bool audioUnit_isPresent () const;
    class annexA {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexA
    annexA::const_reference get_annexA () const;
    annexA::reference ref_annexA ();
    annexA::reference set_annexA ();
    annexA::reference set_annexA (bool value);
    class annexB {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexB
    annexB::const_reference get_annexB () const;
    annexB::reference ref_annexB ();
    annexB::reference set_annexB ();
    annexB::reference set_annexB (bool value);
    class annexD {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexD
    annexD::const_reference get_annexD () const;
    annexD::reference ref_annexD ();
    annexD::reference set_annexD ();
    annexD::reference set_annexD (bool value);
    class annexE {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexE
    annexE::const_reference get_annexE () const;
    annexE::reference ref_annexE ();
    annexE::reference set_annexE ();
    annexE::reference set_annexE (bool value);
    class annexF {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexF
    annexF::const_reference get_annexF () const;
    annexF::reference ref_annexF ();
    annexF::reference set_annexF ();
    annexF::reference set_annexF (bool value);
    class annexG {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexG
    annexG::const_reference get_annexG () const;
    annexG::reference ref_annexG ();
    annexG::reference set_annexG ();
    annexG::reference set_annexG (bool value);
    class annexH {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class annexH
    annexH::const_reference get_annexH () const;
    annexH::reference ref_annexH ();
    annexH::reference set_annexH ();
    annexH::reference set_annexH (bool value);
    void swap(G729Extensions& other);
    G729Extensions * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[8];
    static int fieldIds[8];
    static const char* fieldNames[8];
};

//
// IS11172AudioCapability
//

class IS11172AudioCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172AudioCapability(const void* info) : Inherited(info) {}
  public:
    IS11172AudioCapability() : Inherited(&theInfo) {}
    IS11172AudioCapability(const IS11172AudioCapability & other) : Inherited(other)
    {}
    IS11172AudioCapability& operator = (const IS11172AudioCapability& other)
    { Inherited::operator = (other); return *this; } 
    class audioLayer1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer1
    audioLayer1::const_reference get_audioLayer1 () const;
    audioLayer1::reference ref_audioLayer1 ();
    audioLayer1::reference set_audioLayer1 ();
    audioLayer1::reference set_audioLayer1 (bool value);
    class audioLayer2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer2
    audioLayer2::const_reference get_audioLayer2 () const;
    audioLayer2::reference ref_audioLayer2 ();
    audioLayer2::reference set_audioLayer2 ();
    audioLayer2::reference set_audioLayer2 (bool value);
    class audioLayer3 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer3
    audioLayer3::const_reference get_audioLayer3 () const;
    audioLayer3::reference ref_audioLayer3 ();
    audioLayer3::reference set_audioLayer3 ();
    audioLayer3::reference set_audioLayer3 (bool value);
    class audioSampling32k {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling32k
    audioSampling32k::const_reference get_audioSampling32k () const;
    audioSampling32k::reference ref_audioSampling32k ();
    audioSampling32k::reference set_audioSampling32k ();
    audioSampling32k::reference set_audioSampling32k (bool value);
    class audioSampling44k1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling44k1
    audioSampling44k1::const_reference get_audioSampling44k1 () const;
    audioSampling44k1::reference ref_audioSampling44k1 ();
    audioSampling44k1::reference set_audioSampling44k1 ();
    audioSampling44k1::reference set_audioSampling44k1 (bool value);
    class audioSampling48k {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling48k
    audioSampling48k::const_reference get_audioSampling48k () const;
    audioSampling48k::reference ref_audioSampling48k ();
    audioSampling48k::reference set_audioSampling48k ();
    audioSampling48k::reference set_audioSampling48k (bool value);
    class singleChannel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class singleChannel
    singleChannel::const_reference get_singleChannel () const;
    singleChannel::reference ref_singleChannel ();
    singleChannel::reference set_singleChannel ();
    singleChannel::reference set_singleChannel (bool value);
    class twoChannels {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoChannels
    twoChannels::const_reference get_twoChannels () const;
    twoChannels::reference ref_twoChannels ();
    twoChannels::reference set_twoChannels ();
    twoChannels::reference set_twoChannels (bool value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 448>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    void swap(IS11172AudioCapability& other);
    IS11172AudioCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[9];
    static int fieldIds[9];
    static const char* fieldNames[9];
};

//
// IS13818AudioCapability
//

class IS13818AudioCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS13818AudioCapability(const void* info) : Inherited(info) {}
  public:
    IS13818AudioCapability() : Inherited(&theInfo) {}
    IS13818AudioCapability(const IS13818AudioCapability & other) : Inherited(other)
    {}
    IS13818AudioCapability& operator = (const IS13818AudioCapability& other)
    { Inherited::operator = (other); return *this; } 
    class audioLayer1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer1
    audioLayer1::const_reference get_audioLayer1 () const;
    audioLayer1::reference ref_audioLayer1 ();
    audioLayer1::reference set_audioLayer1 ();
    audioLayer1::reference set_audioLayer1 (bool value);
    class audioLayer2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer2
    audioLayer2::const_reference get_audioLayer2 () const;
    audioLayer2::reference ref_audioLayer2 ();
    audioLayer2::reference set_audioLayer2 ();
    audioLayer2::reference set_audioLayer2 (bool value);
    class audioLayer3 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer3
    audioLayer3::const_reference get_audioLayer3 () const;
    audioLayer3::reference ref_audioLayer3 ();
    audioLayer3::reference set_audioLayer3 ();
    audioLayer3::reference set_audioLayer3 (bool value);
    class audioSampling16k {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling16k
    audioSampling16k::const_reference get_audioSampling16k () const;
    audioSampling16k::reference ref_audioSampling16k ();
    audioSampling16k::reference set_audioSampling16k ();
    audioSampling16k::reference set_audioSampling16k (bool value);
    class audioSampling22k05 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling22k05
    audioSampling22k05::const_reference get_audioSampling22k05 () const;
    audioSampling22k05::reference ref_audioSampling22k05 ();
    audioSampling22k05::reference set_audioSampling22k05 ();
    audioSampling22k05::reference set_audioSampling22k05 (bool value);
    class audioSampling24k {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling24k
    audioSampling24k::const_reference get_audioSampling24k () const;
    audioSampling24k::reference ref_audioSampling24k ();
    audioSampling24k::reference set_audioSampling24k ();
    audioSampling24k::reference set_audioSampling24k (bool value);
    class audioSampling32k {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling32k
    audioSampling32k::const_reference get_audioSampling32k () const;
    audioSampling32k::reference ref_audioSampling32k ();
    audioSampling32k::reference set_audioSampling32k ();
    audioSampling32k::reference set_audioSampling32k (bool value);
    class audioSampling44k1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling44k1
    audioSampling44k1::const_reference get_audioSampling44k1 () const;
    audioSampling44k1::reference ref_audioSampling44k1 ();
    audioSampling44k1::reference set_audioSampling44k1 ();
    audioSampling44k1::reference set_audioSampling44k1 (bool value);
    class audioSampling48k {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling48k
    audioSampling48k::const_reference get_audioSampling48k () const;
    audioSampling48k::reference ref_audioSampling48k ();
    audioSampling48k::reference set_audioSampling48k ();
    audioSampling48k::reference set_audioSampling48k (bool value);
    class singleChannel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class singleChannel
    singleChannel::const_reference get_singleChannel () const;
    singleChannel::reference ref_singleChannel ();
    singleChannel::reference set_singleChannel ();
    singleChannel::reference set_singleChannel (bool value);
    class twoChannels {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoChannels
    twoChannels::const_reference get_twoChannels () const;
    twoChannels::reference ref_twoChannels ();
    twoChannels::reference set_twoChannels ();
    twoChannels::reference set_twoChannels (bool value);
    class threeChannels2_1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class threeChannels2_1
    threeChannels2_1::const_reference get_threeChannels2_1 () const;
    threeChannels2_1::reference ref_threeChannels2_1 ();
    threeChannels2_1::reference set_threeChannels2_1 ();
    threeChannels2_1::reference set_threeChannels2_1 (bool value);
    class threeChannels3_0 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class threeChannels3_0
    threeChannels3_0::const_reference get_threeChannels3_0 () const;
    threeChannels3_0::reference ref_threeChannels3_0 ();
    threeChannels3_0::reference set_threeChannels3_0 ();
    threeChannels3_0::reference set_threeChannels3_0 (bool value);
    class fourChannels2_0_2_0 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fourChannels2_0_2_0
    fourChannels2_0_2_0::const_reference get_fourChannels2_0_2_0 () const;
    fourChannels2_0_2_0::reference ref_fourChannels2_0_2_0 ();
    fourChannels2_0_2_0::reference set_fourChannels2_0_2_0 ();
    fourChannels2_0_2_0::reference set_fourChannels2_0_2_0 (bool value);
    class fourChannels2_2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fourChannels2_2
    fourChannels2_2::const_reference get_fourChannels2_2 () const;
    fourChannels2_2::reference ref_fourChannels2_2 ();
    fourChannels2_2::reference set_fourChannels2_2 ();
    fourChannels2_2::reference set_fourChannels2_2 (bool value);
    class fourChannels3_1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fourChannels3_1
    fourChannels3_1::const_reference get_fourChannels3_1 () const;
    fourChannels3_1::reference ref_fourChannels3_1 ();
    fourChannels3_1::reference set_fourChannels3_1 ();
    fourChannels3_1::reference set_fourChannels3_1 (bool value);
    class fiveChannels3_0_2_0 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fiveChannels3_0_2_0
    fiveChannels3_0_2_0::const_reference get_fiveChannels3_0_2_0 () const;
    fiveChannels3_0_2_0::reference ref_fiveChannels3_0_2_0 ();
    fiveChannels3_0_2_0::reference set_fiveChannels3_0_2_0 ();
    fiveChannels3_0_2_0::reference set_fiveChannels3_0_2_0 (bool value);
    class fiveChannels3_2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fiveChannels3_2
    fiveChannels3_2::const_reference get_fiveChannels3_2 () const;
    fiveChannels3_2::reference ref_fiveChannels3_2 ();
    fiveChannels3_2::reference set_fiveChannels3_2 ();
    fiveChannels3_2::reference set_fiveChannels3_2 (bool value);
    class lowFrequencyEnhancement {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowFrequencyEnhancement
    lowFrequencyEnhancement::const_reference get_lowFrequencyEnhancement () const;
    lowFrequencyEnhancement::reference ref_lowFrequencyEnhancement ();
    lowFrequencyEnhancement::reference set_lowFrequencyEnhancement ();
    lowFrequencyEnhancement::reference set_lowFrequencyEnhancement (bool value);
    class multilingual {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multilingual
    multilingual::const_reference get_multilingual () const;
    multilingual::reference ref_multilingual ();
    multilingual::reference set_multilingual ();
    multilingual::reference set_multilingual (bool value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 1130>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    void swap(IS13818AudioCapability& other);
    IS13818AudioCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[21];
    static int fieldIds[21];
    static const char* fieldNames[21];
};

//
// GSMAudioCapability
//

class GSMAudioCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    GSMAudioCapability(const void* info) : Inherited(info) {}
  public:
    GSMAudioCapability() : Inherited(&theInfo) {}
    GSMAudioCapability(const GSMAudioCapability & other) : Inherited(other)
    {}
    GSMAudioCapability& operator = (const GSMAudioCapability& other)
    { Inherited::operator = (other); return *this; } 
    class audioUnitSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioUnitSize
    audioUnitSize::const_reference get_audioUnitSize () const;
    audioUnitSize::reference ref_audioUnitSize ();
    audioUnitSize::reference set_audioUnitSize ();
    audioUnitSize::reference set_audioUnitSize (audioUnitSize::value_type::int_type value);
    class comfortNoise {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class comfortNoise
    comfortNoise::const_reference get_comfortNoise () const;
    comfortNoise::reference ref_comfortNoise ();
    comfortNoise::reference set_comfortNoise ();
    comfortNoise::reference set_comfortNoise (bool value);
    class scrambled {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class scrambled
    scrambled::const_reference get_scrambled () const;
    scrambled::reference ref_scrambled ();
    scrambled::reference set_scrambled ();
    scrambled::reference set_scrambled (bool value);
    void swap(GSMAudioCapability& other);
    GSMAudioCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// VBDCapability
//

class AudioCapability;

class VBDCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VBDCapability(const void* info) : Inherited(info) {}
  public:
    VBDCapability() : Inherited(&theInfo) {}
    VBDCapability(const VBDCapability & other) : Inherited(other)
    {}
    VBDCapability& operator = (const VBDCapability& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(VBDCapability& other);
    VBDCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// V42bis
//

class V42bis : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V42bis(const void* info) : Inherited(info) {}
  public:
    V42bis() : Inherited(&theInfo) {}
    V42bis(const V42bis & other) : Inherited(other)
    {}
    V42bis& operator = (const V42bis& other)
    { Inherited::operator = (other); return *this; } 
    class numberOfCodewords {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65536>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfCodewords
    numberOfCodewords::const_reference get_numberOfCodewords () const;
    numberOfCodewords::reference ref_numberOfCodewords ();
    numberOfCodewords::reference set_numberOfCodewords ();
    numberOfCodewords::reference set_numberOfCodewords (numberOfCodewords::value_type::int_type value);
    class maximumStringLength {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumStringLength
    maximumStringLength::const_reference get_maximumStringLength () const;
    maximumStringLength::reference ref_maximumStringLength ();
    maximumStringLength::reference set_maximumStringLength ();
    maximumStringLength::reference set_maximumStringLength (maximumStringLength::value_type::int_type value);
    void swap(V42bis& other);
    V42bis * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// T38FaxRateManagement
//

class T38FaxRateManagement : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T38FaxRateManagement(const void* info) : Inherited(info) {}
  public:
    T38FaxRateManagement() : Inherited(&theInfo) {}
    class localTCF {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class localTCF

    localTCF::reference select_localTCF (); 
    bool localTCF_isSelected() const;

    class transferredTCF {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transferredTCF

    transferredTCF::reference select_transferredTCF (); 
    bool transferredTCF_isSelected() const;

    T38FaxRateManagement(localTCF::Id id, localTCF::const_reference value);
    T38FaxRateManagement(transferredTCF::Id id, transferredTCF::const_reference value);
    void swap(T38FaxRateManagement & other);
    T38FaxRateManagement(const T38FaxRateManagement & other)
    : Inherited(other) {} 

    T38FaxRateManagement & operator = (const T38FaxRateManagement & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    T38FaxRateManagement * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// T38FaxTcpOptions
//

class T38FaxTcpOptions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T38FaxTcpOptions(const void* info) : Inherited(info) {}
  public:
    T38FaxTcpOptions() : Inherited(&theInfo) {}
    T38FaxTcpOptions(const T38FaxTcpOptions & other) : Inherited(other)
    {}
    T38FaxTcpOptions& operator = (const T38FaxTcpOptions& other)
    { Inherited::operator = (other); return *this; } 
    class t38TCPBidirectionalMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38TCPBidirectionalMode
    t38TCPBidirectionalMode::const_reference get_t38TCPBidirectionalMode () const;
    t38TCPBidirectionalMode::reference ref_t38TCPBidirectionalMode ();
    t38TCPBidirectionalMode::reference set_t38TCPBidirectionalMode ();
    t38TCPBidirectionalMode::reference set_t38TCPBidirectionalMode (bool value);
    void swap(T38FaxTcpOptions& other);
    T38FaxTcpOptions * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// AudioTelephonyEventCapability
//

class AudioTelephonyEventCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AudioTelephonyEventCapability(const void* info) : Inherited(info) {}
  public:
    AudioTelephonyEventCapability() : Inherited(&theInfo) {}
    AudioTelephonyEventCapability(const AudioTelephonyEventCapability & other) : Inherited(other)
    {}
    AudioTelephonyEventCapability& operator = (const AudioTelephonyEventCapability& other)
    { Inherited::operator = (other); return *this; } 
    class dynamicRTPPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 96, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicRTPPayloadType
    dynamicRTPPayloadType::const_reference get_dynamicRTPPayloadType () const;
    dynamicRTPPayloadType::reference ref_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType (dynamicRTPPayloadType::value_type::int_type value);
    class audioTelephoneEvent {
      public:
        typedef ASN1::GeneralString value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioTelephoneEvent
    audioTelephoneEvent::const_reference get_audioTelephoneEvent () const;
    audioTelephoneEvent::reference ref_audioTelephoneEvent ();
    audioTelephoneEvent::reference set_audioTelephoneEvent ();
    audioTelephoneEvent::reference set_audioTelephoneEvent (const std::string& value);
    void swap(AudioTelephonyEventCapability& other);
    AudioTelephonyEventCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// AudioToneCapability
//

class AudioToneCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AudioToneCapability(const void* info) : Inherited(info) {}
  public:
    AudioToneCapability() : Inherited(&theInfo) {}
    AudioToneCapability(const AudioToneCapability & other) : Inherited(other)
    {}
    AudioToneCapability& operator = (const AudioToneCapability& other)
    { Inherited::operator = (other); return *this; } 
    class dynamicRTPPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 96, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicRTPPayloadType
    dynamicRTPPayloadType::const_reference get_dynamicRTPPayloadType () const;
    dynamicRTPPayloadType::reference ref_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType (dynamicRTPPayloadType::value_type::int_type value);
    void swap(AudioToneCapability& other);
    AudioToneCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NoPTAudioTelephonyEventCapability
//

class NoPTAudioTelephonyEventCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NoPTAudioTelephonyEventCapability(const void* info) : Inherited(info) {}
  public:
    NoPTAudioTelephonyEventCapability() : Inherited(&theInfo) {}
    NoPTAudioTelephonyEventCapability(const NoPTAudioTelephonyEventCapability & other) : Inherited(other)
    {}
    NoPTAudioTelephonyEventCapability& operator = (const NoPTAudioTelephonyEventCapability& other)
    { Inherited::operator = (other); return *this; } 
    class audioTelephoneEvent {
      public:
        typedef ASN1::GeneralString value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioTelephoneEvent
    audioTelephoneEvent::const_reference get_audioTelephoneEvent () const;
    audioTelephoneEvent::reference ref_audioTelephoneEvent ();
    audioTelephoneEvent::reference set_audioTelephoneEvent ();
    audioTelephoneEvent::reference set_audioTelephoneEvent (const std::string& value);
    void swap(NoPTAudioTelephonyEventCapability& other);
    NoPTAudioTelephonyEventCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NoPTAudioToneCapability
//

class NoPTAudioToneCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NoPTAudioToneCapability(const void* info) : Inherited(info) {}
  public:
    NoPTAudioToneCapability() : Inherited(&theInfo) {}
    NoPTAudioToneCapability(const NoPTAudioToneCapability & other) : Inherited(other)
    {}
    NoPTAudioToneCapability& operator = (const NoPTAudioToneCapability& other)
    { Inherited::operator = (other); return *this; } 
    void swap(NoPTAudioToneCapability& other);
    NoPTAudioToneCapability * clone() const;
    static const InfoType theInfo;
  private:
};

typedef ASN1::Constrained_INTEGER<ASN1::PartiallyConstrained, 1, INT_MAX>  MaxRedundancy;

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  LogicalChannelNumber;

//
// V75Parameters
//

class V75Parameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V75Parameters(const void* info) : Inherited(info) {}
  public:
    V75Parameters() : Inherited(&theInfo) {}
    V75Parameters(const V75Parameters & other) : Inherited(other)
    {}
    V75Parameters& operator = (const V75Parameters& other)
    { Inherited::operator = (other); return *this; } 
    class audioHeaderPresent {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioHeaderPresent
    audioHeaderPresent::const_reference get_audioHeaderPresent () const;
    audioHeaderPresent::reference ref_audioHeaderPresent ();
    audioHeaderPresent::reference set_audioHeaderPresent ();
    audioHeaderPresent::reference set_audioHeaderPresent (bool value);
    void swap(V75Parameters& other);
    V75Parameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// H222LogicalChannelParameters
//

class H222LogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H222LogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    H222LogicalChannelParameters() : Inherited(&theInfo) {}
    H222LogicalChannelParameters(const H222LogicalChannelParameters & other) : Inherited(other)
    {}
    H222LogicalChannelParameters& operator = (const H222LogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_pcr_pid,
      e_programDescriptors,
      e_streamDescriptors
    };

    class resourceID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resourceID
    resourceID::const_reference get_resourceID () const;
    resourceID::reference ref_resourceID ();
    resourceID::reference set_resourceID ();
    resourceID::reference set_resourceID (resourceID::value_type::int_type value);
    class subChannelID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 8191>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subChannelID
    subChannelID::const_reference get_subChannelID () const;
    subChannelID::reference ref_subChannelID ();
    subChannelID::reference set_subChannelID ();
    subChannelID::reference set_subChannelID (subChannelID::value_type::int_type value);
    class pcr_pid {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 8191>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pcr_pid
    pcr_pid::const_reference get_pcr_pid () const;
    pcr_pid::reference ref_pcr_pid ();
    pcr_pid::reference set_pcr_pid ();
    pcr_pid::reference set_pcr_pid (pcr_pid::value_type::int_type value);
    void omit_pcr_pid ();
    bool pcr_pid_isPresent () const;
    class programDescriptors {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class programDescriptors
    programDescriptors::const_reference get_programDescriptors () const;
    programDescriptors::reference ref_programDescriptors ();
    programDescriptors::reference set_programDescriptors ();
    programDescriptors::reference set_programDescriptors (const std::vector<char>& value);
    void omit_programDescriptors ();
    bool programDescriptors_isPresent () const;
    class streamDescriptors {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class streamDescriptors
    streamDescriptors::const_reference get_streamDescriptors () const;
    streamDescriptors::reference ref_streamDescriptors ();
    streamDescriptors::reference set_streamDescriptors ();
    streamDescriptors::reference set_streamDescriptors (const std::vector<char>& value);
    void omit_streamDescriptors ();
    bool streamDescriptors_isPresent () const;
    void swap(H222LogicalChannelParameters& other);
    H222LogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// CRCLength
//

class CRCLength : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CRCLength(const void* info) : Inherited(info) {}
  public:
    CRCLength() : Inherited(&theInfo) {}
    class crc8bit {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc8bit

    crc8bit::reference select_crc8bit (); 
    bool crc8bit_isSelected() const;

    class crc16bit {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc16bit

    crc16bit::reference select_crc16bit (); 
    bool crc16bit_isSelected() const;

    class crc32bit {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc32bit

    crc32bit::reference select_crc32bit (); 
    bool crc32bit_isSelected() const;

    CRCLength(crc8bit::Id id, crc8bit::const_reference value);
    CRCLength(crc16bit::Id id, crc16bit::const_reference value);
    CRCLength(crc32bit::Id id, crc32bit::const_reference value);
    void swap(CRCLength & other);
    CRCLength(const CRCLength & other)
    : Inherited(other) {} 

    CRCLength & operator = (const CRCLength & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CRCLength * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// RedundancyEncodingElement
//

class RedundancyEncodingElement : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingElement(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingElement() : Inherited(&theInfo) {}
    RedundancyEncodingElement(const RedundancyEncodingElement & other) : Inherited(other)
    {}
    RedundancyEncodingElement& operator = (const RedundancyEncodingElement& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_payloadType
    };

    class payloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class payloadType
    payloadType::const_reference get_payloadType () const;
    payloadType::reference ref_payloadType ();
    payloadType::reference set_payloadType ();
    payloadType::reference set_payloadType (payloadType::value_type::int_type value);
    void omit_payloadType ();
    bool payloadType_isPresent () const;
    void swap(RedundancyEncodingElement& other);
    RedundancyEncodingElement * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultiplePayloadStream
//

class MultiplePayloadStream : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplePayloadStream(const void* info) : Inherited(info) {}
  public:
    MultiplePayloadStream() : Inherited(&theInfo) {}
    MultiplePayloadStream(const MultiplePayloadStream & other) : Inherited(other)
    {}
    MultiplePayloadStream& operator = (const MultiplePayloadStream& other)
    { Inherited::operator = (other); return *this; } 
    void swap(MultiplePayloadStream& other);
    MultiplePayloadStream * clone() const;
    static const InfoType theInfo;
  private:
};

//
// EscrowData
//

class EscrowData : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EscrowData(const void* info) : Inherited(info) {}
  public:
    EscrowData() : Inherited(&theInfo) {}
    EscrowData(const EscrowData & other) : Inherited(other)
    {}
    EscrowData& operator = (const EscrowData& other)
    { Inherited::operator = (other); return *this; } 
    class escrowID {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class escrowID
    escrowID::const_reference get_escrowID () const;
    escrowID::reference ref_escrowID ();
    escrowID::reference set_escrowID ();
    escrowID::reference set_escrowID (escrowID::const_reference value);
    class escrowValue {
      public:
        typedef ASN1::Constrained_BIT_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 65535> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class escrowValue
    escrowValue::const_reference get_escrowValue () const;
    escrowValue::reference ref_escrowValue ();
    escrowValue::reference set_escrowValue ();
    escrowValue::reference set_escrowValue (escrowValue::const_reference value);
    void swap(EscrowData& other);
    EscrowData * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// CloseLogicalChannelAck
//

class CloseLogicalChannelAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CloseLogicalChannelAck(const void* info) : Inherited(info) {}
  public:
    CloseLogicalChannelAck() : Inherited(&theInfo) {}
    CloseLogicalChannelAck(const CloseLogicalChannelAck & other) : Inherited(other)
    {}
    CloseLogicalChannelAck& operator = (const CloseLogicalChannelAck& other)
    { Inherited::operator = (other); return *this; } 
    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    void swap(CloseLogicalChannelAck& other);
    CloseLogicalChannelAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestChannelCloseAck
//

class RequestChannelCloseAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestChannelCloseAck(const void* info) : Inherited(info) {}
  public:
    RequestChannelCloseAck() : Inherited(&theInfo) {}
    RequestChannelCloseAck(const RequestChannelCloseAck & other) : Inherited(other)
    {}
    RequestChannelCloseAck& operator = (const RequestChannelCloseAck& other)
    { Inherited::operator = (other); return *this; } 
    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    void swap(RequestChannelCloseAck& other);
    RequestChannelCloseAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestChannelCloseRelease
//

class RequestChannelCloseRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestChannelCloseRelease(const void* info) : Inherited(info) {}
  public:
    RequestChannelCloseRelease() : Inherited(&theInfo) {}
    RequestChannelCloseRelease(const RequestChannelCloseRelease & other) : Inherited(other)
    {}
    RequestChannelCloseRelease& operator = (const RequestChannelCloseRelease& other)
    { Inherited::operator = (other); return *this; } 
    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    void swap(RequestChannelCloseRelease& other);
    RequestChannelCloseRelease * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 15>  MultiplexTableEntryNumber;

//
// MultiplexEntrySendAck
//

class MultiplexEntrySendAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntrySendAck(const void* info) : Inherited(info) {}
  public:
    MultiplexEntrySendAck() : Inherited(&theInfo) {}
    MultiplexEntrySendAck(const MultiplexEntrySendAck & other) : Inherited(other)
    {}
    MultiplexEntrySendAck& operator = (const MultiplexEntrySendAck& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class multiplexTableEntryNumber {
      public:
        typedef ASN1::SET_OF<MultiplexTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexTableEntryNumber
    multiplexTableEntryNumber::const_reference get_multiplexTableEntryNumber () const;
    multiplexTableEntryNumber::reference ref_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber (multiplexTableEntryNumber::const_reference value);
    void swap(MultiplexEntrySendAck& other);
    MultiplexEntrySendAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultiplexEntrySendRelease
//

class MultiplexEntrySendRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntrySendRelease(const void* info) : Inherited(info) {}
  public:
    MultiplexEntrySendRelease() : Inherited(&theInfo) {}
    MultiplexEntrySendRelease(const MultiplexEntrySendRelease & other) : Inherited(other)
    {}
    MultiplexEntrySendRelease& operator = (const MultiplexEntrySendRelease& other)
    { Inherited::operator = (other); return *this; } 
    class multiplexTableEntryNumber {
      public:
        typedef ASN1::SET_OF<MultiplexTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexTableEntryNumber
    multiplexTableEntryNumber::const_reference get_multiplexTableEntryNumber () const;
    multiplexTableEntryNumber::reference ref_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber (multiplexTableEntryNumber::const_reference value);
    void swap(MultiplexEntrySendRelease& other);
    MultiplexEntrySendRelease * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestMultiplexEntry
//

class RequestMultiplexEntry : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMultiplexEntry(const void* info) : Inherited(info) {}
  public:
    RequestMultiplexEntry() : Inherited(&theInfo) {}
    RequestMultiplexEntry(const RequestMultiplexEntry & other) : Inherited(other)
    {}
    RequestMultiplexEntry& operator = (const RequestMultiplexEntry& other)
    { Inherited::operator = (other); return *this; } 
    class entryNumbers {
      public:
        typedef ASN1::SET_OF<MultiplexTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class entryNumbers
    entryNumbers::const_reference get_entryNumbers () const;
    entryNumbers::reference ref_entryNumbers ();
    entryNumbers::reference set_entryNumbers ();
    entryNumbers::reference set_entryNumbers (entryNumbers::const_reference value);
    void swap(RequestMultiplexEntry& other);
    RequestMultiplexEntry * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestMultiplexEntryAck
//

class RequestMultiplexEntryAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMultiplexEntryAck(const void* info) : Inherited(info) {}
  public:
    RequestMultiplexEntryAck() : Inherited(&theInfo) {}
    RequestMultiplexEntryAck(const RequestMultiplexEntryAck & other) : Inherited(other)
    {}
    RequestMultiplexEntryAck& operator = (const RequestMultiplexEntryAck& other)
    { Inherited::operator = (other); return *this; } 
    class entryNumbers {
      public:
        typedef ASN1::SET_OF<MultiplexTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class entryNumbers
    entryNumbers::const_reference get_entryNumbers () const;
    entryNumbers::reference ref_entryNumbers ();
    entryNumbers::reference set_entryNumbers ();
    entryNumbers::reference set_entryNumbers (entryNumbers::const_reference value);
    void swap(RequestMultiplexEntryAck& other);
    RequestMultiplexEntryAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestMultiplexEntryRelease
//

class RequestMultiplexEntryRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMultiplexEntryRelease(const void* info) : Inherited(info) {}
  public:
    RequestMultiplexEntryRelease() : Inherited(&theInfo) {}
    RequestMultiplexEntryRelease(const RequestMultiplexEntryRelease & other) : Inherited(other)
    {}
    RequestMultiplexEntryRelease& operator = (const RequestMultiplexEntryRelease& other)
    { Inherited::operator = (other); return *this; } 
    class entryNumbers {
      public:
        typedef ASN1::SET_OF<MultiplexTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class entryNumbers
    entryNumbers::const_reference get_entryNumbers () const;
    entryNumbers::reference ref_entryNumbers ();
    entryNumbers::reference set_entryNumbers ();
    entryNumbers::reference set_entryNumbers (entryNumbers::const_reference value);
    void swap(RequestMultiplexEntryRelease& other);
    RequestMultiplexEntryRelease * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestModeRelease
//

class RequestModeRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestModeRelease(const void* info) : Inherited(info) {}
  public:
    RequestModeRelease() : Inherited(&theInfo) {}
    RequestModeRelease(const RequestModeRelease & other) : Inherited(other)
    {}
    RequestModeRelease& operator = (const RequestModeRelease& other)
    { Inherited::operator = (other); return *this; } 
    void swap(RequestModeRelease& other);
    RequestModeRelease * clone() const;
    static const InfoType theInfo;
  private:
};

//
// MultiplexedStreamModeParameters
//

class MultiplexedStreamModeParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexedStreamModeParameters(const void* info) : Inherited(info) {}
  public:
    MultiplexedStreamModeParameters() : Inherited(&theInfo) {}
    MultiplexedStreamModeParameters(const MultiplexedStreamModeParameters & other) : Inherited(other)
    {}
    MultiplexedStreamModeParameters& operator = (const MultiplexedStreamModeParameters& other)
    { Inherited::operator = (other); return *this; } 
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    void swap(MultiplexedStreamModeParameters& other);
    MultiplexedStreamModeParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// V76ModeParameters
//

class V76ModeParameters : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76ModeParameters(const void* info) : Inherited(info) {}
  public:
    V76ModeParameters() : Inherited(&theInfo) {}
    class suspendResumewAddress {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResumewAddress

    suspendResumewAddress::reference select_suspendResumewAddress (); 
    bool suspendResumewAddress_isSelected() const;

    class suspendResumewoAddress {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResumewoAddress

    suspendResumewoAddress::reference select_suspendResumewoAddress (); 
    bool suspendResumewoAddress_isSelected() const;

    V76ModeParameters(suspendResumewAddress::Id id, suspendResumewAddress::const_reference value);
    V76ModeParameters(suspendResumewoAddress::Id id, suspendResumewoAddress::const_reference value);
    void swap(V76ModeParameters & other);
    V76ModeParameters(const V76ModeParameters & other)
    : Inherited(other) {} 

    V76ModeParameters & operator = (const V76ModeParameters & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    V76ModeParameters * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// IS11172VideoMode
//

class IS11172VideoMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172VideoMode(const void* info) : Inherited(info) {}
  public:
    IS11172VideoMode() : Inherited(&theInfo) {}
    IS11172VideoMode(const IS11172VideoMode & other) : Inherited(other)
    {}
    IS11172VideoMode& operator = (const IS11172VideoMode& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_videoBitRate,
      e_vbvBufferSize,
      e_samplesPerLine,
      e_linesPerFrame,
      e_pictureRate,
      e_luminanceSampleRate
    };

    class constrainedBitstream {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class constrainedBitstream
    constrainedBitstream::const_reference get_constrainedBitstream () const;
    constrainedBitstream::reference ref_constrainedBitstream ();
    constrainedBitstream::reference set_constrainedBitstream ();
    constrainedBitstream::reference set_constrainedBitstream (bool value);
    class videoBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1073741823>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBitRate
    videoBitRate::const_reference get_videoBitRate () const;
    videoBitRate::reference ref_videoBitRate ();
    videoBitRate::reference set_videoBitRate ();
    videoBitRate::reference set_videoBitRate (videoBitRate::value_type::int_type value);
    void omit_videoBitRate ();
    bool videoBitRate_isPresent () const;
    class vbvBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vbvBufferSize
    vbvBufferSize::const_reference get_vbvBufferSize () const;
    vbvBufferSize::reference ref_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize (vbvBufferSize::value_type::int_type value);
    void omit_vbvBufferSize ();
    bool vbvBufferSize_isPresent () const;
    class samplesPerLine {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samplesPerLine
    samplesPerLine::const_reference get_samplesPerLine () const;
    samplesPerLine::reference ref_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine (samplesPerLine::value_type::int_type value);
    void omit_samplesPerLine ();
    bool samplesPerLine_isPresent () const;
    class linesPerFrame {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class linesPerFrame
    linesPerFrame::const_reference get_linesPerFrame () const;
    linesPerFrame::reference ref_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame (linesPerFrame::value_type::int_type value);
    void omit_linesPerFrame ();
    bool linesPerFrame_isPresent () const;
    class pictureRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pictureRate
    pictureRate::const_reference get_pictureRate () const;
    pictureRate::reference ref_pictureRate ();
    pictureRate::reference set_pictureRate ();
    pictureRate::reference set_pictureRate (pictureRate::value_type::int_type value);
    void omit_pictureRate ();
    bool pictureRate_isPresent () const;
    class luminanceSampleRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class luminanceSampleRate
    luminanceSampleRate::const_reference get_luminanceSampleRate () const;
    luminanceSampleRate::reference ref_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate (luminanceSampleRate::value_type::int_type value);
    void omit_luminanceSampleRate ();
    bool luminanceSampleRate_isPresent () const;
    void swap(IS11172VideoMode& other);
    IS11172VideoMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* fieldNames[7];
};

//
// VBDMode
//

class AudioMode;

class VBDMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VBDMode(const void* info) : Inherited(info) {}
  public:
    VBDMode() : Inherited(&theInfo) {}
    VBDMode(const VBDMode & other) : Inherited(other)
    {}
    VBDMode& operator = (const VBDMode& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(VBDMode& other);
    VBDMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RoundTripDelayRequest
//

class RoundTripDelayRequest : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RoundTripDelayRequest(const void* info) : Inherited(info) {}
  public:
    RoundTripDelayRequest() : Inherited(&theInfo) {}
    RoundTripDelayRequest(const RoundTripDelayRequest & other) : Inherited(other)
    {}
    RoundTripDelayRequest& operator = (const RoundTripDelayRequest& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    void swap(RoundTripDelayRequest& other);
    RoundTripDelayRequest * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RoundTripDelayResponse
//

class RoundTripDelayResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RoundTripDelayResponse(const void* info) : Inherited(info) {}
  public:
    RoundTripDelayResponse() : Inherited(&theInfo) {}
    RoundTripDelayResponse(const RoundTripDelayResponse & other) : Inherited(other)
    {}
    RoundTripDelayResponse& operator = (const RoundTripDelayResponse& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    void swap(RoundTripDelayResponse& other);
    RoundTripDelayResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MaintenanceLoopOffCommand
//

class MaintenanceLoopOffCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopOffCommand(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopOffCommand() : Inherited(&theInfo) {}
    MaintenanceLoopOffCommand(const MaintenanceLoopOffCommand & other) : Inherited(other)
    {}
    MaintenanceLoopOffCommand& operator = (const MaintenanceLoopOffCommand& other)
    { Inherited::operator = (other); return *this; } 
    void swap(MaintenanceLoopOffCommand& other);
    MaintenanceLoopOffCommand * clone() const;
    static const InfoType theInfo;
  private:
};

//
// CommunicationModeRequest
//

class CommunicationModeRequest : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CommunicationModeRequest(const void* info) : Inherited(info) {}
  public:
    CommunicationModeRequest() : Inherited(&theInfo) {}
    CommunicationModeRequest(const CommunicationModeRequest & other) : Inherited(other)
    {}
    CommunicationModeRequest& operator = (const CommunicationModeRequest& other)
    { Inherited::operator = (other); return *this; } 
    void swap(CommunicationModeRequest& other);
    CommunicationModeRequest * clone() const;
    static const InfoType theInfo;
  private:
};

//
// Criteria
//

class Criteria : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    Criteria(const void* info) : Inherited(info) {}
  public:
    Criteria() : Inherited(&theInfo) {}
    Criteria(const Criteria & other) : Inherited(other)
    {}
    Criteria& operator = (const Criteria& other)
    { Inherited::operator = (other); return *this; } 
    class field {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class field
    field::const_reference get_field () const;
    field::reference ref_field ();
    field::reference set_field ();
    field::reference set_field (field::const_reference value);
    class value {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 65535> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class value
    value::const_reference get_value () const;
    value::reference ref_value ();
    value::reference set_value ();
    value::reference set_value (const std::vector<char>& value);
    void swap(Criteria& other);
    Criteria * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 192>  McuNumber;

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 192>  TerminalNumber;

typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 128> >  TerminalID;

typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 32> >  ConferenceID;

typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 32> >  Password;

//
// RemoteMCRequest
//

class RemoteMCRequest : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RemoteMCRequest(const void* info) : Inherited(info) {}
  public:
    RemoteMCRequest() : Inherited(&theInfo) {}
    class masterActivate {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterActivate

    masterActivate::reference select_masterActivate (); 
    bool masterActivate_isSelected() const;

    class slaveActivate {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slaveActivate

    slaveActivate::reference select_slaveActivate (); 
    bool slaveActivate_isSelected() const;

    class deActivate {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deActivate

    deActivate::reference select_deActivate (); 
    bool deActivate_isSelected() const;

    RemoteMCRequest(masterActivate::Id id, masterActivate::const_reference value);
    RemoteMCRequest(slaveActivate::Id id, slaveActivate::const_reference value);
    RemoteMCRequest(deActivate::Id id, deActivate::const_reference value);
    void swap(RemoteMCRequest & other);
    RemoteMCRequest(const RemoteMCRequest & other)
    : Inherited(other) {} 

    RemoteMCRequest & operator = (const RemoteMCRequest & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RemoteMCRequest * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// ConnectionIdentifier
//

class ConnectionIdentifier : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConnectionIdentifier(const void* info) : Inherited(info) {}
  public:
    ConnectionIdentifier() : Inherited(&theInfo) {}
    ConnectionIdentifier(const ConnectionIdentifier & other) : Inherited(other)
    {}
    ConnectionIdentifier& operator = (const ConnectionIdentifier& other)
    { Inherited::operator = (other); return *this; } 
    class channelTag {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class channelTag
    channelTag::const_reference get_channelTag () const;
    channelTag::reference ref_channelTag ();
    channelTag::reference set_channelTag ();
    channelTag::reference set_channelTag (channelTag::value_type::int_type value);
    class sequenceNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    void swap(ConnectionIdentifier& other);
    ConnectionIdentifier * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  MaximumBitRate;

//
// LogicalChannelRateRequest
//

class LogicalChannelRateRequest : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    LogicalChannelRateRequest(const void* info) : Inherited(info) {}
  public:
    LogicalChannelRateRequest() : Inherited(&theInfo) {}
    LogicalChannelRateRequest(const LogicalChannelRateRequest & other) : Inherited(other)
    {}
    LogicalChannelRateRequest& operator = (const LogicalChannelRateRequest& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    class maximumBitRate {
      public:
        typedef MaximumBitRate value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumBitRate
    maximumBitRate::const_reference get_maximumBitRate () const;
    maximumBitRate::reference ref_maximumBitRate ();
    maximumBitRate::reference set_maximumBitRate ();
    maximumBitRate::reference set_maximumBitRate (maximumBitRate::value_type::int_type value);
    void swap(LogicalChannelRateRequest& other);
    LogicalChannelRateRequest * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// LogicalChannelRateAcknowledge
//

class LogicalChannelRateAcknowledge : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    LogicalChannelRateAcknowledge(const void* info) : Inherited(info) {}
  public:
    LogicalChannelRateAcknowledge() : Inherited(&theInfo) {}
    LogicalChannelRateAcknowledge(const LogicalChannelRateAcknowledge & other) : Inherited(other)
    {}
    LogicalChannelRateAcknowledge& operator = (const LogicalChannelRateAcknowledge& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    class maximumBitRate {
      public:
        typedef MaximumBitRate value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumBitRate
    maximumBitRate::const_reference get_maximumBitRate () const;
    maximumBitRate::reference ref_maximumBitRate ();
    maximumBitRate::reference set_maximumBitRate ();
    maximumBitRate::reference set_maximumBitRate (maximumBitRate::value_type::int_type value);
    void swap(LogicalChannelRateAcknowledge& other);
    LogicalChannelRateAcknowledge * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// LogicalChannelRateRejectReason
//

class LogicalChannelRateRejectReason : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    LogicalChannelRateRejectReason(const void* info) : Inherited(info) {}
  public:
    LogicalChannelRateRejectReason() : Inherited(&theInfo) {}
    class undefinedReason {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class undefinedReason

    undefinedReason::reference select_undefinedReason (); 
    bool undefinedReason_isSelected() const;

    class insufficientResources {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class insufficientResources

    insufficientResources::reference select_insufficientResources (); 
    bool insufficientResources_isSelected() const;

    LogicalChannelRateRejectReason(undefinedReason::Id id, undefinedReason::const_reference value);
    LogicalChannelRateRejectReason(insufficientResources::Id id, insufficientResources::const_reference value);
    void swap(LogicalChannelRateRejectReason & other);
    LogicalChannelRateRejectReason(const LogicalChannelRateRejectReason & other)
    : Inherited(other) {} 

    LogicalChannelRateRejectReason & operator = (const LogicalChannelRateRejectReason & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    LogicalChannelRateRejectReason * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// LogicalChannelRateRelease
//

class LogicalChannelRateRelease : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    LogicalChannelRateRelease(const void* info) : Inherited(info) {}
  public:
    LogicalChannelRateRelease() : Inherited(&theInfo) {}
    LogicalChannelRateRelease(const LogicalChannelRateRelease & other) : Inherited(other)
    {}
    LogicalChannelRateRelease& operator = (const LogicalChannelRateRelease& other)
    { Inherited::operator = (other); return *this; } 
    void swap(LogicalChannelRateRelease& other);
    LogicalChannelRateRelease * clone() const;
    static const InfoType theInfo;
  private:
};

//
// SubstituteConferenceIDCommand
//

class SubstituteConferenceIDCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    SubstituteConferenceIDCommand(const void* info) : Inherited(info) {}
  public:
    SubstituteConferenceIDCommand() : Inherited(&theInfo) {}
    SubstituteConferenceIDCommand(const SubstituteConferenceIDCommand & other) : Inherited(other)
    {}
    SubstituteConferenceIDCommand& operator = (const SubstituteConferenceIDCommand& other)
    { Inherited::operator = (other); return *this; } 
    class conferenceIdentifier {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceIdentifier
    conferenceIdentifier::const_reference get_conferenceIdentifier () const;
    conferenceIdentifier::reference ref_conferenceIdentifier ();
    conferenceIdentifier::reference set_conferenceIdentifier ();
    conferenceIdentifier::reference set_conferenceIdentifier (const std::vector<char>& value);
    void swap(SubstituteConferenceIDCommand& other);
    SubstituteConferenceIDCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// EncryptionUpdateDirection
//

class EncryptionUpdateDirection : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionUpdateDirection(const void* info) : Inherited(info) {}
  public:
    EncryptionUpdateDirection() : Inherited(&theInfo) {}
    class masterToSlave {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterToSlave

    masterToSlave::reference select_masterToSlave (); 
    bool masterToSlave_isSelected() const;

    class slaveToMaster {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slaveToMaster

    slaveToMaster::reference select_slaveToMaster (); 
    bool slaveToMaster_isSelected() const;

    EncryptionUpdateDirection(masterToSlave::Id id, masterToSlave::const_reference value);
    EncryptionUpdateDirection(slaveToMaster::Id id, slaveToMaster::const_reference value);
    void swap(EncryptionUpdateDirection & other);
    EncryptionUpdateDirection(const EncryptionUpdateDirection & other)
    : Inherited(other) {} 

    EncryptionUpdateDirection & operator = (const EncryptionUpdateDirection & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    EncryptionUpdateDirection * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// KeyProtectionMethod
//

class KeyProtectionMethod : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    KeyProtectionMethod(const void* info) : Inherited(info) {}
  public:
    KeyProtectionMethod() : Inherited(&theInfo) {}
    KeyProtectionMethod(const KeyProtectionMethod & other) : Inherited(other)
    {}
    KeyProtectionMethod& operator = (const KeyProtectionMethod& other)
    { Inherited::operator = (other); return *this; } 
    class secureChannel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class secureChannel
    secureChannel::const_reference get_secureChannel () const;
    secureChannel::reference ref_secureChannel ();
    secureChannel::reference set_secureChannel ();
    secureChannel::reference set_secureChannel (bool value);
    class sharedSecret {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sharedSecret
    sharedSecret::const_reference get_sharedSecret () const;
    sharedSecret::reference ref_sharedSecret ();
    sharedSecret::reference set_sharedSecret ();
    sharedSecret::reference set_sharedSecret (bool value);
    class certProtectedKey {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class certProtectedKey
    certProtectedKey::const_reference get_certProtectedKey () const;
    certProtectedKey::reference ref_certProtectedKey ();
    certProtectedKey::reference set_certProtectedKey ();
    certProtectedKey::reference set_certProtectedKey (bool value);
    void swap(KeyProtectionMethod& other);
    KeyProtectionMethod * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// EncryptionUpdateRequest
//

class EncryptionUpdateRequest : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionUpdateRequest(const void* info) : Inherited(info) {}
  public:
    EncryptionUpdateRequest() : Inherited(&theInfo) {}
    EncryptionUpdateRequest(const EncryptionUpdateRequest & other) : Inherited(other)
    {}
    EncryptionUpdateRequest& operator = (const EncryptionUpdateRequest& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_keyProtectionMethod,
      e_synchFlag
    };

    class keyProtectionMethod {
      public:
        typedef KeyProtectionMethod value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class keyProtectionMethod
    keyProtectionMethod::const_reference get_keyProtectionMethod () const;
    keyProtectionMethod::reference ref_keyProtectionMethod ();
    keyProtectionMethod::reference set_keyProtectionMethod ();
    keyProtectionMethod::reference set_keyProtectionMethod (keyProtectionMethod::const_reference value);
    void omit_keyProtectionMethod ();
    bool keyProtectionMethod_isPresent () const;
    class synchFlag {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class synchFlag
    synchFlag::const_reference get_synchFlag () const;
    synchFlag::reference ref_synchFlag ();
    synchFlag::reference set_synchFlag ();
    synchFlag::reference set_synchFlag (synchFlag::value_type::int_type value);
    void omit_synchFlag ();
    bool synchFlag_isPresent () const;
    void swap(EncryptionUpdateRequest& other);
    EncryptionUpdateRequest * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// PictureReference
//

class PictureReference : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    PictureReference(const void* info) : Inherited(info) {}
  public:
    PictureReference() : Inherited(&theInfo) {}
    class pictureNumber {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1023>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pictureNumber

    pictureNumber::const_reference get_pictureNumber () const;
    pictureNumber::reference ref_pictureNumber (); 
    pictureNumber::reference select_pictureNumber (); 
    pictureNumber::reference select_pictureNumber (pictureNumber::value_type::int_type value); 
    bool pictureNumber_isSelected() const;

    class longTermPictureIndex {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class longTermPictureIndex

    longTermPictureIndex::const_reference get_longTermPictureIndex () const;
    longTermPictureIndex::reference ref_longTermPictureIndex (); 
    longTermPictureIndex::reference select_longTermPictureIndex (); 
    longTermPictureIndex::reference select_longTermPictureIndex (longTermPictureIndex::value_type::int_type value); 
    bool longTermPictureIndex_isSelected() const;

    PictureReference(pictureNumber::Id id, pictureNumber::value_type::int_type value);
    PictureReference(longTermPictureIndex::Id id, longTermPictureIndex::value_type::int_type value);
    void swap(PictureReference & other);
    PictureReference(const PictureReference & other)
    : Inherited(other) {} 

    PictureReference & operator = (const PictureReference & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    PictureReference * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// TerminalYouAreSeeingInSubPictureNumber
//

class TerminalYouAreSeeingInSubPictureNumber : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalYouAreSeeingInSubPictureNumber(const void* info) : Inherited(info) {}
  public:
    TerminalYouAreSeeingInSubPictureNumber() : Inherited(&theInfo) {}
    TerminalYouAreSeeingInSubPictureNumber(const TerminalYouAreSeeingInSubPictureNumber & other) : Inherited(other)
    {}
    TerminalYouAreSeeingInSubPictureNumber& operator = (const TerminalYouAreSeeingInSubPictureNumber& other)
    { Inherited::operator = (other); return *this; } 
    class terminalNumber {
      public:
        typedef TerminalNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalNumber
    terminalNumber::const_reference get_terminalNumber () const;
    terminalNumber::reference ref_terminalNumber ();
    terminalNumber::reference set_terminalNumber ();
    terminalNumber::reference set_terminalNumber (terminalNumber::value_type::int_type value);
    class subPictureNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subPictureNumber
    subPictureNumber::const_reference get_subPictureNumber () const;
    subPictureNumber::reference ref_subPictureNumber ();
    subPictureNumber::reference set_subPictureNumber ();
    subPictureNumber::reference set_subPictureNumber (subPictureNumber::value_type::int_type value);
    void swap(TerminalYouAreSeeingInSubPictureNumber& other);
    TerminalYouAreSeeingInSubPictureNumber * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// VideoIndicateCompose
//

class VideoIndicateCompose : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VideoIndicateCompose(const void* info) : Inherited(info) {}
  public:
    VideoIndicateCompose() : Inherited(&theInfo) {}
    VideoIndicateCompose(const VideoIndicateCompose & other) : Inherited(other)
    {}
    VideoIndicateCompose& operator = (const VideoIndicateCompose& other)
    { Inherited::operator = (other); return *this; } 
    class compositionNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class compositionNumber
    compositionNumber::const_reference get_compositionNumber () const;
    compositionNumber::reference ref_compositionNumber ();
    compositionNumber::reference set_compositionNumber ();
    compositionNumber::reference set_compositionNumber (compositionNumber::value_type::int_type value);
    void swap(VideoIndicateCompose& other);
    VideoIndicateCompose * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// H223SkewIndication
//

class H223SkewIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223SkewIndication(const void* info) : Inherited(info) {}
  public:
    H223SkewIndication() : Inherited(&theInfo) {}
    H223SkewIndication(const H223SkewIndication & other) : Inherited(other)
    {}
    H223SkewIndication& operator = (const H223SkewIndication& other)
    { Inherited::operator = (other); return *this; } 
    class logicalChannelNumber1 {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber1
    logicalChannelNumber1::const_reference get_logicalChannelNumber1 () const;
    logicalChannelNumber1::reference ref_logicalChannelNumber1 ();
    logicalChannelNumber1::reference set_logicalChannelNumber1 ();
    logicalChannelNumber1::reference set_logicalChannelNumber1 (logicalChannelNumber1::value_type::int_type value);
    class logicalChannelNumber2 {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber2
    logicalChannelNumber2::const_reference get_logicalChannelNumber2 () const;
    logicalChannelNumber2::reference ref_logicalChannelNumber2 ();
    logicalChannelNumber2::reference set_logicalChannelNumber2 ();
    logicalChannelNumber2::reference set_logicalChannelNumber2 (logicalChannelNumber2::value_type::int_type value);
    class skew {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4095>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class skew
    skew::const_reference get_skew () const;
    skew::reference ref_skew ();
    skew::reference set_skew ();
    skew::reference set_skew (skew::value_type::int_type value);
    void swap(H223SkewIndication& other);
    H223SkewIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H2250MaximumSkewIndication
//

class H2250MaximumSkewIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250MaximumSkewIndication(const void* info) : Inherited(info) {}
  public:
    H2250MaximumSkewIndication() : Inherited(&theInfo) {}
    H2250MaximumSkewIndication(const H2250MaximumSkewIndication & other) : Inherited(other)
    {}
    H2250MaximumSkewIndication& operator = (const H2250MaximumSkewIndication& other)
    { Inherited::operator = (other); return *this; } 
    class logicalChannelNumber1 {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber1
    logicalChannelNumber1::const_reference get_logicalChannelNumber1 () const;
    logicalChannelNumber1::reference ref_logicalChannelNumber1 ();
    logicalChannelNumber1::reference set_logicalChannelNumber1 ();
    logicalChannelNumber1::reference set_logicalChannelNumber1 (logicalChannelNumber1::value_type::int_type value);
    class logicalChannelNumber2 {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber2
    logicalChannelNumber2::const_reference get_logicalChannelNumber2 () const;
    logicalChannelNumber2::reference ref_logicalChannelNumber2 ();
    logicalChannelNumber2::reference set_logicalChannelNumber2 ();
    logicalChannelNumber2::reference set_logicalChannelNumber2 (logicalChannelNumber2::value_type::int_type value);
    class maximumSkew {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4095>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumSkew
    maximumSkew::const_reference get_maximumSkew () const;
    maximumSkew::reference ref_maximumSkew ();
    maximumSkew::reference set_maximumSkew ();
    maximumSkew::reference set_maximumSkew (maximumSkew::value_type::int_type value);
    void swap(H2250MaximumSkewIndication& other);
    H2250MaximumSkewIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 8, 8> >  IV8;

typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  IV16;

//
// Params
//

class Params : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    Params(const void* info) : Inherited(info) {}
  public:
    Params() : Inherited(&theInfo) {}
    Params(const Params & other) : Inherited(other)
    {}
    Params& operator = (const Params& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_iv8,
      e_iv16,
      e_iv
    };

    class iv8 {
      public:
        typedef IV8 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iv8
    iv8::const_reference get_iv8 () const;
    iv8::reference ref_iv8 ();
    iv8::reference set_iv8 ();
    iv8::reference set_iv8 (const std::vector<char>& value);
    void omit_iv8 ();
    bool iv8_isPresent () const;
    class iv16 {
      public:
        typedef IV16 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iv16
    iv16::const_reference get_iv16 () const;
    iv16::reference ref_iv16 ();
    iv16::reference set_iv16 ();
    iv16::reference set_iv16 (const std::vector<char>& value);
    void omit_iv16 ();
    bool iv16_isPresent () const;
    class iv {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iv
    iv::const_reference get_iv () const;
    iv::reference ref_iv ();
    iv::reference set_iv ();
    iv::reference set_iv (const std::vector<char>& value);
    void omit_iv ();
    bool iv_isPresent () const;
    void swap(Params& other);
    Params * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MobileMultilinkReconfigurationIndication
//

class MobileMultilinkReconfigurationIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MobileMultilinkReconfigurationIndication(const void* info) : Inherited(info) {}
  public:
    MobileMultilinkReconfigurationIndication() : Inherited(&theInfo) {}
    MobileMultilinkReconfigurationIndication(const MobileMultilinkReconfigurationIndication & other) : Inherited(other)
    {}
    MobileMultilinkReconfigurationIndication& operator = (const MobileMultilinkReconfigurationIndication& other)
    { Inherited::operator = (other); return *this; } 
    class sampleSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sampleSize
    sampleSize::const_reference get_sampleSize () const;
    sampleSize::reference ref_sampleSize ();
    sampleSize::reference set_sampleSize ();
    sampleSize::reference set_sampleSize (sampleSize::value_type::int_type value);
    class samplesPerFrame {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samplesPerFrame
    samplesPerFrame::const_reference get_samplesPerFrame () const;
    samplesPerFrame::reference ref_samplesPerFrame ();
    samplesPerFrame::reference set_samplesPerFrame ();
    samplesPerFrame::reference set_samplesPerFrame (samplesPerFrame::value_type::int_type value);
    void swap(MobileMultilinkReconfigurationIndication& other);
    MobileMultilinkReconfigurationIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// NonStandardIdentifier_h221NonStandard
//

class NonStandardIdentifier_h221NonStandard : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NonStandardIdentifier_h221NonStandard(const void* info) : Inherited(info) {}
  public:
    NonStandardIdentifier_h221NonStandard() : Inherited(&theInfo) {}
    NonStandardIdentifier_h221NonStandard(const NonStandardIdentifier_h221NonStandard & other) : Inherited(other)
    {}
    NonStandardIdentifier_h221NonStandard& operator = (const NonStandardIdentifier_h221NonStandard& other)
    { Inherited::operator = (other); return *this; } 
    class t35CountryCode {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t35CountryCode
    t35CountryCode::const_reference get_t35CountryCode () const;
    t35CountryCode::reference ref_t35CountryCode ();
    t35CountryCode::reference set_t35CountryCode ();
    t35CountryCode::reference set_t35CountryCode (t35CountryCode::value_type::int_type value);
    class t35Extension {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t35Extension
    t35Extension::const_reference get_t35Extension () const;
    t35Extension::reference ref_t35Extension ();
    t35Extension::reference set_t35Extension ();
    t35Extension::reference set_t35Extension (t35Extension::value_type::int_type value);
    class manufacturerCode {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class manufacturerCode
    manufacturerCode::const_reference get_manufacturerCode () const;
    manufacturerCode::reference ref_manufacturerCode ();
    manufacturerCode::reference set_manufacturerCode ();
    manufacturerCode::reference set_manufacturerCode (manufacturerCode::value_type::int_type value);
    void swap(NonStandardIdentifier_h221NonStandard& other);
    NonStandardIdentifier_h221NonStandard * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MasterSlaveDeterminationAck_decision
//

class MasterSlaveDeterminationAck_decision : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MasterSlaveDeterminationAck_decision(const void* info) : Inherited(info) {}
  public:
    MasterSlaveDeterminationAck_decision() : Inherited(&theInfo) {}
    class master {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class master

    master::reference select_master (); 
    bool master_isSelected() const;

    class slave {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slave

    slave::reference select_slave (); 
    bool slave_isSelected() const;

    MasterSlaveDeterminationAck_decision(master::Id id, master::const_reference value);
    MasterSlaveDeterminationAck_decision(slave::Id id, slave::const_reference value);
    void swap(MasterSlaveDeterminationAck_decision & other);
    MasterSlaveDeterminationAck_decision(const MasterSlaveDeterminationAck_decision & other)
    : Inherited(other) {} 

    MasterSlaveDeterminationAck_decision & operator = (const MasterSlaveDeterminationAck_decision & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MasterSlaveDeterminationAck_decision * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MasterSlaveDeterminationReject_cause
//

class MasterSlaveDeterminationReject_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MasterSlaveDeterminationReject_cause(const void* info) : Inherited(info) {}
  public:
    MasterSlaveDeterminationReject_cause() : Inherited(&theInfo) {}
    class identicalNumbers {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class identicalNumbers

    identicalNumbers::reference select_identicalNumbers (); 
    bool identicalNumbers_isSelected() const;

    MasterSlaveDeterminationReject_cause(identicalNumbers::Id id, identicalNumbers::const_reference value);
    void swap(MasterSlaveDeterminationReject_cause & other);
    MasterSlaveDeterminationReject_cause(const MasterSlaveDeterminationReject_cause & other)
    : Inherited(other) {} 

    MasterSlaveDeterminationReject_cause & operator = (const MasterSlaveDeterminationReject_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MasterSlaveDeterminationReject_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// Capability_h233EncryptionReceiveCapability
//

class Capability_h233EncryptionReceiveCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    Capability_h233EncryptionReceiveCapability(const void* info) : Inherited(info) {}
  public:
    Capability_h233EncryptionReceiveCapability() : Inherited(&theInfo) {}
    Capability_h233EncryptionReceiveCapability(const Capability_h233EncryptionReceiveCapability & other) : Inherited(other)
    {}
    Capability_h233EncryptionReceiveCapability& operator = (const Capability_h233EncryptionReceiveCapability& other)
    { Inherited::operator = (other); return *this; } 
    class h233IVResponseTime {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h233IVResponseTime
    h233IVResponseTime::const_reference get_h233IVResponseTime () const;
    h233IVResponseTime::reference ref_h233IVResponseTime ();
    h233IVResponseTime::reference set_h233IVResponseTime ();
    h233IVResponseTime::reference set_h233IVResponseTime (h233IVResponseTime::value_type::int_type value);
    void swap(Capability_h233EncryptionReceiveCapability& other);
    Capability_h233EncryptionReceiveCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// VCCapability_aal1
//

class VCCapability_aal1 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability_aal1(const void* info) : Inherited(info) {}
  public:
    VCCapability_aal1() : Inherited(&theInfo) {}
    VCCapability_aal1(const VCCapability_aal1 & other) : Inherited(other)
    {}
    VCCapability_aal1& operator = (const VCCapability_aal1& other)
    { Inherited::operator = (other); return *this; } 
    class nullClockRecovery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullClockRecovery
    nullClockRecovery::const_reference get_nullClockRecovery () const;
    nullClockRecovery::reference ref_nullClockRecovery ();
    nullClockRecovery::reference set_nullClockRecovery ();
    nullClockRecovery::reference set_nullClockRecovery (bool value);
    class srtsClockRecovery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class srtsClockRecovery
    srtsClockRecovery::const_reference get_srtsClockRecovery () const;
    srtsClockRecovery::reference ref_srtsClockRecovery ();
    srtsClockRecovery::reference set_srtsClockRecovery ();
    srtsClockRecovery::reference set_srtsClockRecovery (bool value);
    class adaptiveClockRecovery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class adaptiveClockRecovery
    adaptiveClockRecovery::const_reference get_adaptiveClockRecovery () const;
    adaptiveClockRecovery::reference ref_adaptiveClockRecovery ();
    adaptiveClockRecovery::reference set_adaptiveClockRecovery ();
    adaptiveClockRecovery::reference set_adaptiveClockRecovery (bool value);
    class nullErrorCorrection {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullErrorCorrection
    nullErrorCorrection::const_reference get_nullErrorCorrection () const;
    nullErrorCorrection::reference ref_nullErrorCorrection ();
    nullErrorCorrection::reference set_nullErrorCorrection ();
    nullErrorCorrection::reference set_nullErrorCorrection (bool value);
    class longInterleaver {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class longInterleaver
    longInterleaver::const_reference get_longInterleaver () const;
    longInterleaver::reference ref_longInterleaver ();
    longInterleaver::reference set_longInterleaver ();
    longInterleaver::reference set_longInterleaver (bool value);
    class shortInterleaver {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class shortInterleaver
    shortInterleaver::const_reference get_shortInterleaver () const;
    shortInterleaver::reference ref_shortInterleaver ();
    shortInterleaver::reference set_shortInterleaver ();
    shortInterleaver::reference set_shortInterleaver (bool value);
    class errorCorrectionOnly {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCorrectionOnly
    errorCorrectionOnly::const_reference get_errorCorrectionOnly () const;
    errorCorrectionOnly::reference ref_errorCorrectionOnly ();
    errorCorrectionOnly::reference set_errorCorrectionOnly ();
    errorCorrectionOnly::reference set_errorCorrectionOnly (bool value);
    class structuredDataTransfer {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class structuredDataTransfer
    structuredDataTransfer::const_reference get_structuredDataTransfer () const;
    structuredDataTransfer::reference ref_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer (bool value);
    class partiallyFilledCells {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class partiallyFilledCells
    partiallyFilledCells::const_reference get_partiallyFilledCells () const;
    partiallyFilledCells::reference ref_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells (bool value);
    void swap(VCCapability_aal1& other);
    VCCapability_aal1 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[9];
    static int fieldIds[9];
    static const char* fieldNames[9];
};

//
// VCCapability_aal5
//

class VCCapability_aal5 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability_aal5(const void* info) : Inherited(info) {}
  public:
    VCCapability_aal5() : Inherited(&theInfo) {}
    VCCapability_aal5(const VCCapability_aal5 & other) : Inherited(other)
    {}
    VCCapability_aal5& operator = (const VCCapability_aal5& other)
    { Inherited::operator = (other); return *this; } 
    class forwardMaximumSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardMaximumSDUSize
    forwardMaximumSDUSize::const_reference get_forwardMaximumSDUSize () const;
    forwardMaximumSDUSize::reference ref_forwardMaximumSDUSize ();
    forwardMaximumSDUSize::reference set_forwardMaximumSDUSize ();
    forwardMaximumSDUSize::reference set_forwardMaximumSDUSize (forwardMaximumSDUSize::value_type::int_type value);
    class backwardMaximumSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class backwardMaximumSDUSize
    backwardMaximumSDUSize::const_reference get_backwardMaximumSDUSize () const;
    backwardMaximumSDUSize::reference ref_backwardMaximumSDUSize ();
    backwardMaximumSDUSize::reference set_backwardMaximumSDUSize ();
    backwardMaximumSDUSize::reference set_backwardMaximumSDUSize (backwardMaximumSDUSize::value_type::int_type value);
    void swap(VCCapability_aal5& other);
    VCCapability_aal5 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223Capability_mobileOperationTransmitCapability
//

class H223Capability_mobileOperationTransmitCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223Capability_mobileOperationTransmitCapability(const void* info) : Inherited(info) {}
  public:
    H223Capability_mobileOperationTransmitCapability() : Inherited(&theInfo) {}
    H223Capability_mobileOperationTransmitCapability(const H223Capability_mobileOperationTransmitCapability & other) : Inherited(other)
    {}
    H223Capability_mobileOperationTransmitCapability& operator = (const H223Capability_mobileOperationTransmitCapability& other)
    { Inherited::operator = (other); return *this; } 
    class modeChangeCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class modeChangeCapability
    modeChangeCapability::const_reference get_modeChangeCapability () const;
    modeChangeCapability::reference ref_modeChangeCapability ();
    modeChangeCapability::reference set_modeChangeCapability ();
    modeChangeCapability::reference set_modeChangeCapability (bool value);
    class h223AnnexA {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223AnnexA
    h223AnnexA::const_reference get_h223AnnexA () const;
    h223AnnexA::reference ref_h223AnnexA ();
    h223AnnexA::reference set_h223AnnexA ();
    h223AnnexA::reference set_h223AnnexA (bool value);
    class h223AnnexADoubleFlag {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223AnnexADoubleFlag
    h223AnnexADoubleFlag::const_reference get_h223AnnexADoubleFlag () const;
    h223AnnexADoubleFlag::reference ref_h223AnnexADoubleFlag ();
    h223AnnexADoubleFlag::reference set_h223AnnexADoubleFlag ();
    h223AnnexADoubleFlag::reference set_h223AnnexADoubleFlag (bool value);
    class h223AnnexB {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223AnnexB
    h223AnnexB::const_reference get_h223AnnexB () const;
    h223AnnexB::reference ref_h223AnnexB ();
    h223AnnexB::reference set_h223AnnexB ();
    h223AnnexB::reference set_h223AnnexB (bool value);
    class h223AnnexBwithHeader {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223AnnexBwithHeader
    h223AnnexBwithHeader::const_reference get_h223AnnexBwithHeader () const;
    h223AnnexBwithHeader::reference ref_h223AnnexBwithHeader ();
    h223AnnexBwithHeader::reference set_h223AnnexBwithHeader ();
    h223AnnexBwithHeader::reference set_h223AnnexBwithHeader (bool value);
    void swap(H223Capability_mobileOperationTransmitCapability& other);
    H223Capability_mobileOperationTransmitCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// H223Capability_mobileMultilinkFrameCapability
//

class H223Capability_mobileMultilinkFrameCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223Capability_mobileMultilinkFrameCapability(const void* info) : Inherited(info) {}
  public:
    H223Capability_mobileMultilinkFrameCapability() : Inherited(&theInfo) {}
    H223Capability_mobileMultilinkFrameCapability(const H223Capability_mobileMultilinkFrameCapability & other) : Inherited(other)
    {}
    H223Capability_mobileMultilinkFrameCapability& operator = (const H223Capability_mobileMultilinkFrameCapability& other)
    { Inherited::operator = (other); return *this; } 
    class maximumSampleSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumSampleSize
    maximumSampleSize::const_reference get_maximumSampleSize () const;
    maximumSampleSize::reference ref_maximumSampleSize ();
    maximumSampleSize::reference set_maximumSampleSize ();
    maximumSampleSize::reference set_maximumSampleSize (maximumSampleSize::value_type::int_type value);
    class maximumPayloadLength {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65025>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumPayloadLength
    maximumPayloadLength::const_reference get_maximumPayloadLength () const;
    maximumPayloadLength::reference ref_maximumPayloadLength ();
    maximumPayloadLength::reference set_maximumPayloadLength ();
    maximumPayloadLength::reference set_maximumPayloadLength (maximumPayloadLength::value_type::int_type value);
    void swap(H223Capability_mobileMultilinkFrameCapability& other);
    H223Capability_mobileMultilinkFrameCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H2250Capability_mcCapability
//

class H2250Capability_mcCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250Capability_mcCapability(const void* info) : Inherited(info) {}
  public:
    H2250Capability_mcCapability() : Inherited(&theInfo) {}
    H2250Capability_mcCapability(const H2250Capability_mcCapability & other) : Inherited(other)
    {}
    H2250Capability_mcCapability& operator = (const H2250Capability_mcCapability& other)
    { Inherited::operator = (other); return *this; } 
    class centralizedConferenceMC {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class centralizedConferenceMC
    centralizedConferenceMC::const_reference get_centralizedConferenceMC () const;
    centralizedConferenceMC::reference ref_centralizedConferenceMC ();
    centralizedConferenceMC::reference set_centralizedConferenceMC ();
    centralizedConferenceMC::reference set_centralizedConferenceMC (bool value);
    class decentralizedConferenceMC {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class decentralizedConferenceMC
    decentralizedConferenceMC::const_reference get_decentralizedConferenceMC () const;
    decentralizedConferenceMC::reference ref_decentralizedConferenceMC ();
    decentralizedConferenceMC::reference set_decentralizedConferenceMC ();
    decentralizedConferenceMC::reference set_decentralizedConferenceMC (bool value);
    void swap(H2250Capability_mcCapability& other);
    H2250Capability_mcCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MediaTransportType_atm_AAL5_compressed
//

class MediaTransportType_atm_AAL5_compressed : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MediaTransportType_atm_AAL5_compressed(const void* info) : Inherited(info) {}
  public:
    MediaTransportType_atm_AAL5_compressed() : Inherited(&theInfo) {}
    MediaTransportType_atm_AAL5_compressed(const MediaTransportType_atm_AAL5_compressed & other) : Inherited(other)
    {}
    MediaTransportType_atm_AAL5_compressed& operator = (const MediaTransportType_atm_AAL5_compressed& other)
    { Inherited::operator = (other); return *this; } 
    class variable_delta {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class variable_delta
    variable_delta::const_reference get_variable_delta () const;
    variable_delta::reference ref_variable_delta ();
    variable_delta::reference set_variable_delta ();
    variable_delta::reference set_variable_delta (bool value);
    void swap(MediaTransportType_atm_AAL5_compressed& other);
    MediaTransportType_atm_AAL5_compressed * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

typedef ASN1::SEQUENCE_OF<ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15> ,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  RTPH263VideoRedundancyEncoding_containedThreads;

typedef ASN1::SEQUENCE_OF<ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255> ,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  RTPH263VideoRedundancyFrameMapping_frameSequence;

//
// RefPictureSelection_additionalPictureMemory
//

class RefPictureSelection_additionalPictureMemory : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RefPictureSelection_additionalPictureMemory(const void* info) : Inherited(info) {}
  public:
    RefPictureSelection_additionalPictureMemory() : Inherited(&theInfo) {}
    RefPictureSelection_additionalPictureMemory(const RefPictureSelection_additionalPictureMemory & other) : Inherited(other)
    {}
    RefPictureSelection_additionalPictureMemory& operator = (const RefPictureSelection_additionalPictureMemory& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_sqcifAdditionalPictureMemory,
      e_qcifAdditionalPictureMemory,
      e_cifAdditionalPictureMemory,
      e_cif4AdditionalPictureMemory,
      e_cif16AdditionalPictureMemory,
      e_bigCpfAdditionalPictureMemory
    };

    class sqcifAdditionalPictureMemory {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sqcifAdditionalPictureMemory
    sqcifAdditionalPictureMemory::const_reference get_sqcifAdditionalPictureMemory () const;
    sqcifAdditionalPictureMemory::reference ref_sqcifAdditionalPictureMemory ();
    sqcifAdditionalPictureMemory::reference set_sqcifAdditionalPictureMemory ();
    sqcifAdditionalPictureMemory::reference set_sqcifAdditionalPictureMemory (sqcifAdditionalPictureMemory::value_type::int_type value);
    void omit_sqcifAdditionalPictureMemory ();
    bool sqcifAdditionalPictureMemory_isPresent () const;
    class qcifAdditionalPictureMemory {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcifAdditionalPictureMemory
    qcifAdditionalPictureMemory::const_reference get_qcifAdditionalPictureMemory () const;
    qcifAdditionalPictureMemory::reference ref_qcifAdditionalPictureMemory ();
    qcifAdditionalPictureMemory::reference set_qcifAdditionalPictureMemory ();
    qcifAdditionalPictureMemory::reference set_qcifAdditionalPictureMemory (qcifAdditionalPictureMemory::value_type::int_type value);
    void omit_qcifAdditionalPictureMemory ();
    bool qcifAdditionalPictureMemory_isPresent () const;
    class cifAdditionalPictureMemory {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cifAdditionalPictureMemory
    cifAdditionalPictureMemory::const_reference get_cifAdditionalPictureMemory () const;
    cifAdditionalPictureMemory::reference ref_cifAdditionalPictureMemory ();
    cifAdditionalPictureMemory::reference set_cifAdditionalPictureMemory ();
    cifAdditionalPictureMemory::reference set_cifAdditionalPictureMemory (cifAdditionalPictureMemory::value_type::int_type value);
    void omit_cifAdditionalPictureMemory ();
    bool cifAdditionalPictureMemory_isPresent () const;
    class cif4AdditionalPictureMemory {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif4AdditionalPictureMemory
    cif4AdditionalPictureMemory::const_reference get_cif4AdditionalPictureMemory () const;
    cif4AdditionalPictureMemory::reference ref_cif4AdditionalPictureMemory ();
    cif4AdditionalPictureMemory::reference set_cif4AdditionalPictureMemory ();
    cif4AdditionalPictureMemory::reference set_cif4AdditionalPictureMemory (cif4AdditionalPictureMemory::value_type::int_type value);
    void omit_cif4AdditionalPictureMemory ();
    bool cif4AdditionalPictureMemory_isPresent () const;
    class cif16AdditionalPictureMemory {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif16AdditionalPictureMemory
    cif16AdditionalPictureMemory::const_reference get_cif16AdditionalPictureMemory () const;
    cif16AdditionalPictureMemory::reference ref_cif16AdditionalPictureMemory ();
    cif16AdditionalPictureMemory::reference set_cif16AdditionalPictureMemory ();
    cif16AdditionalPictureMemory::reference set_cif16AdditionalPictureMemory (cif16AdditionalPictureMemory::value_type::int_type value);
    void omit_cif16AdditionalPictureMemory ();
    bool cif16AdditionalPictureMemory_isPresent () const;
    class bigCpfAdditionalPictureMemory {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bigCpfAdditionalPictureMemory
    bigCpfAdditionalPictureMemory::const_reference get_bigCpfAdditionalPictureMemory () const;
    bigCpfAdditionalPictureMemory::reference ref_bigCpfAdditionalPictureMemory ();
    bigCpfAdditionalPictureMemory::reference set_bigCpfAdditionalPictureMemory ();
    bigCpfAdditionalPictureMemory::reference set_bigCpfAdditionalPictureMemory (bigCpfAdditionalPictureMemory::value_type::int_type value);
    void omit_bigCpfAdditionalPictureMemory ();
    bool bigCpfAdditionalPictureMemory_isPresent () const;
    void swap(RefPictureSelection_additionalPictureMemory& other);
    RefPictureSelection_additionalPictureMemory * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// RefPictureSelection_videoBackChannelSend
//

class RefPictureSelection_videoBackChannelSend : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RefPictureSelection_videoBackChannelSend(const void* info) : Inherited(info) {}
  public:
    RefPictureSelection_videoBackChannelSend() : Inherited(&theInfo) {}
    class none {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class none

    none::reference select_none (); 
    bool none_isSelected() const;

    class ackMessageOnly {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ackMessageOnly

    ackMessageOnly::reference select_ackMessageOnly (); 
    bool ackMessageOnly_isSelected() const;

    class nackMessageOnly {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nackMessageOnly

    nackMessageOnly::reference select_nackMessageOnly (); 
    bool nackMessageOnly_isSelected() const;

    class ackOrNackMessageOnly {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ackOrNackMessageOnly

    ackOrNackMessageOnly::reference select_ackOrNackMessageOnly (); 
    bool ackOrNackMessageOnly_isSelected() const;

    class ackAndNackMessage {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ackAndNackMessage

    ackAndNackMessage::reference select_ackAndNackMessage (); 
    bool ackAndNackMessage_isSelected() const;

    RefPictureSelection_videoBackChannelSend(none::Id id, none::const_reference value);
    RefPictureSelection_videoBackChannelSend(ackMessageOnly::Id id, ackMessageOnly::const_reference value);
    RefPictureSelection_videoBackChannelSend(nackMessageOnly::Id id, nackMessageOnly::const_reference value);
    RefPictureSelection_videoBackChannelSend(ackOrNackMessageOnly::Id id, ackOrNackMessageOnly::const_reference value);
    RefPictureSelection_videoBackChannelSend(ackAndNackMessage::Id id, ackAndNackMessage::const_reference value);
    void swap(RefPictureSelection_videoBackChannelSend & other);
    RefPictureSelection_videoBackChannelSend(const RefPictureSelection_videoBackChannelSend & other)
    : Inherited(other) {} 

    RefPictureSelection_videoBackChannelSend & operator = (const RefPictureSelection_videoBackChannelSend & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RefPictureSelection_videoBackChannelSend * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// AudioCapability_g7231
//

class AudioCapability_g7231 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AudioCapability_g7231(const void* info) : Inherited(info) {}
  public:
    AudioCapability_g7231() : Inherited(&theInfo) {}
    AudioCapability_g7231(const AudioCapability_g7231 & other) : Inherited(other)
    {}
    AudioCapability_g7231& operator = (const AudioCapability_g7231& other)
    { Inherited::operator = (other); return *this; } 
    class maxAl_sduAudioFrames {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxAl_sduAudioFrames
    maxAl_sduAudioFrames::const_reference get_maxAl_sduAudioFrames () const;
    maxAl_sduAudioFrames::reference ref_maxAl_sduAudioFrames ();
    maxAl_sduAudioFrames::reference set_maxAl_sduAudioFrames ();
    maxAl_sduAudioFrames::reference set_maxAl_sduAudioFrames (maxAl_sduAudioFrames::value_type::int_type value);
    class silenceSuppression {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class silenceSuppression
    silenceSuppression::const_reference get_silenceSuppression () const;
    silenceSuppression::reference ref_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression (bool value);
    void swap(AudioCapability_g7231& other);
    AudioCapability_g7231 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// G7231AnnexCCapability_g723AnnexCAudioMode
//

class G7231AnnexCCapability_g723AnnexCAudioMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    G7231AnnexCCapability_g723AnnexCAudioMode(const void* info) : Inherited(info) {}
  public:
    G7231AnnexCCapability_g723AnnexCAudioMode() : Inherited(&theInfo) {}
    G7231AnnexCCapability_g723AnnexCAudioMode(const G7231AnnexCCapability_g723AnnexCAudioMode & other) : Inherited(other)
    {}
    G7231AnnexCCapability_g723AnnexCAudioMode& operator = (const G7231AnnexCCapability_g723AnnexCAudioMode& other)
    { Inherited::operator = (other); return *this; } 
    class highRateMode0 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 27, 78>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class highRateMode0
    highRateMode0::const_reference get_highRateMode0 () const;
    highRateMode0::reference ref_highRateMode0 ();
    highRateMode0::reference set_highRateMode0 ();
    highRateMode0::reference set_highRateMode0 (highRateMode0::value_type::int_type value);
    class highRateMode1 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 27, 78>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class highRateMode1
    highRateMode1::const_reference get_highRateMode1 () const;
    highRateMode1::reference ref_highRateMode1 ();
    highRateMode1::reference set_highRateMode1 ();
    highRateMode1::reference set_highRateMode1 (highRateMode1::value_type::int_type value);
    class lowRateMode0 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 23, 66>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowRateMode0
    lowRateMode0::const_reference get_lowRateMode0 () const;
    lowRateMode0::reference ref_lowRateMode0 ();
    lowRateMode0::reference set_lowRateMode0 ();
    lowRateMode0::reference set_lowRateMode0 (lowRateMode0::value_type::int_type value);
    class lowRateMode1 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 23, 66>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowRateMode1
    lowRateMode1::const_reference get_lowRateMode1 () const;
    lowRateMode1::reference ref_lowRateMode1 ();
    lowRateMode1::reference set_lowRateMode1 ();
    lowRateMode1::reference set_lowRateMode1 (lowRateMode1::value_type::int_type value);
    class sidMode0 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 6, 17>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sidMode0
    sidMode0::const_reference get_sidMode0 () const;
    sidMode0::reference ref_sidMode0 ();
    sidMode0::reference set_sidMode0 ();
    sidMode0::reference set_sidMode0 (sidMode0::value_type::int_type value);
    class sidMode1 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 6, 17>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sidMode1
    sidMode1::const_reference get_sidMode1 () const;
    sidMode1::reference ref_sidMode1 ();
    sidMode1::reference set_sidMode1 ();
    sidMode1::reference set_sidMode1 (sidMode1::value_type::int_type value);
    void swap(G7231AnnexCCapability_g723AnnexCAudioMode& other);
    G7231AnnexCCapability_g723AnnexCAudioMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// T84Profile_t84Restricted
//

class T84Profile_t84Restricted : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T84Profile_t84Restricted(const void* info) : Inherited(info) {}
  public:
    T84Profile_t84Restricted() : Inherited(&theInfo) {}
    T84Profile_t84Restricted(const T84Profile_t84Restricted & other) : Inherited(other)
    {}
    T84Profile_t84Restricted& operator = (const T84Profile_t84Restricted& other)
    { Inherited::operator = (other); return *this; } 
    class qcif {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcif
    qcif::const_reference get_qcif () const;
    qcif::reference ref_qcif ();
    qcif::reference set_qcif ();
    qcif::reference set_qcif (bool value);
    class cif {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif
    cif::const_reference get_cif () const;
    cif::reference ref_cif ();
    cif::reference set_cif ();
    cif::reference set_cif (bool value);
    class ccir601Seq {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ccir601Seq
    ccir601Seq::const_reference get_ccir601Seq () const;
    ccir601Seq::reference ref_ccir601Seq ();
    ccir601Seq::reference set_ccir601Seq ();
    ccir601Seq::reference set_ccir601Seq (bool value);
    class ccir601Prog {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ccir601Prog
    ccir601Prog::const_reference get_ccir601Prog () const;
    ccir601Prog::reference ref_ccir601Prog ();
    ccir601Prog::reference set_ccir601Prog ();
    ccir601Prog::reference set_ccir601Prog (bool value);
    class hdtvSeq {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hdtvSeq
    hdtvSeq::const_reference get_hdtvSeq () const;
    hdtvSeq::reference ref_hdtvSeq ();
    hdtvSeq::reference set_hdtvSeq ();
    hdtvSeq::reference set_hdtvSeq (bool value);
    class hdtvProg {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hdtvProg
    hdtvProg::const_reference get_hdtvProg () const;
    hdtvProg::reference ref_hdtvProg ();
    hdtvProg::reference set_hdtvProg ();
    hdtvProg::reference set_hdtvProg (bool value);
    class g3FacsMH200x100 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g3FacsMH200x100
    g3FacsMH200x100::const_reference get_g3FacsMH200x100 () const;
    g3FacsMH200x100::reference ref_g3FacsMH200x100 ();
    g3FacsMH200x100::reference set_g3FacsMH200x100 ();
    g3FacsMH200x100::reference set_g3FacsMH200x100 (bool value);
    class g3FacsMH200x200 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g3FacsMH200x200
    g3FacsMH200x200::const_reference get_g3FacsMH200x200 () const;
    g3FacsMH200x200::reference ref_g3FacsMH200x200 ();
    g3FacsMH200x200::reference set_g3FacsMH200x200 ();
    g3FacsMH200x200::reference set_g3FacsMH200x200 (bool value);
    class g4FacsMMR200x100 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g4FacsMMR200x100
    g4FacsMMR200x100::const_reference get_g4FacsMMR200x100 () const;
    g4FacsMMR200x100::reference ref_g4FacsMMR200x100 ();
    g4FacsMMR200x100::reference set_g4FacsMMR200x100 ();
    g4FacsMMR200x100::reference set_g4FacsMMR200x100 (bool value);
    class g4FacsMMR200x200 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g4FacsMMR200x200
    g4FacsMMR200x200::const_reference get_g4FacsMMR200x200 () const;
    g4FacsMMR200x200::reference ref_g4FacsMMR200x200 ();
    g4FacsMMR200x200::reference set_g4FacsMMR200x200 ();
    g4FacsMMR200x200::reference set_g4FacsMMR200x200 (bool value);
    class jbig200x200Seq {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class jbig200x200Seq
    jbig200x200Seq::const_reference get_jbig200x200Seq () const;
    jbig200x200Seq::reference ref_jbig200x200Seq ();
    jbig200x200Seq::reference set_jbig200x200Seq ();
    jbig200x200Seq::reference set_jbig200x200Seq (bool value);
    class jbig200x200Prog {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class jbig200x200Prog
    jbig200x200Prog::const_reference get_jbig200x200Prog () const;
    jbig200x200Prog::reference ref_jbig200x200Prog ();
    jbig200x200Prog::reference set_jbig200x200Prog ();
    jbig200x200Prog::reference set_jbig200x200Prog (bool value);
    class jbig300x300Seq {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class jbig300x300Seq
    jbig300x300Seq::const_reference get_jbig300x300Seq () const;
    jbig300x300Seq::reference ref_jbig300x300Seq ();
    jbig300x300Seq::reference set_jbig300x300Seq ();
    jbig300x300Seq::reference set_jbig300x300Seq (bool value);
    class jbig300x300Prog {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class jbig300x300Prog
    jbig300x300Prog::const_reference get_jbig300x300Prog () const;
    jbig300x300Prog::reference ref_jbig300x300Prog ();
    jbig300x300Prog::reference set_jbig300x300Prog ();
    jbig300x300Prog::reference set_jbig300x300Prog (bool value);
    class digPhotoLow {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class digPhotoLow
    digPhotoLow::const_reference get_digPhotoLow () const;
    digPhotoLow::reference ref_digPhotoLow ();
    digPhotoLow::reference set_digPhotoLow ();
    digPhotoLow::reference set_digPhotoLow (bool value);
    class digPhotoMedSeq {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class digPhotoMedSeq
    digPhotoMedSeq::const_reference get_digPhotoMedSeq () const;
    digPhotoMedSeq::reference ref_digPhotoMedSeq ();
    digPhotoMedSeq::reference set_digPhotoMedSeq ();
    digPhotoMedSeq::reference set_digPhotoMedSeq (bool value);
    class digPhotoMedProg {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class digPhotoMedProg
    digPhotoMedProg::const_reference get_digPhotoMedProg () const;
    digPhotoMedProg::reference ref_digPhotoMedProg ();
    digPhotoMedProg::reference set_digPhotoMedProg ();
    digPhotoMedProg::reference set_digPhotoMedProg (bool value);
    class digPhotoHighSeq {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class digPhotoHighSeq
    digPhotoHighSeq::const_reference get_digPhotoHighSeq () const;
    digPhotoHighSeq::reference ref_digPhotoHighSeq ();
    digPhotoHighSeq::reference set_digPhotoHighSeq ();
    digPhotoHighSeq::reference set_digPhotoHighSeq (bool value);
    class digPhotoHighProg {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class digPhotoHighProg
    digPhotoHighProg::const_reference get_digPhotoHighProg () const;
    digPhotoHighProg::reference ref_digPhotoHighProg ();
    digPhotoHighProg::reference set_digPhotoHighProg ();
    digPhotoHighProg::reference set_digPhotoHighProg (bool value);
    void swap(T84Profile_t84Restricted& other);
    T84Profile_t84Restricted * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[19];
    static int fieldIds[19];
    static const char* fieldNames[19];
};

//
// T38FaxUdpOptions_t38FaxUdpEC
//

class T38FaxUdpOptions_t38FaxUdpEC : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T38FaxUdpOptions_t38FaxUdpEC(const void* info) : Inherited(info) {}
  public:
    T38FaxUdpOptions_t38FaxUdpEC() : Inherited(&theInfo) {}
    class t38UDPFEC {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38UDPFEC

    t38UDPFEC::reference select_t38UDPFEC (); 
    bool t38UDPFEC_isSelected() const;

    class t38UDPRedundancy {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38UDPRedundancy

    t38UDPRedundancy::reference select_t38UDPRedundancy (); 
    bool t38UDPRedundancy_isSelected() const;

    T38FaxUdpOptions_t38FaxUdpEC(t38UDPFEC::Id id, t38UDPFEC::const_reference value);
    T38FaxUdpOptions_t38FaxUdpEC(t38UDPRedundancy::Id id, t38UDPRedundancy::const_reference value);
    void swap(T38FaxUdpOptions_t38FaxUdpEC & other);
    T38FaxUdpOptions_t38FaxUdpEC(const T38FaxUdpOptions_t38FaxUdpEC & other)
    : Inherited(other) {} 

    T38FaxUdpOptions_t38FaxUdpEC & operator = (const T38FaxUdpOptions_t38FaxUdpEC & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    T38FaxUdpOptions_t38FaxUdpEC * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// FECCapability_rfc2733Format
//

class FECCapability_rfc2733Format : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECCapability_rfc2733Format(const void* info) : Inherited(info) {}
  public:
    FECCapability_rfc2733Format() : Inherited(&theInfo) {}
    class rfc2733rfc2198 {
      public:
        enum Id { id_ = 0 };
        typedef MaxRedundancy value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733rfc2198

    rfc2733rfc2198::const_reference get_rfc2733rfc2198 () const;
    rfc2733rfc2198::reference ref_rfc2733rfc2198 (); 
    rfc2733rfc2198::reference select_rfc2733rfc2198 (); 
    rfc2733rfc2198::reference select_rfc2733rfc2198 (rfc2733rfc2198::value_type::int_type value); 
    bool rfc2733rfc2198_isSelected() const;

    class rfc2733sameport {
      public:
        enum Id { id_ = 1 };
        typedef MaxRedundancy value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733sameport

    rfc2733sameport::const_reference get_rfc2733sameport () const;
    rfc2733sameport::reference ref_rfc2733sameport (); 
    rfc2733sameport::reference select_rfc2733sameport (); 
    rfc2733sameport::reference select_rfc2733sameport (rfc2733sameport::value_type::int_type value); 
    bool rfc2733sameport_isSelected() const;

    class rfc2733diffport {
      public:
        enum Id { id_ = 2 };
        typedef MaxRedundancy value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733diffport

    rfc2733diffport::const_reference get_rfc2733diffport () const;
    rfc2733diffport::reference ref_rfc2733diffport (); 
    rfc2733diffport::reference select_rfc2733diffport (); 
    rfc2733diffport::reference select_rfc2733diffport (rfc2733diffport::value_type::int_type value); 
    bool rfc2733diffport_isSelected() const;

    FECCapability_rfc2733Format(rfc2733rfc2198::Id id, rfc2733rfc2198::value_type::int_type value);
    FECCapability_rfc2733Format(rfc2733sameport::Id id, rfc2733sameport::value_type::int_type value);
    FECCapability_rfc2733Format(rfc2733diffport::Id id, rfc2733diffport::value_type::int_type value);
    void swap(FECCapability_rfc2733Format & other);
    FECCapability_rfc2733Format(const FECCapability_rfc2733Format & other)
    : Inherited(other) {} 

    FECCapability_rfc2733Format & operator = (const FECCapability_rfc2733Format & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FECCapability_rfc2733Format * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// NetworkAccessParameters_distribution
//

class NetworkAccessParameters_distribution : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NetworkAccessParameters_distribution(const void* info) : Inherited(info) {}
  public:
    NetworkAccessParameters_distribution() : Inherited(&theInfo) {}
    class unicast {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unicast

    unicast::reference select_unicast (); 
    bool unicast_isSelected() const;

    class multicast {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multicast

    multicast::reference select_multicast (); 
    bool multicast_isSelected() const;

    NetworkAccessParameters_distribution(unicast::Id id, unicast::const_reference value);
    NetworkAccessParameters_distribution(multicast::Id id, multicast::const_reference value);
    void swap(NetworkAccessParameters_distribution & other);
    NetworkAccessParameters_distribution(const NetworkAccessParameters_distribution & other)
    : Inherited(other) {} 

    NetworkAccessParameters_distribution & operator = (const NetworkAccessParameters_distribution & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NetworkAccessParameters_distribution * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// NetworkAccessParameters_t120SetupProcedure
//

class NetworkAccessParameters_t120SetupProcedure : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NetworkAccessParameters_t120SetupProcedure(const void* info) : Inherited(info) {}
  public:
    NetworkAccessParameters_t120SetupProcedure() : Inherited(&theInfo) {}
    class originateCall {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class originateCall

    originateCall::reference select_originateCall (); 
    bool originateCall_isSelected() const;

    class waitForCall {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class waitForCall

    waitForCall::reference select_waitForCall (); 
    bool waitForCall_isSelected() const;

    class issueQuery {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class issueQuery

    issueQuery::reference select_issueQuery (); 
    bool issueQuery_isSelected() const;

    NetworkAccessParameters_t120SetupProcedure(originateCall::Id id, originateCall::const_reference value);
    NetworkAccessParameters_t120SetupProcedure(waitForCall::Id id, waitForCall::const_reference value);
    NetworkAccessParameters_t120SetupProcedure(issueQuery::Id id, issueQuery::const_reference value);
    void swap(NetworkAccessParameters_t120SetupProcedure & other);
    NetworkAccessParameters_t120SetupProcedure(const NetworkAccessParameters_t120SetupProcedure & other)
    : Inherited(other) {} 

    NetworkAccessParameters_t120SetupProcedure & operator = (const NetworkAccessParameters_t120SetupProcedure & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NetworkAccessParameters_t120SetupProcedure * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// Q2931Address_address
//

class Q2931Address_address : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    Q2931Address_address(const void* info) : Inherited(info) {}
  public:
    Q2931Address_address() : Inherited(&theInfo) {}
    class internationalNumber {
      public:
        enum Id { id_ = 0 };
        class value_type : public ASN1::NumericString
        {
            typedef ASN1::NumericString Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class internationalNumber

    internationalNumber::const_reference get_internationalNumber () const;
    internationalNumber::reference ref_internationalNumber (); 
    internationalNumber::reference select_internationalNumber (); 
    internationalNumber::reference select_internationalNumber (const std::string& value); 
    bool internationalNumber_isSelected() const;

    class nsapAddress {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 20> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nsapAddress

    nsapAddress::const_reference get_nsapAddress () const;
    nsapAddress::reference ref_nsapAddress (); 
    nsapAddress::reference select_nsapAddress (); 
    nsapAddress::reference select_nsapAddress (const std::vector<char>& value); 
    bool nsapAddress_isSelected() const;

    Q2931Address_address(internationalNumber::Id id, const std::string& value);
    Q2931Address_address(nsapAddress::Id id, const std::vector<char>& value);
    void swap(Q2931Address_address & other);
    Q2931Address_address(const Q2931Address_address & other)
    : Inherited(other) {} 

    Q2931Address_address & operator = (const Q2931Address_address & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    Q2931Address_address * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H223AL1MParameters_transferMode
//

class H223AL1MParameters_transferMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL1MParameters_transferMode(const void* info) : Inherited(info) {}
  public:
    H223AL1MParameters_transferMode() : Inherited(&theInfo) {}
    class framed {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class framed

    framed::reference select_framed (); 
    bool framed_isSelected() const;

    class unframed {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unframed

    unframed::reference select_unframed (); 
    bool unframed_isSelected() const;

    H223AL1MParameters_transferMode(framed::Id id, framed::const_reference value);
    H223AL1MParameters_transferMode(unframed::Id id, unframed::const_reference value);
    void swap(H223AL1MParameters_transferMode & other);
    H223AL1MParameters_transferMode(const H223AL1MParameters_transferMode & other)
    : Inherited(other) {} 

    H223AL1MParameters_transferMode & operator = (const H223AL1MParameters_transferMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL1MParameters_transferMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H223AL1MParameters_headerFEC
//

class H223AL1MParameters_headerFEC : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL1MParameters_headerFEC(const void* info) : Inherited(info) {}
  public:
    H223AL1MParameters_headerFEC() : Inherited(&theInfo) {}
    class sebch16_7 {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sebch16_7

    sebch16_7::reference select_sebch16_7 (); 
    bool sebch16_7_isSelected() const;

    class golay24_12 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class golay24_12

    golay24_12::reference select_golay24_12 (); 
    bool golay24_12_isSelected() const;

    H223AL1MParameters_headerFEC(sebch16_7::Id id, sebch16_7::const_reference value);
    H223AL1MParameters_headerFEC(golay24_12::Id id, golay24_12::const_reference value);
    void swap(H223AL1MParameters_headerFEC & other);
    H223AL1MParameters_headerFEC(const H223AL1MParameters_headerFEC & other)
    : Inherited(other) {} 

    H223AL1MParameters_headerFEC & operator = (const H223AL1MParameters_headerFEC & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL1MParameters_headerFEC * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H223AL1MParameters_crcLength
//

class H223AL1MParameters_crcLength : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL1MParameters_crcLength(const void* info) : Inherited(info) {}
  public:
    H223AL1MParameters_crcLength() : Inherited(&theInfo) {}
    class crc4bit {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc4bit

    crc4bit::reference select_crc4bit (); 
    bool crc4bit_isSelected() const;

    class crc12bit {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc12bit

    crc12bit::reference select_crc12bit (); 
    bool crc12bit_isSelected() const;

    class crc20bit {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc20bit

    crc20bit::reference select_crc20bit (); 
    bool crc20bit_isSelected() const;

    class crc28bit {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc28bit

    crc28bit::reference select_crc28bit (); 
    bool crc28bit_isSelected() const;

    class crc8bit {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc8bit

    crc8bit::reference select_crc8bit (); 
    bool crc8bit_isSelected() const;

    class crc16bit {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc16bit

    crc16bit::reference select_crc16bit (); 
    bool crc16bit_isSelected() const;

    class crc32bit {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc32bit

    crc32bit::reference select_crc32bit (); 
    bool crc32bit_isSelected() const;

    class crcNotUsed {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crcNotUsed

    crcNotUsed::reference select_crcNotUsed (); 
    bool crcNotUsed_isSelected() const;

    H223AL1MParameters_crcLength(crc4bit::Id id, crc4bit::const_reference value);
    H223AL1MParameters_crcLength(crc12bit::Id id, crc12bit::const_reference value);
    H223AL1MParameters_crcLength(crc20bit::Id id, crc20bit::const_reference value);
    H223AL1MParameters_crcLength(crc28bit::Id id, crc28bit::const_reference value);
    H223AL1MParameters_crcLength(crc8bit::Id id, crc8bit::const_reference value);
    H223AL1MParameters_crcLength(crc16bit::Id id, crc16bit::const_reference value);
    H223AL1MParameters_crcLength(crc32bit::Id id, crc32bit::const_reference value);
    H223AL1MParameters_crcLength(crcNotUsed::Id id, crcNotUsed::const_reference value);
    void swap(H223AL1MParameters_crcLength & other);
    H223AL1MParameters_crcLength(const H223AL1MParameters_crcLength & other)
    : Inherited(other) {} 

    H223AL1MParameters_crcLength & operator = (const H223AL1MParameters_crcLength & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL1MParameters_crcLength * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[8];
    static const char* selectionNames[8];
};

//
// H223AL2MParameters_headerFEC
//

class H223AL2MParameters_headerFEC : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL2MParameters_headerFEC(const void* info) : Inherited(info) {}
  public:
    H223AL2MParameters_headerFEC() : Inherited(&theInfo) {}
    class sebch16_5 {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sebch16_5

    sebch16_5::reference select_sebch16_5 (); 
    bool sebch16_5_isSelected() const;

    class golay24_12 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class golay24_12

    golay24_12::reference select_golay24_12 (); 
    bool golay24_12_isSelected() const;

    H223AL2MParameters_headerFEC(sebch16_5::Id id, sebch16_5::const_reference value);
    H223AL2MParameters_headerFEC(golay24_12::Id id, golay24_12::const_reference value);
    void swap(H223AL2MParameters_headerFEC & other);
    H223AL2MParameters_headerFEC(const H223AL2MParameters_headerFEC & other)
    : Inherited(other) {} 

    H223AL2MParameters_headerFEC & operator = (const H223AL2MParameters_headerFEC & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL2MParameters_headerFEC * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H223AL3MParameters_headerFormat
//

class H223AL3MParameters_headerFormat : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL3MParameters_headerFormat(const void* info) : Inherited(info) {}
  public:
    H223AL3MParameters_headerFormat() : Inherited(&theInfo) {}
    class sebch16_7 {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sebch16_7

    sebch16_7::reference select_sebch16_7 (); 
    bool sebch16_7_isSelected() const;

    class golay24_12 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class golay24_12

    golay24_12::reference select_golay24_12 (); 
    bool golay24_12_isSelected() const;

    H223AL3MParameters_headerFormat(sebch16_7::Id id, sebch16_7::const_reference value);
    H223AL3MParameters_headerFormat(golay24_12::Id id, golay24_12::const_reference value);
    void swap(H223AL3MParameters_headerFormat & other);
    H223AL3MParameters_headerFormat(const H223AL3MParameters_headerFormat & other)
    : Inherited(other) {} 

    H223AL3MParameters_headerFormat & operator = (const H223AL3MParameters_headerFormat & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL3MParameters_headerFormat * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H223AL3MParameters_crcLength
//

class H223AL3MParameters_crcLength : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL3MParameters_crcLength(const void* info) : Inherited(info) {}
  public:
    H223AL3MParameters_crcLength() : Inherited(&theInfo) {}
    class crc4bit {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc4bit

    crc4bit::reference select_crc4bit (); 
    bool crc4bit_isSelected() const;

    class crc12bit {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc12bit

    crc12bit::reference select_crc12bit (); 
    bool crc12bit_isSelected() const;

    class crc20bit {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc20bit

    crc20bit::reference select_crc20bit (); 
    bool crc20bit_isSelected() const;

    class crc28bit {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc28bit

    crc28bit::reference select_crc28bit (); 
    bool crc28bit_isSelected() const;

    class crc8bit {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc8bit

    crc8bit::reference select_crc8bit (); 
    bool crc8bit_isSelected() const;

    class crc16bit {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc16bit

    crc16bit::reference select_crc16bit (); 
    bool crc16bit_isSelected() const;

    class crc32bit {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc32bit

    crc32bit::reference select_crc32bit (); 
    bool crc32bit_isSelected() const;

    class crcNotUsed {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crcNotUsed

    crcNotUsed::reference select_crcNotUsed (); 
    bool crcNotUsed_isSelected() const;

    H223AL3MParameters_crcLength(crc4bit::Id id, crc4bit::const_reference value);
    H223AL3MParameters_crcLength(crc12bit::Id id, crc12bit::const_reference value);
    H223AL3MParameters_crcLength(crc20bit::Id id, crc20bit::const_reference value);
    H223AL3MParameters_crcLength(crc28bit::Id id, crc28bit::const_reference value);
    H223AL3MParameters_crcLength(crc8bit::Id id, crc8bit::const_reference value);
    H223AL3MParameters_crcLength(crc16bit::Id id, crc16bit::const_reference value);
    H223AL3MParameters_crcLength(crc32bit::Id id, crc32bit::const_reference value);
    H223AL3MParameters_crcLength(crcNotUsed::Id id, crcNotUsed::const_reference value);
    void swap(H223AL3MParameters_crcLength & other);
    H223AL3MParameters_crcLength(const H223AL3MParameters_crcLength & other)
    : Inherited(other) {} 

    H223AL3MParameters_crcLength & operator = (const H223AL3MParameters_crcLength & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL3MParameters_crcLength * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[8];
    static const char* selectionNames[8];
};

//
// H223AnnexCArqParameters_numberOfRetransmissions
//

class H223AnnexCArqParameters_numberOfRetransmissions : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AnnexCArqParameters_numberOfRetransmissions(const void* info) : Inherited(info) {}
  public:
    H223AnnexCArqParameters_numberOfRetransmissions() : Inherited(&theInfo) {}
    class finite {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class finite

    finite::const_reference get_finite () const;
    finite::reference ref_finite (); 
    finite::reference select_finite (); 
    finite::reference select_finite (finite::value_type::int_type value); 
    bool finite_isSelected() const;

    class infinite {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class infinite

    infinite::reference select_infinite (); 
    bool infinite_isSelected() const;

    H223AnnexCArqParameters_numberOfRetransmissions(finite::Id id, finite::value_type::int_type value);
    H223AnnexCArqParameters_numberOfRetransmissions(infinite::Id id, infinite::const_reference value);
    void swap(H223AnnexCArqParameters_numberOfRetransmissions & other);
    H223AnnexCArqParameters_numberOfRetransmissions(const H223AnnexCArqParameters_numberOfRetransmissions & other)
    : Inherited(other) {} 

    H223AnnexCArqParameters_numberOfRetransmissions & operator = (const H223AnnexCArqParameters_numberOfRetransmissions & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AnnexCArqParameters_numberOfRetransmissions * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// V76LogicalChannelParameters_suspendResume
//

class V76LogicalChannelParameters_suspendResume : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76LogicalChannelParameters_suspendResume(const void* info) : Inherited(info) {}
  public:
    V76LogicalChannelParameters_suspendResume() : Inherited(&theInfo) {}
    class noSuspendResume {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noSuspendResume

    noSuspendResume::reference select_noSuspendResume (); 
    bool noSuspendResume_isSelected() const;

    class suspendResumewAddress {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResumewAddress

    suspendResumewAddress::reference select_suspendResumewAddress (); 
    bool suspendResumewAddress_isSelected() const;

    class suspendResumewoAddress {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResumewoAddress

    suspendResumewoAddress::reference select_suspendResumewoAddress (); 
    bool suspendResumewoAddress_isSelected() const;

    V76LogicalChannelParameters_suspendResume(noSuspendResume::Id id, noSuspendResume::const_reference value);
    V76LogicalChannelParameters_suspendResume(suspendResumewAddress::Id id, suspendResumewAddress::const_reference value);
    V76LogicalChannelParameters_suspendResume(suspendResumewoAddress::Id id, suspendResumewoAddress::const_reference value);
    void swap(V76LogicalChannelParameters_suspendResume & other);
    V76LogicalChannelParameters_suspendResume(const V76LogicalChannelParameters_suspendResume & other)
    : Inherited(other) {} 

    V76LogicalChannelParameters_suspendResume & operator = (const V76LogicalChannelParameters_suspendResume & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    V76LogicalChannelParameters_suspendResume * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// UnicastAddress_iPAddress
//

class UnicastAddress_iPAddress : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UnicastAddress_iPAddress(const void* info) : Inherited(info) {}
  public:
    UnicastAddress_iPAddress() : Inherited(&theInfo) {}
    UnicastAddress_iPAddress(const UnicastAddress_iPAddress & other) : Inherited(other)
    {}
    UnicastAddress_iPAddress& operator = (const UnicastAddress_iPAddress& other)
    { Inherited::operator = (other); return *this; } 
    class network {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class network
    network::const_reference get_network () const;
    network::reference ref_network ();
    network::reference set_network ();
    network::reference set_network (const std::vector<char>& value);
    class tsapIdentifier {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tsapIdentifier
    tsapIdentifier::const_reference get_tsapIdentifier () const;
    tsapIdentifier::reference ref_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier (tsapIdentifier::value_type::int_type value);
    void swap(UnicastAddress_iPAddress& other);
    UnicastAddress_iPAddress * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// UnicastAddress_iPXAddress
//

class UnicastAddress_iPXAddress : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UnicastAddress_iPXAddress(const void* info) : Inherited(info) {}
  public:
    UnicastAddress_iPXAddress() : Inherited(&theInfo) {}
    UnicastAddress_iPXAddress(const UnicastAddress_iPXAddress & other) : Inherited(other)
    {}
    UnicastAddress_iPXAddress& operator = (const UnicastAddress_iPXAddress& other)
    { Inherited::operator = (other); return *this; } 
    class node {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 6, 6> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class node
    node::const_reference get_node () const;
    node::reference ref_node ();
    node::reference set_node ();
    node::reference set_node (const std::vector<char>& value);
    class netnum {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class netnum
    netnum::const_reference get_netnum () const;
    netnum::reference ref_netnum ();
    netnum::reference set_netnum ();
    netnum::reference set_netnum (const std::vector<char>& value);
    class tsapIdentifier {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 2, 2> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tsapIdentifier
    tsapIdentifier::const_reference get_tsapIdentifier () const;
    tsapIdentifier::reference ref_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier (const std::vector<char>& value);
    void swap(UnicastAddress_iPXAddress& other);
    UnicastAddress_iPXAddress * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// UnicastAddress_iP6Address
//

class UnicastAddress_iP6Address : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UnicastAddress_iP6Address(const void* info) : Inherited(info) {}
  public:
    UnicastAddress_iP6Address() : Inherited(&theInfo) {}
    UnicastAddress_iP6Address(const UnicastAddress_iP6Address & other) : Inherited(other)
    {}
    UnicastAddress_iP6Address& operator = (const UnicastAddress_iP6Address& other)
    { Inherited::operator = (other); return *this; } 
    class network {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class network
    network::const_reference get_network () const;
    network::reference ref_network ();
    network::reference set_network ();
    network::reference set_network (const std::vector<char>& value);
    class tsapIdentifier {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tsapIdentifier
    tsapIdentifier::const_reference get_tsapIdentifier () const;
    tsapIdentifier::reference ref_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier (tsapIdentifier::value_type::int_type value);
    void swap(UnicastAddress_iP6Address& other);
    UnicastAddress_iP6Address * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MulticastAddress_iPAddress
//

class MulticastAddress_iPAddress : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MulticastAddress_iPAddress(const void* info) : Inherited(info) {}
  public:
    MulticastAddress_iPAddress() : Inherited(&theInfo) {}
    MulticastAddress_iPAddress(const MulticastAddress_iPAddress & other) : Inherited(other)
    {}
    MulticastAddress_iPAddress& operator = (const MulticastAddress_iPAddress& other)
    { Inherited::operator = (other); return *this; } 
    class network {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class network
    network::const_reference get_network () const;
    network::reference ref_network ();
    network::reference set_network ();
    network::reference set_network (const std::vector<char>& value);
    class tsapIdentifier {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tsapIdentifier
    tsapIdentifier::const_reference get_tsapIdentifier () const;
    tsapIdentifier::reference ref_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier (tsapIdentifier::value_type::int_type value);
    void swap(MulticastAddress_iPAddress& other);
    MulticastAddress_iPAddress * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MulticastAddress_iP6Address
//

class MulticastAddress_iP6Address : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MulticastAddress_iP6Address(const void* info) : Inherited(info) {}
  public:
    MulticastAddress_iP6Address() : Inherited(&theInfo) {}
    MulticastAddress_iP6Address(const MulticastAddress_iP6Address & other) : Inherited(other)
    {}
    MulticastAddress_iP6Address& operator = (const MulticastAddress_iP6Address& other)
    { Inherited::operator = (other); return *this; } 
    class network {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class network
    network::const_reference get_network () const;
    network::reference ref_network ();
    network::reference set_network ();
    network::reference set_network (const std::vector<char>& value);
    class tsapIdentifier {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tsapIdentifier
    tsapIdentifier::const_reference get_tsapIdentifier () const;
    tsapIdentifier::reference ref_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier (tsapIdentifier::value_type::int_type value);
    void swap(MulticastAddress_iP6Address& other);
    MulticastAddress_iP6Address * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// OpenLogicalChannelReject_cause
//

class OpenLogicalChannelReject_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelReject_cause(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelReject_cause() : Inherited(&theInfo) {}
    class unspecified {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unspecified

    unspecified::reference select_unspecified (); 
    bool unspecified_isSelected() const;

    class unsuitableReverseParameters {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unsuitableReverseParameters

    unsuitableReverseParameters::reference select_unsuitableReverseParameters (); 
    bool unsuitableReverseParameters_isSelected() const;

    class dataTypeNotSupported {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataTypeNotSupported

    dataTypeNotSupported::reference select_dataTypeNotSupported (); 
    bool dataTypeNotSupported_isSelected() const;

    class dataTypeNotAvailable {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataTypeNotAvailable

    dataTypeNotAvailable::reference select_dataTypeNotAvailable (); 
    bool dataTypeNotAvailable_isSelected() const;

    class unknownDataType {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unknownDataType

    unknownDataType::reference select_unknownDataType (); 
    bool unknownDataType_isSelected() const;

    class dataTypeALCombinationNotSupported {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataTypeALCombinationNotSupported

    dataTypeALCombinationNotSupported::reference select_dataTypeALCombinationNotSupported (); 
    bool dataTypeALCombinationNotSupported_isSelected() const;

    class multicastChannelNotAllowed {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multicastChannelNotAllowed

    multicastChannelNotAllowed::reference select_multicastChannelNotAllowed (); 
    bool multicastChannelNotAllowed_isSelected() const;

    class insufficientBandwidth {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class insufficientBandwidth

    insufficientBandwidth::reference select_insufficientBandwidth (); 
    bool insufficientBandwidth_isSelected() const;

    class separateStackEstablishmentFailed {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateStackEstablishmentFailed

    separateStackEstablishmentFailed::reference select_separateStackEstablishmentFailed (); 
    bool separateStackEstablishmentFailed_isSelected() const;

    class invalidSessionID {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class invalidSessionID

    invalidSessionID::reference select_invalidSessionID (); 
    bool invalidSessionID_isSelected() const;

    class masterSlaveConflict {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterSlaveConflict

    masterSlaveConflict::reference select_masterSlaveConflict (); 
    bool masterSlaveConflict_isSelected() const;

    class waitForCommunicationMode {
      public:
        enum Id { id_ = 11 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class waitForCommunicationMode

    waitForCommunicationMode::reference select_waitForCommunicationMode (); 
    bool waitForCommunicationMode_isSelected() const;

    class invalidDependentChannel {
      public:
        enum Id { id_ = 12 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class invalidDependentChannel

    invalidDependentChannel::reference select_invalidDependentChannel (); 
    bool invalidDependentChannel_isSelected() const;

    class replacementForRejected {
      public:
        enum Id { id_ = 13 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class replacementForRejected

    replacementForRejected::reference select_replacementForRejected (); 
    bool replacementForRejected_isSelected() const;

    class securityDenied {
      public:
        enum Id { id_ = 14 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class securityDenied

    securityDenied::reference select_securityDenied (); 
    bool securityDenied_isSelected() const;

    OpenLogicalChannelReject_cause(unspecified::Id id, unspecified::const_reference value);
    OpenLogicalChannelReject_cause(unsuitableReverseParameters::Id id, unsuitableReverseParameters::const_reference value);
    OpenLogicalChannelReject_cause(dataTypeNotSupported::Id id, dataTypeNotSupported::const_reference value);
    OpenLogicalChannelReject_cause(dataTypeNotAvailable::Id id, dataTypeNotAvailable::const_reference value);
    OpenLogicalChannelReject_cause(unknownDataType::Id id, unknownDataType::const_reference value);
    OpenLogicalChannelReject_cause(dataTypeALCombinationNotSupported::Id id, dataTypeALCombinationNotSupported::const_reference value);
    OpenLogicalChannelReject_cause(multicastChannelNotAllowed::Id id, multicastChannelNotAllowed::const_reference value);
    OpenLogicalChannelReject_cause(insufficientBandwidth::Id id, insufficientBandwidth::const_reference value);
    OpenLogicalChannelReject_cause(separateStackEstablishmentFailed::Id id, separateStackEstablishmentFailed::const_reference value);
    OpenLogicalChannelReject_cause(invalidSessionID::Id id, invalidSessionID::const_reference value);
    OpenLogicalChannelReject_cause(masterSlaveConflict::Id id, masterSlaveConflict::const_reference value);
    OpenLogicalChannelReject_cause(waitForCommunicationMode::Id id, waitForCommunicationMode::const_reference value);
    OpenLogicalChannelReject_cause(invalidDependentChannel::Id id, invalidDependentChannel::const_reference value);
    OpenLogicalChannelReject_cause(replacementForRejected::Id id, replacementForRejected::const_reference value);
    OpenLogicalChannelReject_cause(securityDenied::Id id, securityDenied::const_reference value);
    void swap(OpenLogicalChannelReject_cause & other);
    OpenLogicalChannelReject_cause(const OpenLogicalChannelReject_cause & other)
    : Inherited(other) {} 

    OpenLogicalChannelReject_cause & operator = (const OpenLogicalChannelReject_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    OpenLogicalChannelReject_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[15];
    static const char* selectionNames[15];
};

//
// CloseLogicalChannel_source
//

class CloseLogicalChannel_source : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CloseLogicalChannel_source(const void* info) : Inherited(info) {}
  public:
    CloseLogicalChannel_source() : Inherited(&theInfo) {}
    class user {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class user

    user::reference select_user (); 
    bool user_isSelected() const;

    class lcse {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lcse

    lcse::reference select_lcse (); 
    bool lcse_isSelected() const;

    CloseLogicalChannel_source(user::Id id, user::const_reference value);
    CloseLogicalChannel_source(lcse::Id id, lcse::const_reference value);
    void swap(CloseLogicalChannel_source & other);
    CloseLogicalChannel_source(const CloseLogicalChannel_source & other)
    : Inherited(other) {} 

    CloseLogicalChannel_source & operator = (const CloseLogicalChannel_source & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CloseLogicalChannel_source * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// CloseLogicalChannel_reason
//

class CloseLogicalChannel_reason : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CloseLogicalChannel_reason(const void* info) : Inherited(info) {}
  public:
    CloseLogicalChannel_reason() : Inherited(&theInfo) {}
    class unknown {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unknown

    unknown::reference select_unknown (); 
    bool unknown_isSelected() const;

    class reopen {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reopen

    reopen::reference select_reopen (); 
    bool reopen_isSelected() const;

    class reservationFailure {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reservationFailure

    reservationFailure::reference select_reservationFailure (); 
    bool reservationFailure_isSelected() const;

    CloseLogicalChannel_reason(unknown::Id id, unknown::const_reference value);
    CloseLogicalChannel_reason(reopen::Id id, reopen::const_reference value);
    CloseLogicalChannel_reason(reservationFailure::Id id, reservationFailure::const_reference value);
    void swap(CloseLogicalChannel_reason & other);
    CloseLogicalChannel_reason(const CloseLogicalChannel_reason & other)
    : Inherited(other) {} 

    CloseLogicalChannel_reason & operator = (const CloseLogicalChannel_reason & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CloseLogicalChannel_reason * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// RequestChannelClose_reason
//

class RequestChannelClose_reason : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestChannelClose_reason(const void* info) : Inherited(info) {}
  public:
    RequestChannelClose_reason() : Inherited(&theInfo) {}
    class unknown {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unknown

    unknown::reference select_unknown (); 
    bool unknown_isSelected() const;

    class normal {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class normal

    normal::reference select_normal (); 
    bool normal_isSelected() const;

    class reopen {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reopen

    reopen::reference select_reopen (); 
    bool reopen_isSelected() const;

    class reservationFailure {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reservationFailure

    reservationFailure::reference select_reservationFailure (); 
    bool reservationFailure_isSelected() const;

    RequestChannelClose_reason(unknown::Id id, unknown::const_reference value);
    RequestChannelClose_reason(normal::Id id, normal::const_reference value);
    RequestChannelClose_reason(reopen::Id id, reopen::const_reference value);
    RequestChannelClose_reason(reservationFailure::Id id, reservationFailure::const_reference value);
    void swap(RequestChannelClose_reason & other);
    RequestChannelClose_reason(const RequestChannelClose_reason & other)
    : Inherited(other) {} 

    RequestChannelClose_reason & operator = (const RequestChannelClose_reason & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RequestChannelClose_reason * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// RequestChannelCloseReject_cause
//

class RequestChannelCloseReject_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestChannelCloseReject_cause(const void* info) : Inherited(info) {}
  public:
    RequestChannelCloseReject_cause() : Inherited(&theInfo) {}
    class unspecified {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unspecified

    unspecified::reference select_unspecified (); 
    bool unspecified_isSelected() const;

    RequestChannelCloseReject_cause(unspecified::Id id, unspecified::const_reference value);
    void swap(RequestChannelCloseReject_cause & other);
    RequestChannelCloseReject_cause(const RequestChannelCloseReject_cause & other)
    : Inherited(other) {} 

    RequestChannelCloseReject_cause & operator = (const RequestChannelCloseReject_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RequestChannelCloseReject_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// MultiplexElement_repeatCount
//

class MultiplexElement_repeatCount : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexElement_repeatCount(const void* info) : Inherited(info) {}
  public:
    MultiplexElement_repeatCount() : Inherited(&theInfo) {}
    class finite {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class finite

    finite::const_reference get_finite () const;
    finite::reference ref_finite (); 
    finite::reference select_finite (); 
    finite::reference select_finite (finite::value_type::int_type value); 
    bool finite_isSelected() const;

    class untilClosingFlag {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class untilClosingFlag

    untilClosingFlag::reference select_untilClosingFlag (); 
    bool untilClosingFlag_isSelected() const;

    MultiplexElement_repeatCount(finite::Id id, finite::value_type::int_type value);
    MultiplexElement_repeatCount(untilClosingFlag::Id id, untilClosingFlag::const_reference value);
    void swap(MultiplexElement_repeatCount & other);
    MultiplexElement_repeatCount(const MultiplexElement_repeatCount & other)
    : Inherited(other) {} 

    MultiplexElement_repeatCount & operator = (const MultiplexElement_repeatCount & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultiplexElement_repeatCount * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MultiplexEntryRejectionDescriptions_cause
//

class MultiplexEntryRejectionDescriptions_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntryRejectionDescriptions_cause(const void* info) : Inherited(info) {}
  public:
    MultiplexEntryRejectionDescriptions_cause() : Inherited(&theInfo) {}
    class unspecifiedCause {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unspecifiedCause

    unspecifiedCause::reference select_unspecifiedCause (); 
    bool unspecifiedCause_isSelected() const;

    class descriptorTooComplex {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class descriptorTooComplex

    descriptorTooComplex::reference select_descriptorTooComplex (); 
    bool descriptorTooComplex_isSelected() const;

    MultiplexEntryRejectionDescriptions_cause(unspecifiedCause::Id id, unspecifiedCause::const_reference value);
    MultiplexEntryRejectionDescriptions_cause(descriptorTooComplex::Id id, descriptorTooComplex::const_reference value);
    void swap(MultiplexEntryRejectionDescriptions_cause & other);
    MultiplexEntryRejectionDescriptions_cause(const MultiplexEntryRejectionDescriptions_cause & other)
    : Inherited(other) {} 

    MultiplexEntryRejectionDescriptions_cause & operator = (const MultiplexEntryRejectionDescriptions_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultiplexEntryRejectionDescriptions_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// RequestMultiplexEntryRejectionDescriptions_cause
//

class RequestMultiplexEntryRejectionDescriptions_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMultiplexEntryRejectionDescriptions_cause(const void* info) : Inherited(info) {}
  public:
    RequestMultiplexEntryRejectionDescriptions_cause() : Inherited(&theInfo) {}
    class unspecifiedCause {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unspecifiedCause

    unspecifiedCause::reference select_unspecifiedCause (); 
    bool unspecifiedCause_isSelected() const;

    RequestMultiplexEntryRejectionDescriptions_cause(unspecifiedCause::Id id, unspecifiedCause::const_reference value);
    void swap(RequestMultiplexEntryRejectionDescriptions_cause & other);
    RequestMultiplexEntryRejectionDescriptions_cause(const RequestMultiplexEntryRejectionDescriptions_cause & other)
    : Inherited(other) {} 

    RequestMultiplexEntryRejectionDescriptions_cause & operator = (const RequestMultiplexEntryRejectionDescriptions_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RequestMultiplexEntryRejectionDescriptions_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// RequestModeAck_response
//

class RequestModeAck_response : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestModeAck_response(const void* info) : Inherited(info) {}
  public:
    RequestModeAck_response() : Inherited(&theInfo) {}
    class willTransmitMostPreferredMode {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class willTransmitMostPreferredMode

    willTransmitMostPreferredMode::reference select_willTransmitMostPreferredMode (); 
    bool willTransmitMostPreferredMode_isSelected() const;

    class willTransmitLessPreferredMode {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class willTransmitLessPreferredMode

    willTransmitLessPreferredMode::reference select_willTransmitLessPreferredMode (); 
    bool willTransmitLessPreferredMode_isSelected() const;

    RequestModeAck_response(willTransmitMostPreferredMode::Id id, willTransmitMostPreferredMode::const_reference value);
    RequestModeAck_response(willTransmitLessPreferredMode::Id id, willTransmitLessPreferredMode::const_reference value);
    void swap(RequestModeAck_response & other);
    RequestModeAck_response(const RequestModeAck_response & other)
    : Inherited(other) {} 

    RequestModeAck_response & operator = (const RequestModeAck_response & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RequestModeAck_response * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// RequestModeReject_cause
//

class RequestModeReject_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestModeReject_cause(const void* info) : Inherited(info) {}
  public:
    RequestModeReject_cause() : Inherited(&theInfo) {}
    class modeUnavailable {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class modeUnavailable

    modeUnavailable::reference select_modeUnavailable (); 
    bool modeUnavailable_isSelected() const;

    class multipointConstraint {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multipointConstraint

    multipointConstraint::reference select_multipointConstraint (); 
    bool multipointConstraint_isSelected() const;

    class requestDenied {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestDenied

    requestDenied::reference select_requestDenied (); 
    bool requestDenied_isSelected() const;

    RequestModeReject_cause(modeUnavailable::Id id, modeUnavailable::const_reference value);
    RequestModeReject_cause(multipointConstraint::Id id, multipointConstraint::const_reference value);
    RequestModeReject_cause(requestDenied::Id id, requestDenied::const_reference value);
    void swap(RequestModeReject_cause & other);
    RequestModeReject_cause(const RequestModeReject_cause & other)
    : Inherited(other) {} 

    RequestModeReject_cause & operator = (const RequestModeReject_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RequestModeReject_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// FECMode_rfc2733Format
//

class FECMode_rfc2733Format : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECMode_rfc2733Format(const void* info) : Inherited(info) {}
  public:
    FECMode_rfc2733Format() : Inherited(&theInfo) {}
    class rfc2733rfc2198 {
      public:
        enum Id { id_ = 0 };
        typedef MaxRedundancy value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733rfc2198

    rfc2733rfc2198::const_reference get_rfc2733rfc2198 () const;
    rfc2733rfc2198::reference ref_rfc2733rfc2198 (); 
    rfc2733rfc2198::reference select_rfc2733rfc2198 (); 
    rfc2733rfc2198::reference select_rfc2733rfc2198 (rfc2733rfc2198::value_type::int_type value); 
    bool rfc2733rfc2198_isSelected() const;

    class rfc2733sameport {
      public:
        enum Id { id_ = 1 };
        typedef MaxRedundancy value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733sameport

    rfc2733sameport::const_reference get_rfc2733sameport () const;
    rfc2733sameport::reference ref_rfc2733sameport (); 
    rfc2733sameport::reference select_rfc2733sameport (); 
    rfc2733sameport::reference select_rfc2733sameport (rfc2733sameport::value_type::int_type value); 
    bool rfc2733sameport_isSelected() const;

    class rfc2733diffport {
      public:
        enum Id { id_ = 2 };
        typedef MaxRedundancy value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733diffport

    rfc2733diffport::const_reference get_rfc2733diffport () const;
    rfc2733diffport::reference ref_rfc2733diffport (); 
    rfc2733diffport::reference select_rfc2733diffport (); 
    rfc2733diffport::reference select_rfc2733diffport (rfc2733diffport::value_type::int_type value); 
    bool rfc2733diffport_isSelected() const;

    FECMode_rfc2733Format(rfc2733rfc2198::Id id, rfc2733rfc2198::value_type::int_type value);
    FECMode_rfc2733Format(rfc2733sameport::Id id, rfc2733sameport::value_type::int_type value);
    FECMode_rfc2733Format(rfc2733diffport::Id id, rfc2733diffport::value_type::int_type value);
    void swap(FECMode_rfc2733Format & other);
    FECMode_rfc2733Format(const FECMode_rfc2733Format & other)
    : Inherited(other) {} 

    FECMode_rfc2733Format & operator = (const FECMode_rfc2733Format & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FECMode_rfc2733Format * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// H261VideoMode_resolution
//

class H261VideoMode_resolution : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H261VideoMode_resolution(const void* info) : Inherited(info) {}
  public:
    H261VideoMode_resolution() : Inherited(&theInfo) {}
    class qcif {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcif

    qcif::reference select_qcif (); 
    bool qcif_isSelected() const;

    class cif {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif

    cif::reference select_cif (); 
    bool cif_isSelected() const;

    H261VideoMode_resolution(qcif::Id id, qcif::const_reference value);
    H261VideoMode_resolution(cif::Id id, cif::const_reference value);
    void swap(H261VideoMode_resolution & other);
    H261VideoMode_resolution(const H261VideoMode_resolution & other)
    : Inherited(other) {} 

    H261VideoMode_resolution & operator = (const H261VideoMode_resolution & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H261VideoMode_resolution * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H262VideoMode_profileAndLevel
//

class H262VideoMode_profileAndLevel : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H262VideoMode_profileAndLevel(const void* info) : Inherited(info) {}
  public:
    H262VideoMode_profileAndLevel() : Inherited(&theInfo) {}
    class profileAndLevel_SPatML {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SPatML

    profileAndLevel_SPatML::reference select_profileAndLevel_SPatML (); 
    bool profileAndLevel_SPatML_isSelected() const;

    class profileAndLevel_MPatLL {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatLL

    profileAndLevel_MPatLL::reference select_profileAndLevel_MPatLL (); 
    bool profileAndLevel_MPatLL_isSelected() const;

    class profileAndLevel_MPatML {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatML

    profileAndLevel_MPatML::reference select_profileAndLevel_MPatML (); 
    bool profileAndLevel_MPatML_isSelected() const;

    class profileAndLevel_MPatH_14 {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatH_14

    profileAndLevel_MPatH_14::reference select_profileAndLevel_MPatH_14 (); 
    bool profileAndLevel_MPatH_14_isSelected() const;

    class profileAndLevel_MPatHL {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_MPatHL

    profileAndLevel_MPatHL::reference select_profileAndLevel_MPatHL (); 
    bool profileAndLevel_MPatHL_isSelected() const;

    class profileAndLevel_SNRatLL {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SNRatLL

    profileAndLevel_SNRatLL::reference select_profileAndLevel_SNRatLL (); 
    bool profileAndLevel_SNRatLL_isSelected() const;

    class profileAndLevel_SNRatML {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SNRatML

    profileAndLevel_SNRatML::reference select_profileAndLevel_SNRatML (); 
    bool profileAndLevel_SNRatML_isSelected() const;

    class profileAndLevel_SpatialatH_14 {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_SpatialatH_14

    profileAndLevel_SpatialatH_14::reference select_profileAndLevel_SpatialatH_14 (); 
    bool profileAndLevel_SpatialatH_14_isSelected() const;

    class profileAndLevel_HPatML {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_HPatML

    profileAndLevel_HPatML::reference select_profileAndLevel_HPatML (); 
    bool profileAndLevel_HPatML_isSelected() const;

    class profileAndLevel_HPatH_14 {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_HPatH_14

    profileAndLevel_HPatH_14::reference select_profileAndLevel_HPatH_14 (); 
    bool profileAndLevel_HPatH_14_isSelected() const;

    class profileAndLevel_HPatHL {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel_HPatHL

    profileAndLevel_HPatHL::reference select_profileAndLevel_HPatHL (); 
    bool profileAndLevel_HPatHL_isSelected() const;

    H262VideoMode_profileAndLevel(profileAndLevel_SPatML::Id id, profileAndLevel_SPatML::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_MPatLL::Id id, profileAndLevel_MPatLL::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_MPatML::Id id, profileAndLevel_MPatML::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_MPatH_14::Id id, profileAndLevel_MPatH_14::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_MPatHL::Id id, profileAndLevel_MPatHL::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_SNRatLL::Id id, profileAndLevel_SNRatLL::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_SNRatML::Id id, profileAndLevel_SNRatML::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_SpatialatH_14::Id id, profileAndLevel_SpatialatH_14::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_HPatML::Id id, profileAndLevel_HPatML::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_HPatH_14::Id id, profileAndLevel_HPatH_14::const_reference value);
    H262VideoMode_profileAndLevel(profileAndLevel_HPatHL::Id id, profileAndLevel_HPatHL::const_reference value);
    void swap(H262VideoMode_profileAndLevel & other);
    H262VideoMode_profileAndLevel(const H262VideoMode_profileAndLevel & other)
    : Inherited(other) {} 

    H262VideoMode_profileAndLevel & operator = (const H262VideoMode_profileAndLevel & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H262VideoMode_profileAndLevel * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[11];
    static const char* selectionNames[11];
};

//
// H263VideoMode_resolution
//

class H263VideoMode_resolution : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263VideoMode_resolution(const void* info) : Inherited(info) {}
  public:
    H263VideoMode_resolution() : Inherited(&theInfo) {}
    class sqcif {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sqcif

    sqcif::reference select_sqcif (); 
    bool sqcif_isSelected() const;

    class qcif {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcif

    qcif::reference select_qcif (); 
    bool qcif_isSelected() const;

    class cif {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif

    cif::reference select_cif (); 
    bool cif_isSelected() const;

    class cif4 {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif4

    cif4::reference select_cif4 (); 
    bool cif4_isSelected() const;

    class cif16 {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif16

    cif16::reference select_cif16 (); 
    bool cif16_isSelected() const;

    class custom {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class custom

    custom::reference select_custom (); 
    bool custom_isSelected() const;

    H263VideoMode_resolution(sqcif::Id id, sqcif::const_reference value);
    H263VideoMode_resolution(qcif::Id id, qcif::const_reference value);
    H263VideoMode_resolution(cif::Id id, cif::const_reference value);
    H263VideoMode_resolution(cif4::Id id, cif4::const_reference value);
    H263VideoMode_resolution(cif16::Id id, cif16::const_reference value);
    H263VideoMode_resolution(custom::Id id, custom::const_reference value);
    void swap(H263VideoMode_resolution & other);
    H263VideoMode_resolution(const H263VideoMode_resolution & other)
    : Inherited(other) {} 

    H263VideoMode_resolution & operator = (const H263VideoMode_resolution & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H263VideoMode_resolution * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[6];
    static const char* selectionNames[6];
};

//
// AudioMode_g7231
//

class AudioMode_g7231 : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AudioMode_g7231(const void* info) : Inherited(info) {}
  public:
    AudioMode_g7231() : Inherited(&theInfo) {}
    class noSilenceSuppressionLowRate {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noSilenceSuppressionLowRate

    noSilenceSuppressionLowRate::reference select_noSilenceSuppressionLowRate (); 
    bool noSilenceSuppressionLowRate_isSelected() const;

    class noSilenceSuppressionHighRate {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noSilenceSuppressionHighRate

    noSilenceSuppressionHighRate::reference select_noSilenceSuppressionHighRate (); 
    bool noSilenceSuppressionHighRate_isSelected() const;

    class silenceSuppressionLowRate {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class silenceSuppressionLowRate

    silenceSuppressionLowRate::reference select_silenceSuppressionLowRate (); 
    bool silenceSuppressionLowRate_isSelected() const;

    class silenceSuppressionHighRate {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class silenceSuppressionHighRate

    silenceSuppressionHighRate::reference select_silenceSuppressionHighRate (); 
    bool silenceSuppressionHighRate_isSelected() const;

    AudioMode_g7231(noSilenceSuppressionLowRate::Id id, noSilenceSuppressionLowRate::const_reference value);
    AudioMode_g7231(noSilenceSuppressionHighRate::Id id, noSilenceSuppressionHighRate::const_reference value);
    AudioMode_g7231(silenceSuppressionLowRate::Id id, silenceSuppressionLowRate::const_reference value);
    AudioMode_g7231(silenceSuppressionHighRate::Id id, silenceSuppressionHighRate::const_reference value);
    void swap(AudioMode_g7231 & other);
    AudioMode_g7231(const AudioMode_g7231 & other)
    : Inherited(other) {} 

    AudioMode_g7231 & operator = (const AudioMode_g7231 & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    AudioMode_g7231 * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// IS11172AudioMode_audioLayer
//

class IS11172AudioMode_audioLayer : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172AudioMode_audioLayer(const void* info) : Inherited(info) {}
  public:
    IS11172AudioMode_audioLayer() : Inherited(&theInfo) {}
    class audioLayer1 {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer1

    audioLayer1::reference select_audioLayer1 (); 
    bool audioLayer1_isSelected() const;

    class audioLayer2 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer2

    audioLayer2::reference select_audioLayer2 (); 
    bool audioLayer2_isSelected() const;

    class audioLayer3 {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer3

    audioLayer3::reference select_audioLayer3 (); 
    bool audioLayer3_isSelected() const;

    IS11172AudioMode_audioLayer(audioLayer1::Id id, audioLayer1::const_reference value);
    IS11172AudioMode_audioLayer(audioLayer2::Id id, audioLayer2::const_reference value);
    IS11172AudioMode_audioLayer(audioLayer3::Id id, audioLayer3::const_reference value);
    void swap(IS11172AudioMode_audioLayer & other);
    IS11172AudioMode_audioLayer(const IS11172AudioMode_audioLayer & other)
    : Inherited(other) {} 

    IS11172AudioMode_audioLayer & operator = (const IS11172AudioMode_audioLayer & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IS11172AudioMode_audioLayer * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// IS11172AudioMode_audioSampling
//

class IS11172AudioMode_audioSampling : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172AudioMode_audioSampling(const void* info) : Inherited(info) {}
  public:
    IS11172AudioMode_audioSampling() : Inherited(&theInfo) {}
    class audioSampling32k {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling32k

    audioSampling32k::reference select_audioSampling32k (); 
    bool audioSampling32k_isSelected() const;

    class audioSampling44k1 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling44k1

    audioSampling44k1::reference select_audioSampling44k1 (); 
    bool audioSampling44k1_isSelected() const;

    class audioSampling48k {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling48k

    audioSampling48k::reference select_audioSampling48k (); 
    bool audioSampling48k_isSelected() const;

    IS11172AudioMode_audioSampling(audioSampling32k::Id id, audioSampling32k::const_reference value);
    IS11172AudioMode_audioSampling(audioSampling44k1::Id id, audioSampling44k1::const_reference value);
    IS11172AudioMode_audioSampling(audioSampling48k::Id id, audioSampling48k::const_reference value);
    void swap(IS11172AudioMode_audioSampling & other);
    IS11172AudioMode_audioSampling(const IS11172AudioMode_audioSampling & other)
    : Inherited(other) {} 

    IS11172AudioMode_audioSampling & operator = (const IS11172AudioMode_audioSampling & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IS11172AudioMode_audioSampling * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// IS11172AudioMode_multichannelType
//

class IS11172AudioMode_multichannelType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172AudioMode_multichannelType(const void* info) : Inherited(info) {}
  public:
    IS11172AudioMode_multichannelType() : Inherited(&theInfo) {}
    class singleChannel {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class singleChannel

    singleChannel::reference select_singleChannel (); 
    bool singleChannel_isSelected() const;

    class twoChannelStereo {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoChannelStereo

    twoChannelStereo::reference select_twoChannelStereo (); 
    bool twoChannelStereo_isSelected() const;

    class twoChannelDual {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoChannelDual

    twoChannelDual::reference select_twoChannelDual (); 
    bool twoChannelDual_isSelected() const;

    IS11172AudioMode_multichannelType(singleChannel::Id id, singleChannel::const_reference value);
    IS11172AudioMode_multichannelType(twoChannelStereo::Id id, twoChannelStereo::const_reference value);
    IS11172AudioMode_multichannelType(twoChannelDual::Id id, twoChannelDual::const_reference value);
    void swap(IS11172AudioMode_multichannelType & other);
    IS11172AudioMode_multichannelType(const IS11172AudioMode_multichannelType & other)
    : Inherited(other) {} 

    IS11172AudioMode_multichannelType & operator = (const IS11172AudioMode_multichannelType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IS11172AudioMode_multichannelType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// IS13818AudioMode_audioLayer
//

class IS13818AudioMode_audioLayer : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS13818AudioMode_audioLayer(const void* info) : Inherited(info) {}
  public:
    IS13818AudioMode_audioLayer() : Inherited(&theInfo) {}
    class audioLayer1 {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer1

    audioLayer1::reference select_audioLayer1 (); 
    bool audioLayer1_isSelected() const;

    class audioLayer2 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer2

    audioLayer2::reference select_audioLayer2 (); 
    bool audioLayer2_isSelected() const;

    class audioLayer3 {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer3

    audioLayer3::reference select_audioLayer3 (); 
    bool audioLayer3_isSelected() const;

    IS13818AudioMode_audioLayer(audioLayer1::Id id, audioLayer1::const_reference value);
    IS13818AudioMode_audioLayer(audioLayer2::Id id, audioLayer2::const_reference value);
    IS13818AudioMode_audioLayer(audioLayer3::Id id, audioLayer3::const_reference value);
    void swap(IS13818AudioMode_audioLayer & other);
    IS13818AudioMode_audioLayer(const IS13818AudioMode_audioLayer & other)
    : Inherited(other) {} 

    IS13818AudioMode_audioLayer & operator = (const IS13818AudioMode_audioLayer & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IS13818AudioMode_audioLayer * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// IS13818AudioMode_audioSampling
//

class IS13818AudioMode_audioSampling : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS13818AudioMode_audioSampling(const void* info) : Inherited(info) {}
  public:
    IS13818AudioMode_audioSampling() : Inherited(&theInfo) {}
    class audioSampling16k {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling16k

    audioSampling16k::reference select_audioSampling16k (); 
    bool audioSampling16k_isSelected() const;

    class audioSampling22k05 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling22k05

    audioSampling22k05::reference select_audioSampling22k05 (); 
    bool audioSampling22k05_isSelected() const;

    class audioSampling24k {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling24k

    audioSampling24k::reference select_audioSampling24k (); 
    bool audioSampling24k_isSelected() const;

    class audioSampling32k {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling32k

    audioSampling32k::reference select_audioSampling32k (); 
    bool audioSampling32k_isSelected() const;

    class audioSampling44k1 {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling44k1

    audioSampling44k1::reference select_audioSampling44k1 (); 
    bool audioSampling44k1_isSelected() const;

    class audioSampling48k {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling48k

    audioSampling48k::reference select_audioSampling48k (); 
    bool audioSampling48k_isSelected() const;

    IS13818AudioMode_audioSampling(audioSampling16k::Id id, audioSampling16k::const_reference value);
    IS13818AudioMode_audioSampling(audioSampling22k05::Id id, audioSampling22k05::const_reference value);
    IS13818AudioMode_audioSampling(audioSampling24k::Id id, audioSampling24k::const_reference value);
    IS13818AudioMode_audioSampling(audioSampling32k::Id id, audioSampling32k::const_reference value);
    IS13818AudioMode_audioSampling(audioSampling44k1::Id id, audioSampling44k1::const_reference value);
    IS13818AudioMode_audioSampling(audioSampling48k::Id id, audioSampling48k::const_reference value);
    void swap(IS13818AudioMode_audioSampling & other);
    IS13818AudioMode_audioSampling(const IS13818AudioMode_audioSampling & other)
    : Inherited(other) {} 

    IS13818AudioMode_audioSampling & operator = (const IS13818AudioMode_audioSampling & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IS13818AudioMode_audioSampling * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[6];
    static const char* selectionNames[6];
};

//
// IS13818AudioMode_multichannelType
//

class IS13818AudioMode_multichannelType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS13818AudioMode_multichannelType(const void* info) : Inherited(info) {}
  public:
    IS13818AudioMode_multichannelType() : Inherited(&theInfo) {}
    class singleChannel {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class singleChannel

    singleChannel::reference select_singleChannel (); 
    bool singleChannel_isSelected() const;

    class twoChannelStereo {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoChannelStereo

    twoChannelStereo::reference select_twoChannelStereo (); 
    bool twoChannelStereo_isSelected() const;

    class twoChannelDual {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoChannelDual

    twoChannelDual::reference select_twoChannelDual (); 
    bool twoChannelDual_isSelected() const;

    class threeChannels2_1 {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class threeChannels2_1

    threeChannels2_1::reference select_threeChannels2_1 (); 
    bool threeChannels2_1_isSelected() const;

    class threeChannels3_0 {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class threeChannels3_0

    threeChannels3_0::reference select_threeChannels3_0 (); 
    bool threeChannels3_0_isSelected() const;

    class fourChannels2_0_2_0 {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fourChannels2_0_2_0

    fourChannels2_0_2_0::reference select_fourChannels2_0_2_0 (); 
    bool fourChannels2_0_2_0_isSelected() const;

    class fourChannels2_2 {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fourChannels2_2

    fourChannels2_2::reference select_fourChannels2_2 (); 
    bool fourChannels2_2_isSelected() const;

    class fourChannels3_1 {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fourChannels3_1

    fourChannels3_1::reference select_fourChannels3_1 (); 
    bool fourChannels3_1_isSelected() const;

    class fiveChannels3_0_2_0 {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fiveChannels3_0_2_0

    fiveChannels3_0_2_0::reference select_fiveChannels3_0_2_0 (); 
    bool fiveChannels3_0_2_0_isSelected() const;

    class fiveChannels3_2 {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fiveChannels3_2

    fiveChannels3_2::reference select_fiveChannels3_2 (); 
    bool fiveChannels3_2_isSelected() const;

    IS13818AudioMode_multichannelType(singleChannel::Id id, singleChannel::const_reference value);
    IS13818AudioMode_multichannelType(twoChannelStereo::Id id, twoChannelStereo::const_reference value);
    IS13818AudioMode_multichannelType(twoChannelDual::Id id, twoChannelDual::const_reference value);
    IS13818AudioMode_multichannelType(threeChannels2_1::Id id, threeChannels2_1::const_reference value);
    IS13818AudioMode_multichannelType(threeChannels3_0::Id id, threeChannels3_0::const_reference value);
    IS13818AudioMode_multichannelType(fourChannels2_0_2_0::Id id, fourChannels2_0_2_0::const_reference value);
    IS13818AudioMode_multichannelType(fourChannels2_2::Id id, fourChannels2_2::const_reference value);
    IS13818AudioMode_multichannelType(fourChannels3_1::Id id, fourChannels3_1::const_reference value);
    IS13818AudioMode_multichannelType(fiveChannels3_0_2_0::Id id, fiveChannels3_0_2_0::const_reference value);
    IS13818AudioMode_multichannelType(fiveChannels3_2::Id id, fiveChannels3_2::const_reference value);
    void swap(IS13818AudioMode_multichannelType & other);
    IS13818AudioMode_multichannelType(const IS13818AudioMode_multichannelType & other)
    : Inherited(other) {} 

    IS13818AudioMode_multichannelType & operator = (const IS13818AudioMode_multichannelType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IS13818AudioMode_multichannelType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[10];
    static const char* selectionNames[10];
};

//
// G7231AnnexCMode_g723AnnexCAudioMode
//

class G7231AnnexCMode_g723AnnexCAudioMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    G7231AnnexCMode_g723AnnexCAudioMode(const void* info) : Inherited(info) {}
  public:
    G7231AnnexCMode_g723AnnexCAudioMode() : Inherited(&theInfo) {}
    G7231AnnexCMode_g723AnnexCAudioMode(const G7231AnnexCMode_g723AnnexCAudioMode & other) : Inherited(other)
    {}
    G7231AnnexCMode_g723AnnexCAudioMode& operator = (const G7231AnnexCMode_g723AnnexCAudioMode& other)
    { Inherited::operator = (other); return *this; } 
    class highRateMode0 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 27, 78>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class highRateMode0
    highRateMode0::const_reference get_highRateMode0 () const;
    highRateMode0::reference ref_highRateMode0 ();
    highRateMode0::reference set_highRateMode0 ();
    highRateMode0::reference set_highRateMode0 (highRateMode0::value_type::int_type value);
    class highRateMode1 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 27, 78>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class highRateMode1
    highRateMode1::const_reference get_highRateMode1 () const;
    highRateMode1::reference ref_highRateMode1 ();
    highRateMode1::reference set_highRateMode1 ();
    highRateMode1::reference set_highRateMode1 (highRateMode1::value_type::int_type value);
    class lowRateMode0 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 23, 66>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowRateMode0
    lowRateMode0::const_reference get_lowRateMode0 () const;
    lowRateMode0::reference ref_lowRateMode0 ();
    lowRateMode0::reference set_lowRateMode0 ();
    lowRateMode0::reference set_lowRateMode0 (lowRateMode0::value_type::int_type value);
    class lowRateMode1 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 23, 66>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowRateMode1
    lowRateMode1::const_reference get_lowRateMode1 () const;
    lowRateMode1::reference ref_lowRateMode1 ();
    lowRateMode1::reference set_lowRateMode1 ();
    lowRateMode1::reference set_lowRateMode1 (lowRateMode1::value_type::int_type value);
    class sidMode0 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 6, 17>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sidMode0
    sidMode0::const_reference get_sidMode0 () const;
    sidMode0::reference ref_sidMode0 ();
    sidMode0::reference set_sidMode0 ();
    sidMode0::reference set_sidMode0 (sidMode0::value_type::int_type value);
    class sidMode1 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 6, 17>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sidMode1
    sidMode1::const_reference get_sidMode1 () const;
    sidMode1::reference ref_sidMode1 ();
    sidMode1::reference set_sidMode1 ();
    sidMode1::reference set_sidMode1 (sidMode1::value_type::int_type value);
    void swap(G7231AnnexCMode_g723AnnexCAudioMode& other);
    G7231AnnexCMode_g723AnnexCAudioMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// MaintenanceLoopRequest_type
//

class MaintenanceLoopRequest_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopRequest_type(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopRequest_type() : Inherited(&theInfo) {}
    class systemLoop {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class systemLoop

    systemLoop::reference select_systemLoop (); 
    bool systemLoop_isSelected() const;

    class mediaLoop {
      public:
        enum Id { id_ = 1 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaLoop

    mediaLoop::const_reference get_mediaLoop () const;
    mediaLoop::reference ref_mediaLoop (); 
    mediaLoop::reference select_mediaLoop (); 
    mediaLoop::reference select_mediaLoop (mediaLoop::value_type::int_type value); 
    bool mediaLoop_isSelected() const;

    class logicalChannelLoop {
      public:
        enum Id { id_ = 2 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelLoop

    logicalChannelLoop::const_reference get_logicalChannelLoop () const;
    logicalChannelLoop::reference ref_logicalChannelLoop (); 
    logicalChannelLoop::reference select_logicalChannelLoop (); 
    logicalChannelLoop::reference select_logicalChannelLoop (logicalChannelLoop::value_type::int_type value); 
    bool logicalChannelLoop_isSelected() const;

    MaintenanceLoopRequest_type(systemLoop::Id id, systemLoop::const_reference value);
    MaintenanceLoopRequest_type(mediaLoop::Id id, mediaLoop::value_type::int_type value);
    MaintenanceLoopRequest_type(logicalChannelLoop::Id id, logicalChannelLoop::value_type::int_type value);
    void swap(MaintenanceLoopRequest_type & other);
    MaintenanceLoopRequest_type(const MaintenanceLoopRequest_type & other)
    : Inherited(other) {} 

    MaintenanceLoopRequest_type & operator = (const MaintenanceLoopRequest_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MaintenanceLoopRequest_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MaintenanceLoopAck_type
//

class MaintenanceLoopAck_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopAck_type(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopAck_type() : Inherited(&theInfo) {}
    class systemLoop {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class systemLoop

    systemLoop::reference select_systemLoop (); 
    bool systemLoop_isSelected() const;

    class mediaLoop {
      public:
        enum Id { id_ = 1 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaLoop

    mediaLoop::const_reference get_mediaLoop () const;
    mediaLoop::reference ref_mediaLoop (); 
    mediaLoop::reference select_mediaLoop (); 
    mediaLoop::reference select_mediaLoop (mediaLoop::value_type::int_type value); 
    bool mediaLoop_isSelected() const;

    class logicalChannelLoop {
      public:
        enum Id { id_ = 2 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelLoop

    logicalChannelLoop::const_reference get_logicalChannelLoop () const;
    logicalChannelLoop::reference ref_logicalChannelLoop (); 
    logicalChannelLoop::reference select_logicalChannelLoop (); 
    logicalChannelLoop::reference select_logicalChannelLoop (logicalChannelLoop::value_type::int_type value); 
    bool logicalChannelLoop_isSelected() const;

    MaintenanceLoopAck_type(systemLoop::Id id, systemLoop::const_reference value);
    MaintenanceLoopAck_type(mediaLoop::Id id, mediaLoop::value_type::int_type value);
    MaintenanceLoopAck_type(logicalChannelLoop::Id id, logicalChannelLoop::value_type::int_type value);
    void swap(MaintenanceLoopAck_type & other);
    MaintenanceLoopAck_type(const MaintenanceLoopAck_type & other)
    : Inherited(other) {} 

    MaintenanceLoopAck_type & operator = (const MaintenanceLoopAck_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MaintenanceLoopAck_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MaintenanceLoopReject_type
//

class MaintenanceLoopReject_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopReject_type(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopReject_type() : Inherited(&theInfo) {}
    class systemLoop {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class systemLoop

    systemLoop::reference select_systemLoop (); 
    bool systemLoop_isSelected() const;

    class mediaLoop {
      public:
        enum Id { id_ = 1 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaLoop

    mediaLoop::const_reference get_mediaLoop () const;
    mediaLoop::reference ref_mediaLoop (); 
    mediaLoop::reference select_mediaLoop (); 
    mediaLoop::reference select_mediaLoop (mediaLoop::value_type::int_type value); 
    bool mediaLoop_isSelected() const;

    class logicalChannelLoop {
      public:
        enum Id { id_ = 2 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelLoop

    logicalChannelLoop::const_reference get_logicalChannelLoop () const;
    logicalChannelLoop::reference ref_logicalChannelLoop (); 
    logicalChannelLoop::reference select_logicalChannelLoop (); 
    logicalChannelLoop::reference select_logicalChannelLoop (logicalChannelLoop::value_type::int_type value); 
    bool logicalChannelLoop_isSelected() const;

    MaintenanceLoopReject_type(systemLoop::Id id, systemLoop::const_reference value);
    MaintenanceLoopReject_type(mediaLoop::Id id, mediaLoop::value_type::int_type value);
    MaintenanceLoopReject_type(logicalChannelLoop::Id id, logicalChannelLoop::value_type::int_type value);
    void swap(MaintenanceLoopReject_type & other);
    MaintenanceLoopReject_type(const MaintenanceLoopReject_type & other)
    : Inherited(other) {} 

    MaintenanceLoopReject_type & operator = (const MaintenanceLoopReject_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MaintenanceLoopReject_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MaintenanceLoopReject_cause
//

class MaintenanceLoopReject_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopReject_cause(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopReject_cause() : Inherited(&theInfo) {}
    class canNotPerformLoop {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class canNotPerformLoop

    canNotPerformLoop::reference select_canNotPerformLoop (); 
    bool canNotPerformLoop_isSelected() const;

    MaintenanceLoopReject_cause(canNotPerformLoop::Id id, canNotPerformLoop::const_reference value);
    void swap(MaintenanceLoopReject_cause & other);
    MaintenanceLoopReject_cause(const MaintenanceLoopReject_cause & other)
    : Inherited(other) {} 

    MaintenanceLoopReject_cause & operator = (const MaintenanceLoopReject_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MaintenanceLoopReject_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// ConferenceResponse_makeMeChairResponse
//

class ConferenceResponse_makeMeChairResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_makeMeChairResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_makeMeChairResponse() : Inherited(&theInfo) {}
    class grantedChairToken {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class grantedChairToken

    grantedChairToken::reference select_grantedChairToken (); 
    bool grantedChairToken_isSelected() const;

    class deniedChairToken {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deniedChairToken

    deniedChairToken::reference select_deniedChairToken (); 
    bool deniedChairToken_isSelected() const;

    ConferenceResponse_makeMeChairResponse(grantedChairToken::Id id, grantedChairToken::const_reference value);
    ConferenceResponse_makeMeChairResponse(deniedChairToken::Id id, deniedChairToken::const_reference value);
    void swap(ConferenceResponse_makeMeChairResponse & other);
    ConferenceResponse_makeMeChairResponse(const ConferenceResponse_makeMeChairResponse & other)
    : Inherited(other) {} 

    ConferenceResponse_makeMeChairResponse & operator = (const ConferenceResponse_makeMeChairResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceResponse_makeMeChairResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// ConferenceResponse_extensionAddressResponse
//

class ConferenceResponse_extensionAddressResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_extensionAddressResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_extensionAddressResponse() : Inherited(&theInfo) {}
    ConferenceResponse_extensionAddressResponse(const ConferenceResponse_extensionAddressResponse & other) : Inherited(other)
    {}
    ConferenceResponse_extensionAddressResponse& operator = (const ConferenceResponse_extensionAddressResponse& other)
    { Inherited::operator = (other); return *this; } 
    class extensionAddress {
      public:
        typedef TerminalID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class extensionAddress
    extensionAddress::const_reference get_extensionAddress () const;
    extensionAddress::reference ref_extensionAddress ();
    extensionAddress::reference set_extensionAddress ();
    extensionAddress::reference set_extensionAddress (const std::vector<char>& value);
    void swap(ConferenceResponse_extensionAddressResponse& other);
    ConferenceResponse_extensionAddressResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// ConferenceResponse_broadcastMyLogicalChannelResponse
//

class ConferenceResponse_broadcastMyLogicalChannelResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_broadcastMyLogicalChannelResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_broadcastMyLogicalChannelResponse() : Inherited(&theInfo) {}
    class grantedBroadcastMyLogicalChannel {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class grantedBroadcastMyLogicalChannel

    grantedBroadcastMyLogicalChannel::reference select_grantedBroadcastMyLogicalChannel (); 
    bool grantedBroadcastMyLogicalChannel_isSelected() const;

    class deniedBroadcastMyLogicalChannel {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deniedBroadcastMyLogicalChannel

    deniedBroadcastMyLogicalChannel::reference select_deniedBroadcastMyLogicalChannel (); 
    bool deniedBroadcastMyLogicalChannel_isSelected() const;

    ConferenceResponse_broadcastMyLogicalChannelResponse(grantedBroadcastMyLogicalChannel::Id id, grantedBroadcastMyLogicalChannel::const_reference value);
    ConferenceResponse_broadcastMyLogicalChannelResponse(deniedBroadcastMyLogicalChannel::Id id, deniedBroadcastMyLogicalChannel::const_reference value);
    void swap(ConferenceResponse_broadcastMyLogicalChannelResponse & other);
    ConferenceResponse_broadcastMyLogicalChannelResponse(const ConferenceResponse_broadcastMyLogicalChannelResponse & other)
    : Inherited(other) {} 

    ConferenceResponse_broadcastMyLogicalChannelResponse & operator = (const ConferenceResponse_broadcastMyLogicalChannelResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceResponse_broadcastMyLogicalChannelResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// ConferenceResponse_makeTerminalBroadcasterResponse
//

class ConferenceResponse_makeTerminalBroadcasterResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_makeTerminalBroadcasterResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_makeTerminalBroadcasterResponse() : Inherited(&theInfo) {}
    class grantedMakeTerminalBroadcaster {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class grantedMakeTerminalBroadcaster

    grantedMakeTerminalBroadcaster::reference select_grantedMakeTerminalBroadcaster (); 
    bool grantedMakeTerminalBroadcaster_isSelected() const;

    class deniedMakeTerminalBroadcaster {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deniedMakeTerminalBroadcaster

    deniedMakeTerminalBroadcaster::reference select_deniedMakeTerminalBroadcaster (); 
    bool deniedMakeTerminalBroadcaster_isSelected() const;

    ConferenceResponse_makeTerminalBroadcasterResponse(grantedMakeTerminalBroadcaster::Id id, grantedMakeTerminalBroadcaster::const_reference value);
    ConferenceResponse_makeTerminalBroadcasterResponse(deniedMakeTerminalBroadcaster::Id id, deniedMakeTerminalBroadcaster::const_reference value);
    void swap(ConferenceResponse_makeTerminalBroadcasterResponse & other);
    ConferenceResponse_makeTerminalBroadcasterResponse(const ConferenceResponse_makeTerminalBroadcasterResponse & other)
    : Inherited(other) {} 

    ConferenceResponse_makeTerminalBroadcasterResponse & operator = (const ConferenceResponse_makeTerminalBroadcasterResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceResponse_makeTerminalBroadcasterResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// ConferenceResponse_sendThisSourceResponse
//

class ConferenceResponse_sendThisSourceResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_sendThisSourceResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_sendThisSourceResponse() : Inherited(&theInfo) {}
    class grantedSendThisSource {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class grantedSendThisSource

    grantedSendThisSource::reference select_grantedSendThisSource (); 
    bool grantedSendThisSource_isSelected() const;

    class deniedSendThisSource {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deniedSendThisSource

    deniedSendThisSource::reference select_deniedSendThisSource (); 
    bool deniedSendThisSource_isSelected() const;

    ConferenceResponse_sendThisSourceResponse(grantedSendThisSource::Id id, grantedSendThisSource::const_reference value);
    ConferenceResponse_sendThisSourceResponse(deniedSendThisSource::Id id, deniedSendThisSource::const_reference value);
    void swap(ConferenceResponse_sendThisSourceResponse & other);
    ConferenceResponse_sendThisSourceResponse(const ConferenceResponse_sendThisSourceResponse & other)
    : Inherited(other) {} 

    ConferenceResponse_sendThisSourceResponse & operator = (const ConferenceResponse_sendThisSourceResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceResponse_sendThisSourceResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// RemoteMCResponse_reject
//

class RemoteMCResponse_reject : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RemoteMCResponse_reject(const void* info) : Inherited(info) {}
  public:
    RemoteMCResponse_reject() : Inherited(&theInfo) {}
    class unspecified {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unspecified

    unspecified::reference select_unspecified (); 
    bool unspecified_isSelected() const;

    class functionNotSupported {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class functionNotSupported

    functionNotSupported::reference select_functionNotSupported (); 
    bool functionNotSupported_isSelected() const;

    RemoteMCResponse_reject(unspecified::Id id, unspecified::const_reference value);
    RemoteMCResponse_reject(functionNotSupported::Id id, functionNotSupported::const_reference value);
    void swap(RemoteMCResponse_reject & other);
    RemoteMCResponse_reject(const RemoteMCResponse_reject & other)
    : Inherited(other) {} 

    RemoteMCResponse_reject & operator = (const RemoteMCResponse_reject & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RemoteMCResponse_reject * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MultilinkRequest_callInformation
//

class MultilinkRequest_callInformation : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkRequest_callInformation(const void* info) : Inherited(info) {}
  public:
    MultilinkRequest_callInformation() : Inherited(&theInfo) {}
    MultilinkRequest_callInformation(const MultilinkRequest_callInformation & other) : Inherited(other)
    {}
    MultilinkRequest_callInformation& operator = (const MultilinkRequest_callInformation& other)
    { Inherited::operator = (other); return *this; } 
    class maxNumberOfAdditionalConnections {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxNumberOfAdditionalConnections
    maxNumberOfAdditionalConnections::const_reference get_maxNumberOfAdditionalConnections () const;
    maxNumberOfAdditionalConnections::reference ref_maxNumberOfAdditionalConnections ();
    maxNumberOfAdditionalConnections::reference set_maxNumberOfAdditionalConnections ();
    maxNumberOfAdditionalConnections::reference set_maxNumberOfAdditionalConnections (maxNumberOfAdditionalConnections::value_type::int_type value);
    void swap(MultilinkRequest_callInformation& other);
    MultilinkRequest_callInformation * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultilinkRequest_removeConnection
//

class MultilinkRequest_removeConnection : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkRequest_removeConnection(const void* info) : Inherited(info) {}
  public:
    MultilinkRequest_removeConnection() : Inherited(&theInfo) {}
    MultilinkRequest_removeConnection(const MultilinkRequest_removeConnection & other) : Inherited(other)
    {}
    MultilinkRequest_removeConnection& operator = (const MultilinkRequest_removeConnection& other)
    { Inherited::operator = (other); return *this; } 
    class connectionIdentifier {
      public:
        typedef ConnectionIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class connectionIdentifier
    connectionIdentifier::const_reference get_connectionIdentifier () const;
    connectionIdentifier::reference ref_connectionIdentifier ();
    connectionIdentifier::reference set_connectionIdentifier ();
    connectionIdentifier::reference set_connectionIdentifier (connectionIdentifier::const_reference value);
    void swap(MultilinkRequest_removeConnection& other);
    MultilinkRequest_removeConnection * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultilinkResponse_removeConnection
//

class MultilinkResponse_removeConnection : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse_removeConnection(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse_removeConnection() : Inherited(&theInfo) {}
    MultilinkResponse_removeConnection(const MultilinkResponse_removeConnection & other) : Inherited(other)
    {}
    MultilinkResponse_removeConnection& operator = (const MultilinkResponse_removeConnection& other)
    { Inherited::operator = (other); return *this; } 
    class connectionIdentifier {
      public:
        typedef ConnectionIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class connectionIdentifier
    connectionIdentifier::const_reference get_connectionIdentifier () const;
    connectionIdentifier::reference ref_connectionIdentifier ();
    connectionIdentifier::reference set_connectionIdentifier ();
    connectionIdentifier::reference set_connectionIdentifier (connectionIdentifier::const_reference value);
    void swap(MultilinkResponse_removeConnection& other);
    MultilinkResponse_removeConnection * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultilinkResponse_maximumHeaderInterval
//

class MultilinkResponse_maximumHeaderInterval : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse_maximumHeaderInterval(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse_maximumHeaderInterval() : Inherited(&theInfo) {}
    MultilinkResponse_maximumHeaderInterval(const MultilinkResponse_maximumHeaderInterval & other) : Inherited(other)
    {}
    MultilinkResponse_maximumHeaderInterval& operator = (const MultilinkResponse_maximumHeaderInterval& other)
    { Inherited::operator = (other); return *this; } 
    class currentInterval {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class currentInterval
    currentInterval::const_reference get_currentInterval () const;
    currentInterval::reference ref_currentInterval ();
    currentInterval::reference set_currentInterval ();
    currentInterval::reference set_currentInterval (currentInterval::value_type::int_type value);
    void swap(MultilinkResponse_maximumHeaderInterval& other);
    MultilinkResponse_maximumHeaderInterval * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultilinkIndication_crcDesired
//

class MultilinkIndication_crcDesired : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkIndication_crcDesired(const void* info) : Inherited(info) {}
  public:
    MultilinkIndication_crcDesired() : Inherited(&theInfo) {}
    MultilinkIndication_crcDesired(const MultilinkIndication_crcDesired & other) : Inherited(other)
    {}
    MultilinkIndication_crcDesired& operator = (const MultilinkIndication_crcDesired& other)
    { Inherited::operator = (other); return *this; } 
    void swap(MultilinkIndication_crcDesired& other);
    MultilinkIndication_crcDesired * clone() const;
    static const InfoType theInfo;
  private:
};

//
// MultilinkIndication_excessiveError
//

class MultilinkIndication_excessiveError : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkIndication_excessiveError(const void* info) : Inherited(info) {}
  public:
    MultilinkIndication_excessiveError() : Inherited(&theInfo) {}
    MultilinkIndication_excessiveError(const MultilinkIndication_excessiveError & other) : Inherited(other)
    {}
    MultilinkIndication_excessiveError& operator = (const MultilinkIndication_excessiveError& other)
    { Inherited::operator = (other); return *this; } 
    class connectionIdentifier {
      public:
        typedef ConnectionIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class connectionIdentifier
    connectionIdentifier::const_reference get_connectionIdentifier () const;
    connectionIdentifier::reference ref_connectionIdentifier ();
    connectionIdentifier::reference set_connectionIdentifier ();
    connectionIdentifier::reference set_connectionIdentifier (connectionIdentifier::const_reference value);
    void swap(MultilinkIndication_excessiveError& other);
    MultilinkIndication_excessiveError * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// SendTerminalCapabilitySet_specificRequest
//

class SendTerminalCapabilitySet_specificRequest : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    SendTerminalCapabilitySet_specificRequest(const void* info) : Inherited(info) {}
  public:
    SendTerminalCapabilitySet_specificRequest() : Inherited(&theInfo) {}
    SendTerminalCapabilitySet_specificRequest(const SendTerminalCapabilitySet_specificRequest & other) : Inherited(other)
    {}
    SendTerminalCapabilitySet_specificRequest& operator = (const SendTerminalCapabilitySet_specificRequest& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_capabilityTableEntryNumbers,
      e_capabilityDescriptorNumbers
    };

    class multiplexCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexCapability
    multiplexCapability::const_reference get_multiplexCapability () const;
    multiplexCapability::reference ref_multiplexCapability ();
    multiplexCapability::reference set_multiplexCapability ();
    multiplexCapability::reference set_multiplexCapability (bool value);
    class capabilityTableEntryNumbers {
      public:
        typedef ASN1::SET_OF<CapabilityTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 65535> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityTableEntryNumbers
    capabilityTableEntryNumbers::const_reference get_capabilityTableEntryNumbers () const;
    capabilityTableEntryNumbers::reference ref_capabilityTableEntryNumbers ();
    capabilityTableEntryNumbers::reference set_capabilityTableEntryNumbers ();
    capabilityTableEntryNumbers::reference set_capabilityTableEntryNumbers (capabilityTableEntryNumbers::const_reference value);
    void omit_capabilityTableEntryNumbers ();
    bool capabilityTableEntryNumbers_isPresent () const;
    class capabilityDescriptorNumbers {
      public:
        typedef ASN1::SET_OF<CapabilityDescriptorNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityDescriptorNumbers
    capabilityDescriptorNumbers::const_reference get_capabilityDescriptorNumbers () const;
    capabilityDescriptorNumbers::reference ref_capabilityDescriptorNumbers ();
    capabilityDescriptorNumbers::reference set_capabilityDescriptorNumbers ();
    capabilityDescriptorNumbers::reference set_capabilityDescriptorNumbers (capabilityDescriptorNumbers::const_reference value);
    void omit_capabilityDescriptorNumbers ();
    bool capabilityDescriptorNumbers_isPresent () const;
    void swap(SendTerminalCapabilitySet_specificRequest& other);
    SendTerminalCapabilitySet_specificRequest * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// FlowControlCommand_scope
//

class FlowControlCommand_scope : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FlowControlCommand_scope(const void* info) : Inherited(info) {}
  public:
    FlowControlCommand_scope() : Inherited(&theInfo) {}
    class logicalChannelNumber {
      public:
        enum Id { id_ = 0 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber

    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (logicalChannelNumber::value_type::int_type value); 
    bool logicalChannelNumber_isSelected() const;

    class resourceID {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resourceID

    resourceID::const_reference get_resourceID () const;
    resourceID::reference ref_resourceID (); 
    resourceID::reference select_resourceID (); 
    resourceID::reference select_resourceID (resourceID::value_type::int_type value); 
    bool resourceID_isSelected() const;

    class wholeMultiplex {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class wholeMultiplex

    wholeMultiplex::reference select_wholeMultiplex (); 
    bool wholeMultiplex_isSelected() const;

    FlowControlCommand_scope(logicalChannelNumber::Id id, logicalChannelNumber::value_type::int_type value);
    FlowControlCommand_scope(resourceID::Id id, resourceID::value_type::int_type value);
    FlowControlCommand_scope(wholeMultiplex::Id id, wholeMultiplex::const_reference value);
    void swap(FlowControlCommand_scope & other);
    FlowControlCommand_scope(const FlowControlCommand_scope & other)
    : Inherited(other) {} 

    FlowControlCommand_scope & operator = (const FlowControlCommand_scope & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FlowControlCommand_scope * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// FlowControlCommand_restriction
//

class FlowControlCommand_restriction : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FlowControlCommand_restriction(const void* info) : Inherited(info) {}
  public:
    FlowControlCommand_restriction() : Inherited(&theInfo) {}
    class maximumBitRate {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16777215>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumBitRate

    maximumBitRate::const_reference get_maximumBitRate () const;
    maximumBitRate::reference ref_maximumBitRate (); 
    maximumBitRate::reference select_maximumBitRate (); 
    maximumBitRate::reference select_maximumBitRate (maximumBitRate::value_type::int_type value); 
    bool maximumBitRate_isSelected() const;

    class noRestriction {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noRestriction

    noRestriction::reference select_noRestriction (); 
    bool noRestriction_isSelected() const;

    FlowControlCommand_restriction(maximumBitRate::Id id, maximumBitRate::value_type::int_type value);
    FlowControlCommand_restriction(noRestriction::Id id, noRestriction::const_reference value);
    void swap(FlowControlCommand_restriction & other);
    FlowControlCommand_restriction(const FlowControlCommand_restriction & other)
    : Inherited(other) {} 

    FlowControlCommand_restriction & operator = (const FlowControlCommand_restriction & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FlowControlCommand_restriction * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// EndSessionCommand_gstnOptions
//

class EndSessionCommand_gstnOptions : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EndSessionCommand_gstnOptions(const void* info) : Inherited(info) {}
  public:
    EndSessionCommand_gstnOptions() : Inherited(&theInfo) {}
    class telephonyMode {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class telephonyMode

    telephonyMode::reference select_telephonyMode (); 
    bool telephonyMode_isSelected() const;

    class v8bis {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v8bis

    v8bis::reference select_v8bis (); 
    bool v8bis_isSelected() const;

    class v34DSVD {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v34DSVD

    v34DSVD::reference select_v34DSVD (); 
    bool v34DSVD_isSelected() const;

    class v34DuplexFAX {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v34DuplexFAX

    v34DuplexFAX::reference select_v34DuplexFAX (); 
    bool v34DuplexFAX_isSelected() const;

    class v34H324 {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v34H324

    v34H324::reference select_v34H324 (); 
    bool v34H324_isSelected() const;

    EndSessionCommand_gstnOptions(telephonyMode::Id id, telephonyMode::const_reference value);
    EndSessionCommand_gstnOptions(v8bis::Id id, v8bis::const_reference value);
    EndSessionCommand_gstnOptions(v34DSVD::Id id, v34DSVD::const_reference value);
    EndSessionCommand_gstnOptions(v34DuplexFAX::Id id, v34DuplexFAX::const_reference value);
    EndSessionCommand_gstnOptions(v34H324::Id id, v34H324::const_reference value);
    void swap(EndSessionCommand_gstnOptions & other);
    EndSessionCommand_gstnOptions(const EndSessionCommand_gstnOptions & other)
    : Inherited(other) {} 

    EndSessionCommand_gstnOptions & operator = (const EndSessionCommand_gstnOptions & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    EndSessionCommand_gstnOptions * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// EndSessionCommand_isdnOptions
//

class EndSessionCommand_isdnOptions : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EndSessionCommand_isdnOptions(const void* info) : Inherited(info) {}
  public:
    EndSessionCommand_isdnOptions() : Inherited(&theInfo) {}
    class telephonyMode {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class telephonyMode

    telephonyMode::reference select_telephonyMode (); 
    bool telephonyMode_isSelected() const;

    class v140 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v140

    v140::reference select_v140 (); 
    bool v140_isSelected() const;

    class terminalOnHold {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalOnHold

    terminalOnHold::reference select_terminalOnHold (); 
    bool terminalOnHold_isSelected() const;

    EndSessionCommand_isdnOptions(telephonyMode::Id id, telephonyMode::const_reference value);
    EndSessionCommand_isdnOptions(v140::Id id, v140::const_reference value);
    EndSessionCommand_isdnOptions(terminalOnHold::Id id, terminalOnHold::const_reference value);
    void swap(EndSessionCommand_isdnOptions & other);
    EndSessionCommand_isdnOptions(const EndSessionCommand_isdnOptions & other)
    : Inherited(other) {} 

    EndSessionCommand_isdnOptions & operator = (const EndSessionCommand_isdnOptions & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    EndSessionCommand_isdnOptions * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// H223MultiplexReconfiguration_h223ModeChange
//

class H223MultiplexReconfiguration_h223ModeChange : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223MultiplexReconfiguration_h223ModeChange(const void* info) : Inherited(info) {}
  public:
    H223MultiplexReconfiguration_h223ModeChange() : Inherited(&theInfo) {}
    class toLevel0 {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class toLevel0

    toLevel0::reference select_toLevel0 (); 
    bool toLevel0_isSelected() const;

    class toLevel1 {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class toLevel1

    toLevel1::reference select_toLevel1 (); 
    bool toLevel1_isSelected() const;

    class toLevel2 {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class toLevel2

    toLevel2::reference select_toLevel2 (); 
    bool toLevel2_isSelected() const;

    class toLevel2withOptionalHeader {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class toLevel2withOptionalHeader

    toLevel2withOptionalHeader::reference select_toLevel2withOptionalHeader (); 
    bool toLevel2withOptionalHeader_isSelected() const;

    H223MultiplexReconfiguration_h223ModeChange(toLevel0::Id id, toLevel0::const_reference value);
    H223MultiplexReconfiguration_h223ModeChange(toLevel1::Id id, toLevel1::const_reference value);
    H223MultiplexReconfiguration_h223ModeChange(toLevel2::Id id, toLevel2::const_reference value);
    H223MultiplexReconfiguration_h223ModeChange(toLevel2withOptionalHeader::Id id, toLevel2withOptionalHeader::const_reference value);
    void swap(H223MultiplexReconfiguration_h223ModeChange & other);
    H223MultiplexReconfiguration_h223ModeChange(const H223MultiplexReconfiguration_h223ModeChange & other)
    : Inherited(other) {} 

    H223MultiplexReconfiguration_h223ModeChange & operator = (const H223MultiplexReconfiguration_h223ModeChange & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223MultiplexReconfiguration_h223ModeChange * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// H223MultiplexReconfiguration_h223AnnexADoubleFlag
//

class H223MultiplexReconfiguration_h223AnnexADoubleFlag : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223MultiplexReconfiguration_h223AnnexADoubleFlag(const void* info) : Inherited(info) {}
  public:
    H223MultiplexReconfiguration_h223AnnexADoubleFlag() : Inherited(&theInfo) {}
    class start {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class start

    start::reference select_start (); 
    bool start_isSelected() const;

    class stop {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class stop

    stop::reference select_stop (); 
    bool stop_isSelected() const;

    H223MultiplexReconfiguration_h223AnnexADoubleFlag(start::Id id, start::const_reference value);
    H223MultiplexReconfiguration_h223AnnexADoubleFlag(stop::Id id, stop::const_reference value);
    void swap(H223MultiplexReconfiguration_h223AnnexADoubleFlag & other);
    H223MultiplexReconfiguration_h223AnnexADoubleFlag(const H223MultiplexReconfiguration_h223AnnexADoubleFlag & other)
    : Inherited(other) {} 

    H223MultiplexReconfiguration_h223AnnexADoubleFlag & operator = (const H223MultiplexReconfiguration_h223AnnexADoubleFlag & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223MultiplexReconfiguration_h223AnnexADoubleFlag * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// NewATMVCCommand_multiplex
//

class NewATMVCCommand_multiplex : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_multiplex(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_multiplex() : Inherited(&theInfo) {}
    class noMultiplex {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noMultiplex

    noMultiplex::reference select_noMultiplex (); 
    bool noMultiplex_isSelected() const;

    class transportStream {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportStream

    transportStream::reference select_transportStream (); 
    bool transportStream_isSelected() const;

    class programStream {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class programStream

    programStream::reference select_programStream (); 
    bool programStream_isSelected() const;

    NewATMVCCommand_multiplex(noMultiplex::Id id, noMultiplex::const_reference value);
    NewATMVCCommand_multiplex(transportStream::Id id, transportStream::const_reference value);
    NewATMVCCommand_multiplex(programStream::Id id, programStream::const_reference value);
    void swap(NewATMVCCommand_multiplex & other);
    NewATMVCCommand_multiplex(const NewATMVCCommand_multiplex & other)
    : Inherited(other) {} 

    NewATMVCCommand_multiplex & operator = (const NewATMVCCommand_multiplex & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCCommand_multiplex * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MobileMultilinkReconfigurationCommand_status
//

class MobileMultilinkReconfigurationCommand_status : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MobileMultilinkReconfigurationCommand_status(const void* info) : Inherited(info) {}
  public:
    MobileMultilinkReconfigurationCommand_status() : Inherited(&theInfo) {}
    class synchronized {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class synchronized

    synchronized::reference select_synchronized (); 
    bool synchronized_isSelected() const;

    class reconfiguration {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reconfiguration

    reconfiguration::reference select_reconfiguration (); 
    bool reconfiguration_isSelected() const;

    MobileMultilinkReconfigurationCommand_status(synchronized::Id id, synchronized::const_reference value);
    MobileMultilinkReconfigurationCommand_status(reconfiguration::Id id, reconfiguration::const_reference value);
    void swap(MobileMultilinkReconfigurationCommand_status & other);
    MobileMultilinkReconfigurationCommand_status(const MobileMultilinkReconfigurationCommand_status & other)
    : Inherited(other) {} 

    MobileMultilinkReconfigurationCommand_status & operator = (const MobileMultilinkReconfigurationCommand_status & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MobileMultilinkReconfigurationCommand_status * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// FunctionNotSupported_cause
//

class FunctionNotSupported_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FunctionNotSupported_cause(const void* info) : Inherited(info) {}
  public:
    FunctionNotSupported_cause() : Inherited(&theInfo) {}
    class syntaxError {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class syntaxError

    syntaxError::reference select_syntaxError (); 
    bool syntaxError_isSelected() const;

    class semanticError {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class semanticError

    semanticError::reference select_semanticError (); 
    bool semanticError_isSelected() const;

    class unknownFunction {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unknownFunction

    unknownFunction::reference select_unknownFunction (); 
    bool unknownFunction_isSelected() const;

    FunctionNotSupported_cause(syntaxError::Id id, syntaxError::const_reference value);
    FunctionNotSupported_cause(semanticError::Id id, semanticError::const_reference value);
    FunctionNotSupported_cause(unknownFunction::Id id, unknownFunction::const_reference value);
    void swap(FunctionNotSupported_cause & other);
    FunctionNotSupported_cause(const FunctionNotSupported_cause & other)
    : Inherited(other) {} 

    FunctionNotSupported_cause & operator = (const FunctionNotSupported_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FunctionNotSupported_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// JitterIndication_scope
//

class JitterIndication_scope : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    JitterIndication_scope(const void* info) : Inherited(info) {}
  public:
    JitterIndication_scope() : Inherited(&theInfo) {}
    class logicalChannelNumber {
      public:
        enum Id { id_ = 0 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber

    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (logicalChannelNumber::value_type::int_type value); 
    bool logicalChannelNumber_isSelected() const;

    class resourceID {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resourceID

    resourceID::const_reference get_resourceID () const;
    resourceID::reference ref_resourceID (); 
    resourceID::reference select_resourceID (); 
    resourceID::reference select_resourceID (resourceID::value_type::int_type value); 
    bool resourceID_isSelected() const;

    class wholeMultiplex {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class wholeMultiplex

    wholeMultiplex::reference select_wholeMultiplex (); 
    bool wholeMultiplex_isSelected() const;

    JitterIndication_scope(logicalChannelNumber::Id id, logicalChannelNumber::value_type::int_type value);
    JitterIndication_scope(resourceID::Id id, resourceID::value_type::int_type value);
    JitterIndication_scope(wholeMultiplex::Id id, wholeMultiplex::const_reference value);
    void swap(JitterIndication_scope & other);
    JitterIndication_scope(const JitterIndication_scope & other)
    : Inherited(other) {} 

    JitterIndication_scope & operator = (const JitterIndication_scope & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    JitterIndication_scope * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// NewATMVCIndication_multiplex
//

class NewATMVCIndication_multiplex : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_multiplex(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_multiplex() : Inherited(&theInfo) {}
    class noMultiplex {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noMultiplex

    noMultiplex::reference select_noMultiplex (); 
    bool noMultiplex_isSelected() const;

    class transportStream {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportStream

    transportStream::reference select_transportStream (); 
    bool transportStream_isSelected() const;

    class programStream {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class programStream

    programStream::reference select_programStream (); 
    bool programStream_isSelected() const;

    NewATMVCIndication_multiplex(noMultiplex::Id id, noMultiplex::const_reference value);
    NewATMVCIndication_multiplex(transportStream::Id id, transportStream::const_reference value);
    NewATMVCIndication_multiplex(programStream::Id id, programStream::const_reference value);
    void swap(NewATMVCIndication_multiplex & other);
    NewATMVCIndication_multiplex(const NewATMVCIndication_multiplex & other)
    : Inherited(other) {} 

    NewATMVCIndication_multiplex & operator = (const NewATMVCIndication_multiplex & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCIndication_multiplex * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// UserInputIndication_encryptedAlphanumeric
//

class UserInputIndication_encryptedAlphanumeric : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_encryptedAlphanumeric(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_encryptedAlphanumeric() : Inherited(&theInfo) {}
    UserInputIndication_encryptedAlphanumeric(const UserInputIndication_encryptedAlphanumeric & other) : Inherited(other)
    {}
    UserInputIndication_encryptedAlphanumeric& operator = (const UserInputIndication_encryptedAlphanumeric& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_paramS
    };

    class algorithmOID {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class algorithmOID
    algorithmOID::const_reference get_algorithmOID () const;
    algorithmOID::reference ref_algorithmOID ();
    algorithmOID::reference set_algorithmOID ();
    algorithmOID::reference set_algorithmOID (algorithmOID::const_reference value);
    class paramS {
      public:
        typedef Params value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class paramS
    paramS::const_reference get_paramS () const;
    paramS::reference ref_paramS ();
    paramS::reference set_paramS ();
    paramS::reference set_paramS (paramS::const_reference value);
    void omit_paramS ();
    bool paramS_isPresent () const;
    class encrypted {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encrypted
    encrypted::const_reference get_encrypted () const;
    encrypted::reference ref_encrypted ();
    encrypted::reference set_encrypted ();
    encrypted::reference set_encrypted (const std::vector<char>& value);
    void swap(UserInputIndication_encryptedAlphanumeric& other);
    UserInputIndication_encryptedAlphanumeric * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// FlowControlIndication_scope
//

class FlowControlIndication_scope : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FlowControlIndication_scope(const void* info) : Inherited(info) {}
  public:
    FlowControlIndication_scope() : Inherited(&theInfo) {}
    class logicalChannelNumber {
      public:
        enum Id { id_ = 0 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber

    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (logicalChannelNumber::value_type::int_type value); 
    bool logicalChannelNumber_isSelected() const;

    class resourceID {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resourceID

    resourceID::const_reference get_resourceID () const;
    resourceID::reference ref_resourceID (); 
    resourceID::reference select_resourceID (); 
    resourceID::reference select_resourceID (resourceID::value_type::int_type value); 
    bool resourceID_isSelected() const;

    class wholeMultiplex {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class wholeMultiplex

    wholeMultiplex::reference select_wholeMultiplex (); 
    bool wholeMultiplex_isSelected() const;

    FlowControlIndication_scope(logicalChannelNumber::Id id, logicalChannelNumber::value_type::int_type value);
    FlowControlIndication_scope(resourceID::Id id, resourceID::value_type::int_type value);
    FlowControlIndication_scope(wholeMultiplex::Id id, wholeMultiplex::const_reference value);
    void swap(FlowControlIndication_scope & other);
    FlowControlIndication_scope(const FlowControlIndication_scope & other)
    : Inherited(other) {} 

    FlowControlIndication_scope & operator = (const FlowControlIndication_scope & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FlowControlIndication_scope * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// FlowControlIndication_restriction
//

class FlowControlIndication_restriction : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FlowControlIndication_restriction(const void* info) : Inherited(info) {}
  public:
    FlowControlIndication_restriction() : Inherited(&theInfo) {}
    class maximumBitRate {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16777215>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumBitRate

    maximumBitRate::const_reference get_maximumBitRate () const;
    maximumBitRate::reference ref_maximumBitRate (); 
    maximumBitRate::reference select_maximumBitRate (); 
    maximumBitRate::reference select_maximumBitRate (maximumBitRate::value_type::int_type value); 
    bool maximumBitRate_isSelected() const;

    class noRestriction {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noRestriction

    noRestriction::reference select_noRestriction (); 
    bool noRestriction_isSelected() const;

    FlowControlIndication_restriction(maximumBitRate::Id id, maximumBitRate::value_type::int_type value);
    FlowControlIndication_restriction(noRestriction::Id id, noRestriction::const_reference value);
    void swap(FlowControlIndication_restriction & other);
    FlowControlIndication_restriction(const FlowControlIndication_restriction & other)
    : Inherited(other) {} 

    FlowControlIndication_restriction & operator = (const FlowControlIndication_restriction & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FlowControlIndication_restriction * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded
//

class TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(const void* info) : Inherited(info) {}
  public:
    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded() : Inherited(&theInfo) {}
    class highestEntryNumberProcessed {
      public:
        enum Id { id_ = 0 };
        typedef CapabilityTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class highestEntryNumberProcessed

    highestEntryNumberProcessed::const_reference get_highestEntryNumberProcessed () const;
    highestEntryNumberProcessed::reference ref_highestEntryNumberProcessed (); 
    highestEntryNumberProcessed::reference select_highestEntryNumberProcessed (); 
    highestEntryNumberProcessed::reference select_highestEntryNumberProcessed (highestEntryNumberProcessed::value_type::int_type value); 
    bool highestEntryNumberProcessed_isSelected() const;

    class noneProcessed {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noneProcessed

    noneProcessed::reference select_noneProcessed (); 
    bool noneProcessed_isSelected() const;

    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(highestEntryNumberProcessed::Id id, highestEntryNumberProcessed::value_type::int_type value);
    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(noneProcessed::Id id, noneProcessed::const_reference value);
    void swap(TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & other);
    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded(const TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & other)
    : Inherited(other) {} 

    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & operator = (const TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// H223Capability_h223MultiplexTableCapability_enhanced
//

class H223Capability_h223MultiplexTableCapability_enhanced : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223Capability_h223MultiplexTableCapability_enhanced(const void* info) : Inherited(info) {}
  public:
    H223Capability_h223MultiplexTableCapability_enhanced() : Inherited(&theInfo) {}
    H223Capability_h223MultiplexTableCapability_enhanced(const H223Capability_h223MultiplexTableCapability_enhanced & other) : Inherited(other)
    {}
    H223Capability_h223MultiplexTableCapability_enhanced& operator = (const H223Capability_h223MultiplexTableCapability_enhanced& other)
    { Inherited::operator = (other); return *this; } 
    class maximumNestingDepth {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumNestingDepth
    maximumNestingDepth::const_reference get_maximumNestingDepth () const;
    maximumNestingDepth::reference ref_maximumNestingDepth ();
    maximumNestingDepth::reference set_maximumNestingDepth ();
    maximumNestingDepth::reference set_maximumNestingDepth (maximumNestingDepth::value_type::int_type value);
    class maximumElementListSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 2, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumElementListSize
    maximumElementListSize::const_reference get_maximumElementListSize () const;
    maximumElementListSize::reference ref_maximumElementListSize ();
    maximumElementListSize::reference set_maximumElementListSize ();
    maximumElementListSize::reference set_maximumElementListSize (maximumElementListSize::value_type::int_type value);
    class maximumSubElementListSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 2, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumSubElementListSize
    maximumSubElementListSize::const_reference get_maximumSubElementListSize () const;
    maximumSubElementListSize::reference ref_maximumSubElementListSize ();
    maximumSubElementListSize::reference set_maximumSubElementListSize ();
    maximumSubElementListSize::reference set_maximumSubElementListSize (maximumSubElementListSize::value_type::int_type value);
    void swap(H223Capability_h223MultiplexTableCapability_enhanced& other);
    H223Capability_h223MultiplexTableCapability_enhanced * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters
//

class RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters(const void* info) : Inherited(info) {}
  public:
    RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters() : Inherited(&theInfo) {}
    RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters(const RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters & other) : Inherited(other)
    {}
    RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters& operator = (const RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters& other)
    { Inherited::operator = (other); return *this; } 
    class mpuHorizMBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 128>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mpuHorizMBs
    mpuHorizMBs::const_reference get_mpuHorizMBs () const;
    mpuHorizMBs::reference ref_mpuHorizMBs ();
    mpuHorizMBs::reference set_mpuHorizMBs ();
    mpuHorizMBs::reference set_mpuHorizMBs (mpuHorizMBs::value_type::int_type value);
    class mpuVertMBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 72>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mpuVertMBs
    mpuVertMBs::const_reference get_mpuVertMBs () const;
    mpuVertMBs::reference ref_mpuVertMBs ();
    mpuVertMBs::reference set_mpuVertMBs ();
    mpuVertMBs::reference set_mpuVertMBs (mpuVertMBs::value_type::int_type value);
    class mpuTotalNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65536>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mpuTotalNumber
    mpuTotalNumber::const_reference get_mpuTotalNumber () const;
    mpuTotalNumber::reference ref_mpuTotalNumber ();
    mpuTotalNumber::reference set_mpuTotalNumber ();
    mpuTotalNumber::reference set_mpuTotalNumber (mpuTotalNumber::value_type::int_type value);
    void swap(RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters& other);
    RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

typedef ASN1::SET_OF<ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 14> ,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 14> >  CustomPictureFormat_pixelAspectInformation_pixelAspectCode;

//
// DepFECCapability_rfc2733_separateStream
//

class DepFECCapability_rfc2733_separateStream : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECCapability_rfc2733_separateStream(const void* info) : Inherited(info) {}
  public:
    DepFECCapability_rfc2733_separateStream() : Inherited(&theInfo) {}
    DepFECCapability_rfc2733_separateStream(const DepFECCapability_rfc2733_separateStream & other) : Inherited(other)
    {}
    DepFECCapability_rfc2733_separateStream& operator = (const DepFECCapability_rfc2733_separateStream& other)
    { Inherited::operator = (other); return *this; } 
    class separatePort {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separatePort
    separatePort::const_reference get_separatePort () const;
    separatePort::reference ref_separatePort ();
    separatePort::reference set_separatePort ();
    separatePort::reference set_separatePort (bool value);
    class samePort {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samePort
    samePort::const_reference get_samePort () const;
    samePort::reference ref_samePort ();
    samePort::reference set_samePort ();
    samePort::reference set_samePort (bool value);
    void swap(DepFECCapability_rfc2733_separateStream& other);
    DepFECCapability_rfc2733_separateStream * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223LogicalChannelParameters_adaptationLayerType_al3
//

class H223LogicalChannelParameters_adaptationLayerType_al3 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223LogicalChannelParameters_adaptationLayerType_al3(const void* info) : Inherited(info) {}
  public:
    H223LogicalChannelParameters_adaptationLayerType_al3() : Inherited(&theInfo) {}
    H223LogicalChannelParameters_adaptationLayerType_al3(const H223LogicalChannelParameters_adaptationLayerType_al3 & other) : Inherited(other)
    {}
    H223LogicalChannelParameters_adaptationLayerType_al3& operator = (const H223LogicalChannelParameters_adaptationLayerType_al3& other)
    { Inherited::operator = (other); return *this; } 
    class controlFieldOctets {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 2>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class controlFieldOctets
    controlFieldOctets::const_reference get_controlFieldOctets () const;
    controlFieldOctets::reference ref_controlFieldOctets ();
    controlFieldOctets::reference set_controlFieldOctets ();
    controlFieldOctets::reference set_controlFieldOctets (controlFieldOctets::value_type::int_type value);
    class sendBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16777215>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendBufferSize
    sendBufferSize::const_reference get_sendBufferSize () const;
    sendBufferSize::reference ref_sendBufferSize ();
    sendBufferSize::reference set_sendBufferSize ();
    sendBufferSize::reference set_sendBufferSize (sendBufferSize::value_type::int_type value);
    void swap(H223LogicalChannelParameters_adaptationLayerType_al3& other);
    H223LogicalChannelParameters_adaptationLayerType_al3 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// UnicastAddress_iPSourceRouteAddress_routing
//

class UnicastAddress_iPSourceRouteAddress_routing : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UnicastAddress_iPSourceRouteAddress_routing(const void* info) : Inherited(info) {}
  public:
    UnicastAddress_iPSourceRouteAddress_routing() : Inherited(&theInfo) {}
    class strict {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class strict

    strict::reference select_strict (); 
    bool strict_isSelected() const;

    class loose {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class loose

    loose::reference select_loose (); 
    bool loose_isSelected() const;

    UnicastAddress_iPSourceRouteAddress_routing(strict::Id id, strict::const_reference value);
    UnicastAddress_iPSourceRouteAddress_routing(loose::Id id, loose::const_reference value);
    void swap(UnicastAddress_iPSourceRouteAddress_routing & other);
    UnicastAddress_iPSourceRouteAddress_routing(const UnicastAddress_iPSourceRouteAddress_routing & other)
    : Inherited(other) {} 

    UnicastAddress_iPSourceRouteAddress_routing & operator = (const UnicastAddress_iPSourceRouteAddress_routing & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    UnicastAddress_iPSourceRouteAddress_routing * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

typedef ASN1::SEQUENCE_OF<ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> > >  UnicastAddress_iPSourceRouteAddress_route;

//
// H223ModeParameters_adaptationLayerType_al3
//

class H223ModeParameters_adaptationLayerType_al3 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223ModeParameters_adaptationLayerType_al3(const void* info) : Inherited(info) {}
  public:
    H223ModeParameters_adaptationLayerType_al3() : Inherited(&theInfo) {}
    H223ModeParameters_adaptationLayerType_al3(const H223ModeParameters_adaptationLayerType_al3 & other) : Inherited(other)
    {}
    H223ModeParameters_adaptationLayerType_al3& operator = (const H223ModeParameters_adaptationLayerType_al3& other)
    { Inherited::operator = (other); return *this; } 
    class controlFieldOctets {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 2>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class controlFieldOctets
    controlFieldOctets::const_reference get_controlFieldOctets () const;
    controlFieldOctets::reference ref_controlFieldOctets ();
    controlFieldOctets::reference set_controlFieldOctets ();
    controlFieldOctets::reference set_controlFieldOctets (controlFieldOctets::value_type::int_type value);
    class sendBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16777215>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendBufferSize
    sendBufferSize::const_reference get_sendBufferSize () const;
    sendBufferSize::reference ref_sendBufferSize ();
    sendBufferSize::reference set_sendBufferSize ();
    sendBufferSize::reference set_sendBufferSize (sendBufferSize::value_type::int_type value);
    void swap(H223ModeParameters_adaptationLayerType_al3& other);
    H223ModeParameters_adaptationLayerType_al3 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultilinkRequest_maximumHeaderInterval_requestType
//

class MultilinkRequest_maximumHeaderInterval_requestType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkRequest_maximumHeaderInterval_requestType(const void* info) : Inherited(info) {}
  public:
    MultilinkRequest_maximumHeaderInterval_requestType() : Inherited(&theInfo) {}
    class currentIntervalInformation {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class currentIntervalInformation

    currentIntervalInformation::reference select_currentIntervalInformation (); 
    bool currentIntervalInformation_isSelected() const;

    class requestedInterval {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestedInterval

    requestedInterval::const_reference get_requestedInterval () const;
    requestedInterval::reference ref_requestedInterval (); 
    requestedInterval::reference select_requestedInterval (); 
    requestedInterval::reference select_requestedInterval (requestedInterval::value_type::int_type value); 
    bool requestedInterval_isSelected() const;

    MultilinkRequest_maximumHeaderInterval_requestType(currentIntervalInformation::Id id, currentIntervalInformation::const_reference value);
    MultilinkRequest_maximumHeaderInterval_requestType(requestedInterval::Id id, requestedInterval::value_type::int_type value);
    void swap(MultilinkRequest_maximumHeaderInterval_requestType & other);
    MultilinkRequest_maximumHeaderInterval_requestType(const MultilinkRequest_maximumHeaderInterval_requestType & other)
    : Inherited(other) {} 

    MultilinkRequest_maximumHeaderInterval_requestType & operator = (const MultilinkRequest_maximumHeaderInterval_requestType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultilinkRequest_maximumHeaderInterval_requestType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MiscellaneousCommand_type_videoFastUpdateGOB
//

class MiscellaneousCommand_type_videoFastUpdateGOB : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_videoFastUpdateGOB(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_videoFastUpdateGOB() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_videoFastUpdateGOB(const MiscellaneousCommand_type_videoFastUpdateGOB & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_videoFastUpdateGOB& operator = (const MiscellaneousCommand_type_videoFastUpdateGOB& other)
    { Inherited::operator = (other); return *this; } 
    class firstGOB {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 17>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class firstGOB
    firstGOB::const_reference get_firstGOB () const;
    firstGOB::reference ref_firstGOB ();
    firstGOB::reference set_firstGOB ();
    firstGOB::reference set_firstGOB (firstGOB::value_type::int_type value);
    class numberOfGOBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 18>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfGOBs
    numberOfGOBs::const_reference get_numberOfGOBs () const;
    numberOfGOBs::reference ref_numberOfGOBs ();
    numberOfGOBs::reference set_numberOfGOBs ();
    numberOfGOBs::reference set_numberOfGOBs (numberOfGOBs::value_type::int_type value);
    void swap(MiscellaneousCommand_type_videoFastUpdateGOB& other);
    MiscellaneousCommand_type_videoFastUpdateGOB * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MiscellaneousCommand_type_videoFastUpdateMB
//

class MiscellaneousCommand_type_videoFastUpdateMB : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_videoFastUpdateMB(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_videoFastUpdateMB() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_videoFastUpdateMB(const MiscellaneousCommand_type_videoFastUpdateMB & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_videoFastUpdateMB& operator = (const MiscellaneousCommand_type_videoFastUpdateMB& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_firstGOB,
      e_firstMB
    };

    class firstGOB {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class firstGOB
    firstGOB::const_reference get_firstGOB () const;
    firstGOB::reference ref_firstGOB ();
    firstGOB::reference set_firstGOB ();
    firstGOB::reference set_firstGOB (firstGOB::value_type::int_type value);
    void omit_firstGOB ();
    bool firstGOB_isPresent () const;
    class firstMB {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 8192>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class firstMB
    firstMB::const_reference get_firstMB () const;
    firstMB::reference ref_firstMB ();
    firstMB::reference set_firstMB ();
    firstMB::reference set_firstMB (firstMB::value_type::int_type value);
    void omit_firstMB ();
    bool firstMB_isPresent () const;
    class numberOfMBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 8192>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfMBs
    numberOfMBs::const_reference get_numberOfMBs () const;
    numberOfMBs::reference ref_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs (numberOfMBs::value_type::int_type value);
    void swap(MiscellaneousCommand_type_videoFastUpdateMB& other);
    MiscellaneousCommand_type_videoFastUpdateMB * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MiscellaneousCommand_type_videoBadMBs
//

class MiscellaneousCommand_type_videoBadMBs : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_videoBadMBs(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_videoBadMBs() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_videoBadMBs(const MiscellaneousCommand_type_videoBadMBs & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_videoBadMBs& operator = (const MiscellaneousCommand_type_videoBadMBs& other)
    { Inherited::operator = (other); return *this; } 
    class firstMB {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 9216>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class firstMB
    firstMB::const_reference get_firstMB () const;
    firstMB::reference ref_firstMB ();
    firstMB::reference set_firstMB ();
    firstMB::reference set_firstMB (firstMB::value_type::int_type value);
    class numberOfMBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 9216>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfMBs
    numberOfMBs::const_reference get_numberOfMBs () const;
    numberOfMBs::reference ref_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs (numberOfMBs::value_type::int_type value);
    class temporalReference {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1023>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class temporalReference
    temporalReference::const_reference get_temporalReference () const;
    temporalReference::reference ref_temporalReference ();
    temporalReference::reference set_temporalReference ();
    temporalReference::reference set_temporalReference (temporalReference::value_type::int_type value);
    void swap(MiscellaneousCommand_type_videoBadMBs& other);
    MiscellaneousCommand_type_videoBadMBs * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MiscellaneousCommand_type_lostPartialPicture
//

class MiscellaneousCommand_type_lostPartialPicture : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_lostPartialPicture(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_lostPartialPicture() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_lostPartialPicture(const MiscellaneousCommand_type_lostPartialPicture & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_lostPartialPicture& operator = (const MiscellaneousCommand_type_lostPartialPicture& other)
    { Inherited::operator = (other); return *this; } 
    class pictureReference {
      public:
        typedef PictureReference value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pictureReference
    pictureReference::const_reference get_pictureReference () const;
    pictureReference::reference ref_pictureReference ();
    pictureReference::reference set_pictureReference ();
    pictureReference::reference set_pictureReference (pictureReference::const_reference value);
    class firstMB {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 9216>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class firstMB
    firstMB::const_reference get_firstMB () const;
    firstMB::reference ref_firstMB ();
    firstMB::reference set_firstMB ();
    firstMB::reference set_firstMB (firstMB::value_type::int_type value);
    class numberOfMBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 9216>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfMBs
    numberOfMBs::const_reference get_numberOfMBs () const;
    numberOfMBs::reference ref_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs (numberOfMBs::value_type::int_type value);
    void swap(MiscellaneousCommand_type_lostPartialPicture& other);
    MiscellaneousCommand_type_lostPartialPicture * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MiscellaneousCommand_type_encryptionUpdateAck
//

class MiscellaneousCommand_type_encryptionUpdateAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_encryptionUpdateAck(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_encryptionUpdateAck() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_encryptionUpdateAck(const MiscellaneousCommand_type_encryptionUpdateAck & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_encryptionUpdateAck& operator = (const MiscellaneousCommand_type_encryptionUpdateAck& other)
    { Inherited::operator = (other); return *this; } 
    class synchFlag {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class synchFlag
    synchFlag::const_reference get_synchFlag () const;
    synchFlag::reference ref_synchFlag ();
    synchFlag::reference set_synchFlag ();
    synchFlag::reference set_synchFlag (synchFlag::value_type::int_type value);
    void swap(MiscellaneousCommand_type_encryptionUpdateAck& other);
    MiscellaneousCommand_type_encryptionUpdateAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NewATMVCCommand_aal_aal5
//

class NewATMVCCommand_aal_aal5 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_aal_aal5(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_aal_aal5() : Inherited(&theInfo) {}
    NewATMVCCommand_aal_aal5(const NewATMVCCommand_aal_aal5 & other) : Inherited(other)
    {}
    NewATMVCCommand_aal_aal5& operator = (const NewATMVCCommand_aal_aal5& other)
    { Inherited::operator = (other); return *this; } 
    class forwardMaximumSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardMaximumSDUSize
    forwardMaximumSDUSize::const_reference get_forwardMaximumSDUSize () const;
    forwardMaximumSDUSize::reference ref_forwardMaximumSDUSize ();
    forwardMaximumSDUSize::reference set_forwardMaximumSDUSize ();
    forwardMaximumSDUSize::reference set_forwardMaximumSDUSize (forwardMaximumSDUSize::value_type::int_type value);
    class backwardMaximumSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class backwardMaximumSDUSize
    backwardMaximumSDUSize::const_reference get_backwardMaximumSDUSize () const;
    backwardMaximumSDUSize::reference ref_backwardMaximumSDUSize ();
    backwardMaximumSDUSize::reference set_backwardMaximumSDUSize ();
    backwardMaximumSDUSize::reference set_backwardMaximumSDUSize (backwardMaximumSDUSize::value_type::int_type value);
    void swap(NewATMVCCommand_aal_aal5& other);
    NewATMVCCommand_aal_aal5 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// NewATMVCCommand_reverseParameters_multiplex
//

class NewATMVCCommand_reverseParameters_multiplex : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_reverseParameters_multiplex(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_reverseParameters_multiplex() : Inherited(&theInfo) {}
    class noMultiplex {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noMultiplex

    noMultiplex::reference select_noMultiplex (); 
    bool noMultiplex_isSelected() const;

    class transportStream {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportStream

    transportStream::reference select_transportStream (); 
    bool transportStream_isSelected() const;

    class programStream {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class programStream

    programStream::reference select_programStream (); 
    bool programStream_isSelected() const;

    NewATMVCCommand_reverseParameters_multiplex(noMultiplex::Id id, noMultiplex::const_reference value);
    NewATMVCCommand_reverseParameters_multiplex(transportStream::Id id, transportStream::const_reference value);
    NewATMVCCommand_reverseParameters_multiplex(programStream::Id id, programStream::const_reference value);
    void swap(NewATMVCCommand_reverseParameters_multiplex & other);
    NewATMVCCommand_reverseParameters_multiplex(const NewATMVCCommand_reverseParameters_multiplex & other)
    : Inherited(other) {} 

    NewATMVCCommand_reverseParameters_multiplex & operator = (const NewATMVCCommand_reverseParameters_multiplex & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCCommand_reverseParameters_multiplex * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MiscellaneousIndication_type_videoNotDecodedMBs
//

class MiscellaneousIndication_type_videoNotDecodedMBs : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousIndication_type_videoNotDecodedMBs(const void* info) : Inherited(info) {}
  public:
    MiscellaneousIndication_type_videoNotDecodedMBs() : Inherited(&theInfo) {}
    MiscellaneousIndication_type_videoNotDecodedMBs(const MiscellaneousIndication_type_videoNotDecodedMBs & other) : Inherited(other)
    {}
    MiscellaneousIndication_type_videoNotDecodedMBs& operator = (const MiscellaneousIndication_type_videoNotDecodedMBs& other)
    { Inherited::operator = (other); return *this; } 
    class firstMB {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 8192>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class firstMB
    firstMB::const_reference get_firstMB () const;
    firstMB::reference ref_firstMB ();
    firstMB::reference set_firstMB ();
    firstMB::reference set_firstMB (firstMB::value_type::int_type value);
    class numberOfMBs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 8192>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfMBs
    numberOfMBs::const_reference get_numberOfMBs () const;
    numberOfMBs::reference ref_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs ();
    numberOfMBs::reference set_numberOfMBs (numberOfMBs::value_type::int_type value);
    class temporalReference {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class temporalReference
    temporalReference::const_reference get_temporalReference () const;
    temporalReference::reference ref_temporalReference ();
    temporalReference::reference set_temporalReference ();
    temporalReference::reference set_temporalReference (temporalReference::value_type::int_type value);
    void swap(MiscellaneousIndication_type_videoNotDecodedMBs& other);
    MiscellaneousIndication_type_videoNotDecodedMBs * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// NewATMVCIndication_aal_aal5
//

class NewATMVCIndication_aal_aal5 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_aal_aal5(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_aal_aal5() : Inherited(&theInfo) {}
    NewATMVCIndication_aal_aal5(const NewATMVCIndication_aal_aal5 & other) : Inherited(other)
    {}
    NewATMVCIndication_aal_aal5& operator = (const NewATMVCIndication_aal_aal5& other)
    { Inherited::operator = (other); return *this; } 
    class forwardMaximumSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardMaximumSDUSize
    forwardMaximumSDUSize::const_reference get_forwardMaximumSDUSize () const;
    forwardMaximumSDUSize::reference ref_forwardMaximumSDUSize ();
    forwardMaximumSDUSize::reference set_forwardMaximumSDUSize ();
    forwardMaximumSDUSize::reference set_forwardMaximumSDUSize (forwardMaximumSDUSize::value_type::int_type value);
    class backwardMaximumSDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class backwardMaximumSDUSize
    backwardMaximumSDUSize::const_reference get_backwardMaximumSDUSize () const;
    backwardMaximumSDUSize::reference ref_backwardMaximumSDUSize ();
    backwardMaximumSDUSize::reference set_backwardMaximumSDUSize ();
    backwardMaximumSDUSize::reference set_backwardMaximumSDUSize (backwardMaximumSDUSize::value_type::int_type value);
    void swap(NewATMVCIndication_aal_aal5& other);
    NewATMVCIndication_aal_aal5 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// NewATMVCIndication_reverseParameters_multiplex
//

class NewATMVCIndication_reverseParameters_multiplex : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_reverseParameters_multiplex(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_reverseParameters_multiplex() : Inherited(&theInfo) {}
    class noMultiplex {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noMultiplex

    noMultiplex::reference select_noMultiplex (); 
    bool noMultiplex_isSelected() const;

    class transportStream {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportStream

    transportStream::reference select_transportStream (); 
    bool transportStream_isSelected() const;

    class programStream {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class programStream

    programStream::reference select_programStream (); 
    bool programStream_isSelected() const;

    NewATMVCIndication_reverseParameters_multiplex(noMultiplex::Id id, noMultiplex::const_reference value);
    NewATMVCIndication_reverseParameters_multiplex(transportStream::Id id, transportStream::const_reference value);
    NewATMVCIndication_reverseParameters_multiplex(programStream::Id id, programStream::const_reference value);
    void swap(NewATMVCIndication_reverseParameters_multiplex & other);
    NewATMVCIndication_reverseParameters_multiplex(const NewATMVCIndication_reverseParameters_multiplex & other)
    : Inherited(other) {} 

    NewATMVCIndication_reverseParameters_multiplex & operator = (const NewATMVCIndication_reverseParameters_multiplex & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCIndication_reverseParameters_multiplex * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// UserInputIndication_signal_rtp
//

class UserInputIndication_signal_rtp : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_signal_rtp(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_signal_rtp() : Inherited(&theInfo) {}
    UserInputIndication_signal_rtp(const UserInputIndication_signal_rtp & other) : Inherited(other)
    {}
    UserInputIndication_signal_rtp& operator = (const UserInputIndication_signal_rtp& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_timestamp,
      e_expirationTime
    };

    class timestamp {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class timestamp
    timestamp::const_reference get_timestamp () const;
    timestamp::reference ref_timestamp ();
    timestamp::reference set_timestamp ();
    timestamp::reference set_timestamp (timestamp::value_type::int_type value);
    void omit_timestamp ();
    bool timestamp_isPresent () const;
    class expirationTime {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class expirationTime
    expirationTime::const_reference get_expirationTime () const;
    expirationTime::reference ref_expirationTime ();
    expirationTime::reference set_expirationTime ();
    expirationTime::reference set_expirationTime (expirationTime::value_type::int_type value);
    void omit_expirationTime ();
    bool expirationTime_isPresent () const;
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    void swap(UserInputIndication_signal_rtp& other);
    UserInputIndication_signal_rtp * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// UserInputIndication_signalUpdate_rtp
//

class UserInputIndication_signalUpdate_rtp : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_signalUpdate_rtp(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_signalUpdate_rtp() : Inherited(&theInfo) {}
    UserInputIndication_signalUpdate_rtp(const UserInputIndication_signalUpdate_rtp & other) : Inherited(other)
    {}
    UserInputIndication_signalUpdate_rtp& operator = (const UserInputIndication_signalUpdate_rtp& other)
    { Inherited::operator = (other); return *this; } 
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    void swap(UserInputIndication_signalUpdate_rtp& other);
    UserInputIndication_signalUpdate_rtp * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric
//

class UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric() : Inherited(&theInfo) {}
    UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric(const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric & other) : Inherited(other)
    {}
    UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric& operator = (const UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_paramS
    };

    class algorithmOID {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class algorithmOID
    algorithmOID::const_reference get_algorithmOID () const;
    algorithmOID::reference ref_algorithmOID ();
    algorithmOID::reference set_algorithmOID ();
    algorithmOID::reference set_algorithmOID (algorithmOID::const_reference value);
    class paramS {
      public:
        typedef Params value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class paramS
    paramS::const_reference get_paramS () const;
    paramS::reference ref_paramS ();
    paramS::reference set_paramS ();
    paramS::reference set_paramS (paramS::const_reference value);
    void omit_paramS ();
    bool paramS_isPresent () const;
    class encrypted {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encrypted
    encrypted::const_reference get_encrypted () const;
    encrypted::reference ref_encrypted ();
    encrypted::reference set_encrypted ();
    encrypted::reference set_encrypted (const std::vector<char>& value);
    void swap(UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric& other);
    UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// VCCapability_availableBitRates_type_rangeOfBitRates
//

class VCCapability_availableBitRates_type_rangeOfBitRates : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability_availableBitRates_type_rangeOfBitRates(const void* info) : Inherited(info) {}
  public:
    VCCapability_availableBitRates_type_rangeOfBitRates() : Inherited(&theInfo) {}
    VCCapability_availableBitRates_type_rangeOfBitRates(const VCCapability_availableBitRates_type_rangeOfBitRates & other) : Inherited(other)
    {}
    VCCapability_availableBitRates_type_rangeOfBitRates& operator = (const VCCapability_availableBitRates_type_rangeOfBitRates& other)
    { Inherited::operator = (other); return *this; } 
    class lowerBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowerBitRate
    lowerBitRate::const_reference get_lowerBitRate () const;
    lowerBitRate::reference ref_lowerBitRate ();
    lowerBitRate::reference set_lowerBitRate ();
    lowerBitRate::reference set_lowerBitRate (lowerBitRate::value_type::int_type value);
    class higherBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class higherBitRate
    higherBitRate::const_reference get_higherBitRate () const;
    higherBitRate::reference ref_higherBitRate ();
    higherBitRate::reference set_higherBitRate ();
    higherBitRate::reference set_higherBitRate (higherBitRate::value_type::int_type value);
    void swap(VCCapability_availableBitRates_type_rangeOfBitRates& other);
    VCCapability_availableBitRates_type_rangeOfBitRates * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// CustomPictureFormat_mPI_customPCF_subtype
//

class CustomPictureFormat_mPI_customPCF_subtype : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CustomPictureFormat_mPI_customPCF_subtype(const void* info) : Inherited(info) {}
  public:
    CustomPictureFormat_mPI_customPCF_subtype() : Inherited(&theInfo) {}
    CustomPictureFormat_mPI_customPCF_subtype(const CustomPictureFormat_mPI_customPCF_subtype & other) : Inherited(other)
    {}
    CustomPictureFormat_mPI_customPCF_subtype& operator = (const CustomPictureFormat_mPI_customPCF_subtype& other)
    { Inherited::operator = (other); return *this; } 
    class clockConversionCode {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1000, 1001>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class clockConversionCode
    clockConversionCode::const_reference get_clockConversionCode () const;
    clockConversionCode::reference ref_clockConversionCode ();
    clockConversionCode::reference set_clockConversionCode ();
    clockConversionCode::reference set_clockConversionCode (clockConversionCode::value_type::int_type value);
    class clockDivisor {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class clockDivisor
    clockDivisor::const_reference get_clockDivisor () const;
    clockDivisor::reference ref_clockDivisor ();
    clockDivisor::reference set_clockDivisor ();
    clockDivisor::reference set_clockDivisor (clockDivisor::value_type::int_type value);
    class customMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class customMPI
    customMPI::const_reference get_customMPI () const;
    customMPI::reference ref_customMPI ();
    customMPI::reference set_customMPI ();
    customMPI::reference set_customMPI (customMPI::value_type::int_type value);
    void swap(CustomPictureFormat_mPI_customPCF_subtype& other);
    CustomPictureFormat_mPI_customPCF_subtype * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype
//

class CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype(const void* info) : Inherited(info) {}
  public:
    CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype() : Inherited(&theInfo) {}
    CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype(const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype & other) : Inherited(other)
    {}
    CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype& operator = (const CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype& other)
    { Inherited::operator = (other); return *this; } 
    class width {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class width
    width::const_reference get_width () const;
    width::reference ref_width ();
    width::reference set_width ();
    width::reference set_width (width::value_type::int_type value);
    class height {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class height
    height::const_reference get_height () const;
    height::reference ref_height ();
    height::reference set_height ();
    height::reference set_height (height::value_type::int_type value);
    void swap(CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype& other);
    CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// V76LogicalChannelParameters_mode_eRM_recovery
//

class V76LogicalChannelParameters_mode_eRM_recovery : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76LogicalChannelParameters_mode_eRM_recovery(const void* info) : Inherited(info) {}
  public:
    V76LogicalChannelParameters_mode_eRM_recovery() : Inherited(&theInfo) {}
    class rej {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rej

    rej::reference select_rej (); 
    bool rej_isSelected() const;

    class sREJ {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sREJ

    sREJ::reference select_sREJ (); 
    bool sREJ_isSelected() const;

    class mSREJ {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mSREJ

    mSREJ::reference select_mSREJ (); 
    bool mSREJ_isSelected() const;

    V76LogicalChannelParameters_mode_eRM_recovery(rej::Id id, rej::const_reference value);
    V76LogicalChannelParameters_mode_eRM_recovery(sREJ::Id id, sREJ::const_reference value);
    V76LogicalChannelParameters_mode_eRM_recovery(mSREJ::Id id, mSREJ::const_reference value);
    void swap(V76LogicalChannelParameters_mode_eRM_recovery & other);
    V76LogicalChannelParameters_mode_eRM_recovery(const V76LogicalChannelParameters_mode_eRM_recovery & other)
    : Inherited(other) {} 

    V76LogicalChannelParameters_mode_eRM_recovery & operator = (const V76LogicalChannelParameters_mode_eRM_recovery & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    V76LogicalChannelParameters_mode_eRM_recovery * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// FECData_rfc2733_pktMode_rfc2733sameport
//

class FECData_rfc2733_pktMode_rfc2733sameport : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECData_rfc2733_pktMode_rfc2733sameport(const void* info) : Inherited(info) {}
  public:
    FECData_rfc2733_pktMode_rfc2733sameport() : Inherited(&theInfo) {}
    FECData_rfc2733_pktMode_rfc2733sameport(const FECData_rfc2733_pktMode_rfc2733sameport & other) : Inherited(other)
    {}
    FECData_rfc2733_pktMode_rfc2733sameport& operator = (const FECData_rfc2733_pktMode_rfc2733sameport& other)
    { Inherited::operator = (other); return *this; } 
    void swap(FECData_rfc2733_pktMode_rfc2733sameport& other);
    FECData_rfc2733_pktMode_rfc2733sameport * clone() const;
    static const InfoType theInfo;
  private:
};

//
// FECData_rfc2733_pktMode_rfc2733diffport
//

class FECData_rfc2733_pktMode_rfc2733diffport : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECData_rfc2733_pktMode_rfc2733diffport(const void* info) : Inherited(info) {}
  public:
    FECData_rfc2733_pktMode_rfc2733diffport() : Inherited(&theInfo) {}
    FECData_rfc2733_pktMode_rfc2733diffport(const FECData_rfc2733_pktMode_rfc2733diffport & other) : Inherited(other)
    {}
    FECData_rfc2733_pktMode_rfc2733diffport& operator = (const FECData_rfc2733_pktMode_rfc2733diffport& other)
    { Inherited::operator = (other); return *this; } 
    class protectedChannel {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedChannel
    protectedChannel::const_reference get_protectedChannel () const;
    protectedChannel::reference ref_protectedChannel ();
    protectedChannel::reference set_protectedChannel ();
    protectedChannel::reference set_protectedChannel (protectedChannel::value_type::int_type value);
    void swap(FECData_rfc2733_pktMode_rfc2733diffport& other);
    FECData_rfc2733_pktMode_rfc2733diffport * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultilinkResponse_addConnection_responseCode_rejected
//

class MultilinkResponse_addConnection_responseCode_rejected : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse_addConnection_responseCode_rejected(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse_addConnection_responseCode_rejected() : Inherited(&theInfo) {}
    class connectionsNotAvailable {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class connectionsNotAvailable

    connectionsNotAvailable::reference select_connectionsNotAvailable (); 
    bool connectionsNotAvailable_isSelected() const;

    class userRejected {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class userRejected

    userRejected::reference select_userRejected (); 
    bool userRejected_isSelected() const;

    MultilinkResponse_addConnection_responseCode_rejected(connectionsNotAvailable::Id id, connectionsNotAvailable::const_reference value);
    MultilinkResponse_addConnection_responseCode_rejected(userRejected::Id id, userRejected::const_reference value);
    void swap(MultilinkResponse_addConnection_responseCode_rejected & other);
    MultilinkResponse_addConnection_responseCode_rejected(const MultilinkResponse_addConnection_responseCode_rejected & other)
    : Inherited(other) {} 

    MultilinkResponse_addConnection_responseCode_rejected & operator = (const MultilinkResponse_addConnection_responseCode_rejected & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultilinkResponse_addConnection_responseCode_rejected * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MiscellaneousCommand_type_progressiveRefinementStart_repeatCount
//

class MiscellaneousCommand_type_progressiveRefinementStart_repeatCount : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount() : Inherited(&theInfo) {}
    class doOneProgression {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class doOneProgression

    doOneProgression::reference select_doOneProgression (); 
    bool doOneProgression_isSelected() const;

    class doContinuousProgressions {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class doContinuousProgressions

    doContinuousProgressions::reference select_doContinuousProgressions (); 
    bool doContinuousProgressions_isSelected() const;

    class doOneIndependentProgression {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class doOneIndependentProgression

    doOneIndependentProgression::reference select_doOneIndependentProgression (); 
    bool doOneIndependentProgression_isSelected() const;

    class doContinuousIndependentProgressions {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class doContinuousIndependentProgressions

    doContinuousIndependentProgressions::reference select_doContinuousIndependentProgressions (); 
    bool doContinuousIndependentProgressions_isSelected() const;

    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(doOneProgression::Id id, doOneProgression::const_reference value);
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(doContinuousProgressions::Id id, doContinuousProgressions::const_reference value);
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(doOneIndependentProgression::Id id, doOneIndependentProgression::const_reference value);
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(doContinuousIndependentProgressions::Id id, doContinuousIndependentProgressions::const_reference value);
    void swap(MiscellaneousCommand_type_progressiveRefinementStart_repeatCount & other);
    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount(const MiscellaneousCommand_type_progressiveRefinementStart_repeatCount & other)
    : Inherited(other) {} 

    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount & operator = (const MiscellaneousCommand_type_progressiveRefinementStart_repeatCount & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MiscellaneousCommand_type_progressiveRefinementStart_repeatCount * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// NewATMVCCommand_aal_aal1_clockRecovery
//

class NewATMVCCommand_aal_aal1_clockRecovery : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_aal_aal1_clockRecovery(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_aal_aal1_clockRecovery() : Inherited(&theInfo) {}
    class nullClockRecovery {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullClockRecovery

    nullClockRecovery::reference select_nullClockRecovery (); 
    bool nullClockRecovery_isSelected() const;

    class srtsClockRecovery {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class srtsClockRecovery

    srtsClockRecovery::reference select_srtsClockRecovery (); 
    bool srtsClockRecovery_isSelected() const;

    class adaptiveClockRecovery {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class adaptiveClockRecovery

    adaptiveClockRecovery::reference select_adaptiveClockRecovery (); 
    bool adaptiveClockRecovery_isSelected() const;

    NewATMVCCommand_aal_aal1_clockRecovery(nullClockRecovery::Id id, nullClockRecovery::const_reference value);
    NewATMVCCommand_aal_aal1_clockRecovery(srtsClockRecovery::Id id, srtsClockRecovery::const_reference value);
    NewATMVCCommand_aal_aal1_clockRecovery(adaptiveClockRecovery::Id id, adaptiveClockRecovery::const_reference value);
    void swap(NewATMVCCommand_aal_aal1_clockRecovery & other);
    NewATMVCCommand_aal_aal1_clockRecovery(const NewATMVCCommand_aal_aal1_clockRecovery & other)
    : Inherited(other) {} 

    NewATMVCCommand_aal_aal1_clockRecovery & operator = (const NewATMVCCommand_aal_aal1_clockRecovery & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCCommand_aal_aal1_clockRecovery * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// NewATMVCCommand_aal_aal1_errorCorrection
//

class NewATMVCCommand_aal_aal1_errorCorrection : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_aal_aal1_errorCorrection(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_aal_aal1_errorCorrection() : Inherited(&theInfo) {}
    class nullErrorCorrection {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullErrorCorrection

    nullErrorCorrection::reference select_nullErrorCorrection (); 
    bool nullErrorCorrection_isSelected() const;

    class longInterleaver {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class longInterleaver

    longInterleaver::reference select_longInterleaver (); 
    bool longInterleaver_isSelected() const;

    class shortInterleaver {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class shortInterleaver

    shortInterleaver::reference select_shortInterleaver (); 
    bool shortInterleaver_isSelected() const;

    class errorCorrectionOnly {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCorrectionOnly

    errorCorrectionOnly::reference select_errorCorrectionOnly (); 
    bool errorCorrectionOnly_isSelected() const;

    NewATMVCCommand_aal_aal1_errorCorrection(nullErrorCorrection::Id id, nullErrorCorrection::const_reference value);
    NewATMVCCommand_aal_aal1_errorCorrection(longInterleaver::Id id, longInterleaver::const_reference value);
    NewATMVCCommand_aal_aal1_errorCorrection(shortInterleaver::Id id, shortInterleaver::const_reference value);
    NewATMVCCommand_aal_aal1_errorCorrection(errorCorrectionOnly::Id id, errorCorrectionOnly::const_reference value);
    void swap(NewATMVCCommand_aal_aal1_errorCorrection & other);
    NewATMVCCommand_aal_aal1_errorCorrection(const NewATMVCCommand_aal_aal1_errorCorrection & other)
    : Inherited(other) {} 

    NewATMVCCommand_aal_aal1_errorCorrection & operator = (const NewATMVCCommand_aal_aal1_errorCorrection & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCCommand_aal_aal1_errorCorrection * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// NewATMVCIndication_aal_aal1_clockRecovery
//

class NewATMVCIndication_aal_aal1_clockRecovery : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_aal_aal1_clockRecovery(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_aal_aal1_clockRecovery() : Inherited(&theInfo) {}
    class nullClockRecovery {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullClockRecovery

    nullClockRecovery::reference select_nullClockRecovery (); 
    bool nullClockRecovery_isSelected() const;

    class srtsClockRecovery {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class srtsClockRecovery

    srtsClockRecovery::reference select_srtsClockRecovery (); 
    bool srtsClockRecovery_isSelected() const;

    class adaptiveClockRecovery {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class adaptiveClockRecovery

    adaptiveClockRecovery::reference select_adaptiveClockRecovery (); 
    bool adaptiveClockRecovery_isSelected() const;

    NewATMVCIndication_aal_aal1_clockRecovery(nullClockRecovery::Id id, nullClockRecovery::const_reference value);
    NewATMVCIndication_aal_aal1_clockRecovery(srtsClockRecovery::Id id, srtsClockRecovery::const_reference value);
    NewATMVCIndication_aal_aal1_clockRecovery(adaptiveClockRecovery::Id id, adaptiveClockRecovery::const_reference value);
    void swap(NewATMVCIndication_aal_aal1_clockRecovery & other);
    NewATMVCIndication_aal_aal1_clockRecovery(const NewATMVCIndication_aal_aal1_clockRecovery & other)
    : Inherited(other) {} 

    NewATMVCIndication_aal_aal1_clockRecovery & operator = (const NewATMVCIndication_aal_aal1_clockRecovery & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCIndication_aal_aal1_clockRecovery * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// NewATMVCIndication_aal_aal1_errorCorrection
//

class NewATMVCIndication_aal_aal1_errorCorrection : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_aal_aal1_errorCorrection(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_aal_aal1_errorCorrection() : Inherited(&theInfo) {}
    class nullErrorCorrection {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullErrorCorrection

    nullErrorCorrection::reference select_nullErrorCorrection (); 
    bool nullErrorCorrection_isSelected() const;

    class longInterleaver {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class longInterleaver

    longInterleaver::reference select_longInterleaver (); 
    bool longInterleaver_isSelected() const;

    class shortInterleaver {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class shortInterleaver

    shortInterleaver::reference select_shortInterleaver (); 
    bool shortInterleaver_isSelected() const;

    class errorCorrectionOnly {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCorrectionOnly

    errorCorrectionOnly::reference select_errorCorrectionOnly (); 
    bool errorCorrectionOnly_isSelected() const;

    NewATMVCIndication_aal_aal1_errorCorrection(nullErrorCorrection::Id id, nullErrorCorrection::const_reference value);
    NewATMVCIndication_aal_aal1_errorCorrection(longInterleaver::Id id, longInterleaver::const_reference value);
    NewATMVCIndication_aal_aal1_errorCorrection(shortInterleaver::Id id, shortInterleaver::const_reference value);
    NewATMVCIndication_aal_aal1_errorCorrection(errorCorrectionOnly::Id id, errorCorrectionOnly::const_reference value);
    void swap(NewATMVCIndication_aal_aal1_errorCorrection & other);
    NewATMVCIndication_aal_aal1_errorCorrection(const NewATMVCIndication_aal_aal1_errorCorrection & other)
    : Inherited(other) {} 

    NewATMVCIndication_aal_aal1_errorCorrection & operator = (const NewATMVCIndication_aal_aal1_errorCorrection & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCIndication_aal_aal1_errorCorrection * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// DepFECData_rfc2733_mode_separateStream_differentPort
//

class DepFECData_rfc2733_mode_separateStream_differentPort : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECData_rfc2733_mode_separateStream_differentPort(const void* info) : Inherited(info) {}
  public:
    DepFECData_rfc2733_mode_separateStream_differentPort() : Inherited(&theInfo) {}
    DepFECData_rfc2733_mode_separateStream_differentPort(const DepFECData_rfc2733_mode_separateStream_differentPort & other) : Inherited(other)
    {}
    DepFECData_rfc2733_mode_separateStream_differentPort& operator = (const DepFECData_rfc2733_mode_separateStream_differentPort& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_protectedPayloadType
    };

    class protectedSessionID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedSessionID
    protectedSessionID::const_reference get_protectedSessionID () const;
    protectedSessionID::reference ref_protectedSessionID ();
    protectedSessionID::reference set_protectedSessionID ();
    protectedSessionID::reference set_protectedSessionID (protectedSessionID::value_type::int_type value);
    class protectedPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedPayloadType
    protectedPayloadType::const_reference get_protectedPayloadType () const;
    protectedPayloadType::reference ref_protectedPayloadType ();
    protectedPayloadType::reference set_protectedPayloadType ();
    protectedPayloadType::reference set_protectedPayloadType (protectedPayloadType::value_type::int_type value);
    void omit_protectedPayloadType ();
    bool protectedPayloadType_isPresent () const;
    void swap(DepFECData_rfc2733_mode_separateStream_differentPort& other);
    DepFECData_rfc2733_mode_separateStream_differentPort * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DepFECData_rfc2733_mode_separateStream_samePort
//

class DepFECData_rfc2733_mode_separateStream_samePort : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECData_rfc2733_mode_separateStream_samePort(const void* info) : Inherited(info) {}
  public:
    DepFECData_rfc2733_mode_separateStream_samePort() : Inherited(&theInfo) {}
    DepFECData_rfc2733_mode_separateStream_samePort(const DepFECData_rfc2733_mode_separateStream_samePort & other) : Inherited(other)
    {}
    DepFECData_rfc2733_mode_separateStream_samePort& operator = (const DepFECData_rfc2733_mode_separateStream_samePort& other)
    { Inherited::operator = (other); return *this; } 
    class protectedPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedPayloadType
    protectedPayloadType::const_reference get_protectedPayloadType () const;
    protectedPayloadType::reference ref_protectedPayloadType ();
    protectedPayloadType::reference set_protectedPayloadType ();
    protectedPayloadType::reference set_protectedPayloadType (protectedPayloadType::value_type::int_type value);
    void swap(DepFECData_rfc2733_mode_separateStream_samePort& other);
    DepFECData_rfc2733_mode_separateStream_samePort * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NonStandardIdentifier
//

class NonStandardIdentifier : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NonStandardIdentifier(const void* info) : Inherited(info) {}
  public:
    NonStandardIdentifier() : Inherited(&theInfo) {}
    class object {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class object

    object::const_reference get_object () const;
    object::reference ref_object (); 
    object::reference select_object (); 
    object::reference select_object (object::const_reference value); 
    bool object_isSelected() const;

    class h221NonStandard {
      public:
        enum Id { id_ = 1 };
        typedef NonStandardIdentifier_h221NonStandard value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h221NonStandard

    h221NonStandard::const_reference get_h221NonStandard () const;
    h221NonStandard::reference ref_h221NonStandard (); 
    h221NonStandard::reference select_h221NonStandard (); 
    h221NonStandard::reference select_h221NonStandard (h221NonStandard::const_reference value); 
    bool h221NonStandard_isSelected() const;

    NonStandardIdentifier(object::Id id, object::const_reference value);
    NonStandardIdentifier(h221NonStandard::Id id, h221NonStandard::const_reference value);
    void swap(NonStandardIdentifier & other);
    NonStandardIdentifier(const NonStandardIdentifier & other)
    : Inherited(other) {} 

    NonStandardIdentifier & operator = (const NonStandardIdentifier & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NonStandardIdentifier * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MasterSlaveDeterminationAck
//

class MasterSlaveDeterminationAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MasterSlaveDeterminationAck(const void* info) : Inherited(info) {}
  public:
    MasterSlaveDeterminationAck() : Inherited(&theInfo) {}
    MasterSlaveDeterminationAck(const MasterSlaveDeterminationAck & other) : Inherited(other)
    {}
    MasterSlaveDeterminationAck& operator = (const MasterSlaveDeterminationAck& other)
    { Inherited::operator = (other); return *this; } 
    class decision {
      public:
        typedef MasterSlaveDeterminationAck_decision value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class decision
    decision::const_reference get_decision () const;
    decision::reference ref_decision ();
    decision::reference set_decision ();
    decision::reference set_decision (decision::const_reference value);
    void swap(MasterSlaveDeterminationAck& other);
    MasterSlaveDeterminationAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MasterSlaveDeterminationReject
//

class MasterSlaveDeterminationReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MasterSlaveDeterminationReject(const void* info) : Inherited(info) {}
  public:
    MasterSlaveDeterminationReject() : Inherited(&theInfo) {}
    MasterSlaveDeterminationReject(const MasterSlaveDeterminationReject & other) : Inherited(other)
    {}
    MasterSlaveDeterminationReject& operator = (const MasterSlaveDeterminationReject& other)
    { Inherited::operator = (other); return *this; } 
    class cause {
      public:
        typedef MasterSlaveDeterminationReject_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    void swap(MasterSlaveDeterminationReject& other);
    MasterSlaveDeterminationReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

typedef ASN1::SEQUENCE_OF<CapabilityTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  AlternativeCapabilitySet;

//
// V76Capability
//

class V76Capability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76Capability(const void* info) : Inherited(info) {}
  public:
    V76Capability() : Inherited(&theInfo) {}
    V76Capability(const V76Capability & other) : Inherited(other)
    {}
    V76Capability& operator = (const V76Capability& other)
    { Inherited::operator = (other); return *this; } 
    class suspendResumeCapabilitywAddress {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResumeCapabilitywAddress
    suspendResumeCapabilitywAddress::const_reference get_suspendResumeCapabilitywAddress () const;
    suspendResumeCapabilitywAddress::reference ref_suspendResumeCapabilitywAddress ();
    suspendResumeCapabilitywAddress::reference set_suspendResumeCapabilitywAddress ();
    suspendResumeCapabilitywAddress::reference set_suspendResumeCapabilitywAddress (bool value);
    class suspendResumeCapabilitywoAddress {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResumeCapabilitywoAddress
    suspendResumeCapabilitywoAddress::const_reference get_suspendResumeCapabilitywoAddress () const;
    suspendResumeCapabilitywoAddress::reference ref_suspendResumeCapabilitywoAddress ();
    suspendResumeCapabilitywoAddress::reference set_suspendResumeCapabilitywoAddress ();
    suspendResumeCapabilitywoAddress::reference set_suspendResumeCapabilitywoAddress (bool value);
    class rejCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rejCapability
    rejCapability::const_reference get_rejCapability () const;
    rejCapability::reference ref_rejCapability ();
    rejCapability::reference set_rejCapability ();
    rejCapability::reference set_rejCapability (bool value);
    class sREJCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sREJCapability
    sREJCapability::const_reference get_sREJCapability () const;
    sREJCapability::reference ref_sREJCapability ();
    sREJCapability::reference set_sREJCapability ();
    sREJCapability::reference set_sREJCapability (bool value);
    class mREJCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mREJCapability
    mREJCapability::const_reference get_mREJCapability () const;
    mREJCapability::reference ref_mREJCapability ();
    mREJCapability::reference set_mREJCapability ();
    mREJCapability::reference set_mREJCapability (bool value);
    class crc8bitCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc8bitCapability
    crc8bitCapability::const_reference get_crc8bitCapability () const;
    crc8bitCapability::reference ref_crc8bitCapability ();
    crc8bitCapability::reference set_crc8bitCapability ();
    crc8bitCapability::reference set_crc8bitCapability (bool value);
    class crc16bitCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc16bitCapability
    crc16bitCapability::const_reference get_crc16bitCapability () const;
    crc16bitCapability::reference ref_crc16bitCapability ();
    crc16bitCapability::reference set_crc16bitCapability ();
    crc16bitCapability::reference set_crc16bitCapability (bool value);
    class crc32bitCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crc32bitCapability
    crc32bitCapability::const_reference get_crc32bitCapability () const;
    crc32bitCapability::reference ref_crc32bitCapability ();
    crc32bitCapability::reference set_crc32bitCapability ();
    crc32bitCapability::reference set_crc32bitCapability (bool value);
    class uihCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class uihCapability
    uihCapability::const_reference get_uihCapability () const;
    uihCapability::reference ref_uihCapability ();
    uihCapability::reference set_uihCapability ();
    uihCapability::reference set_uihCapability (bool value);
    class numOfDLCS {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 2, 8191>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numOfDLCS
    numOfDLCS::const_reference get_numOfDLCS () const;
    numOfDLCS::reference ref_numOfDLCS ();
    numOfDLCS::reference set_numOfDLCS ();
    numOfDLCS::reference set_numOfDLCS (numOfDLCS::value_type::int_type value);
    class twoOctetAddressFieldCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class twoOctetAddressFieldCapability
    twoOctetAddressFieldCapability::const_reference get_twoOctetAddressFieldCapability () const;
    twoOctetAddressFieldCapability::reference ref_twoOctetAddressFieldCapability ();
    twoOctetAddressFieldCapability::reference set_twoOctetAddressFieldCapability ();
    twoOctetAddressFieldCapability::reference set_twoOctetAddressFieldCapability (bool value);
    class loopBackTestCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class loopBackTestCapability
    loopBackTestCapability::const_reference get_loopBackTestCapability () const;
    loopBackTestCapability::reference ref_loopBackTestCapability ();
    loopBackTestCapability::reference set_loopBackTestCapability ();
    loopBackTestCapability::reference set_loopBackTestCapability (bool value);
    class n401Capability {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4095>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class n401Capability
    n401Capability::const_reference get_n401Capability () const;
    n401Capability::reference ref_n401Capability ();
    n401Capability::reference set_n401Capability ();
    n401Capability::reference set_n401Capability (n401Capability::value_type::int_type value);
    class maxWindowSizeCapability {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxWindowSizeCapability
    maxWindowSizeCapability::const_reference get_maxWindowSizeCapability () const;
    maxWindowSizeCapability::reference ref_maxWindowSizeCapability ();
    maxWindowSizeCapability::reference set_maxWindowSizeCapability ();
    maxWindowSizeCapability::reference set_maxWindowSizeCapability (maxWindowSizeCapability::value_type::int_type value);
    class v75Capability {
      public:
        typedef V75Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v75Capability
    v75Capability::const_reference get_v75Capability () const;
    v75Capability::reference ref_v75Capability ();
    v75Capability::reference set_v75Capability ();
    v75Capability::reference set_v75Capability (v75Capability::const_reference value);
    void swap(V76Capability& other);
    V76Capability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[15];
    static int fieldIds[15];
    static const char* fieldNames[15];
};

//
// RSVPParameters
//

class RSVPParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RSVPParameters(const void* info) : Inherited(info) {}
  public:
    RSVPParameters() : Inherited(&theInfo) {}
    RSVPParameters(const RSVPParameters & other) : Inherited(other)
    {}
    RSVPParameters& operator = (const RSVPParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_qosMode,
      e_tokenRate,
      e_bucketSize,
      e_peakRate,
      e_minPoliced,
      e_maxPktSize
    };

    class qosMode {
      public:
        typedef QOSMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qosMode
    qosMode::const_reference get_qosMode () const;
    qosMode::reference ref_qosMode ();
    qosMode::reference set_qosMode ();
    qosMode::reference set_qosMode (qosMode::const_reference value);
    void omit_qosMode ();
    bool qosMode_isPresent () const;
    class tokenRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tokenRate
    tokenRate::const_reference get_tokenRate () const;
    tokenRate::reference ref_tokenRate ();
    tokenRate::reference set_tokenRate ();
    tokenRate::reference set_tokenRate (tokenRate::value_type::int_type value);
    void omit_tokenRate ();
    bool tokenRate_isPresent () const;
    class bucketSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bucketSize
    bucketSize::const_reference get_bucketSize () const;
    bucketSize::reference ref_bucketSize ();
    bucketSize::reference set_bucketSize ();
    bucketSize::reference set_bucketSize (bucketSize::value_type::int_type value);
    void omit_bucketSize ();
    bool bucketSize_isPresent () const;
    class peakRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class peakRate
    peakRate::const_reference get_peakRate () const;
    peakRate::reference ref_peakRate ();
    peakRate::reference set_peakRate ();
    peakRate::reference set_peakRate (peakRate::value_type::int_type value);
    void omit_peakRate ();
    bool peakRate_isPresent () const;
    class minPoliced {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class minPoliced
    minPoliced::const_reference get_minPoliced () const;
    minPoliced::reference ref_minPoliced ();
    minPoliced::reference set_minPoliced ();
    minPoliced::reference set_minPoliced (minPoliced::value_type::int_type value);
    void omit_minPoliced ();
    bool minPoliced_isPresent () const;
    class maxPktSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxPktSize
    maxPktSize::const_reference get_maxPktSize () const;
    maxPktSize::reference ref_maxPktSize ();
    maxPktSize::reference set_maxPktSize ();
    maxPktSize::reference set_maxPktSize (maxPktSize::value_type::int_type value);
    void omit_maxPktSize ();
    bool maxPktSize_isPresent () const;
    void swap(RSVPParameters& other);
    RSVPParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// MediaTransportType
//

class MediaTransportType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MediaTransportType(const void* info) : Inherited(info) {}
  public:
    MediaTransportType() : Inherited(&theInfo) {}
    class ip_UDP {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ip_UDP

    ip_UDP::reference select_ip_UDP (); 
    bool ip_UDP_isSelected() const;

    class ip_TCP {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class ip_TCP

    ip_TCP::reference select_ip_TCP (); 
    bool ip_TCP_isSelected() const;

    class atm_AAL5_UNIDIR {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atm_AAL5_UNIDIR

    atm_AAL5_UNIDIR::reference select_atm_AAL5_UNIDIR (); 
    bool atm_AAL5_UNIDIR_isSelected() const;

    class atm_AAL5_BIDIR {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atm_AAL5_BIDIR

    atm_AAL5_BIDIR::reference select_atm_AAL5_BIDIR (); 
    bool atm_AAL5_BIDIR_isSelected() const;

    class atm_AAL5_compressed {
      public:
        enum Id { id_ = 4 };
        typedef MediaTransportType_atm_AAL5_compressed value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atm_AAL5_compressed

    atm_AAL5_compressed::const_reference get_atm_AAL5_compressed () const;
    atm_AAL5_compressed::reference ref_atm_AAL5_compressed (); 
    atm_AAL5_compressed::reference select_atm_AAL5_compressed (); 
    atm_AAL5_compressed::reference select_atm_AAL5_compressed (atm_AAL5_compressed::const_reference value); 
    bool atm_AAL5_compressed_isSelected() const;

    MediaTransportType(ip_UDP::Id id, ip_UDP::const_reference value);
    MediaTransportType(ip_TCP::Id id, ip_TCP::const_reference value);
    MediaTransportType(atm_AAL5_UNIDIR::Id id, atm_AAL5_UNIDIR::const_reference value);
    MediaTransportType(atm_AAL5_BIDIR::Id id, atm_AAL5_BIDIR::const_reference value);
    MediaTransportType(atm_AAL5_compressed::Id id, atm_AAL5_compressed::const_reference value);
    void swap(MediaTransportType & other);
    MediaTransportType(const MediaTransportType & other)
    : Inherited(other) {} 

    MediaTransportType & operator = (const MediaTransportType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MediaTransportType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// MediaChannelCapability
//

class MediaChannelCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MediaChannelCapability(const void* info) : Inherited(info) {}
  public:
    MediaChannelCapability() : Inherited(&theInfo) {}
    MediaChannelCapability(const MediaChannelCapability & other) : Inherited(other)
    {}
    MediaChannelCapability& operator = (const MediaChannelCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_mediaTransport
    };

    class mediaTransport {
      public:
        typedef MediaTransportType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaTransport
    mediaTransport::const_reference get_mediaTransport () const;
    mediaTransport::reference ref_mediaTransport ();
    mediaTransport::reference set_mediaTransport ();
    mediaTransport::reference set_mediaTransport (mediaTransport::const_reference value);
    void omit_mediaTransport ();
    bool mediaTransport_isPresent () const;
    void swap(MediaChannelCapability& other);
    MediaChannelCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RTPH263VideoRedundancyFrameMapping
//

class RTPH263VideoRedundancyFrameMapping : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RTPH263VideoRedundancyFrameMapping(const void* info) : Inherited(info) {}
  public:
    RTPH263VideoRedundancyFrameMapping() : Inherited(&theInfo) {}
    RTPH263VideoRedundancyFrameMapping(const RTPH263VideoRedundancyFrameMapping & other) : Inherited(other)
    {}
    RTPH263VideoRedundancyFrameMapping& operator = (const RTPH263VideoRedundancyFrameMapping& other)
    { Inherited::operator = (other); return *this; } 
    class threadNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class threadNumber
    threadNumber::const_reference get_threadNumber () const;
    threadNumber::reference ref_threadNumber ();
    threadNumber::reference set_threadNumber ();
    threadNumber::reference set_threadNumber (threadNumber::value_type::int_type value);
    class frameSequence {
      public:
        typedef RTPH263VideoRedundancyFrameMapping_frameSequence value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class frameSequence
    frameSequence::const_reference get_frameSequence () const;
    frameSequence::reference ref_frameSequence ();
    frameSequence::reference set_frameSequence ();
    frameSequence::reference set_frameSequence (frameSequence::const_reference value);
    void swap(RTPH263VideoRedundancyFrameMapping& other);
    RTPH263VideoRedundancyFrameMapping * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H263ModeComboFlags
//

class H263ModeComboFlags : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263ModeComboFlags(const void* info) : Inherited(info) {}
  public:
    H263ModeComboFlags() : Inherited(&theInfo) {}
    H263ModeComboFlags(const H263ModeComboFlags & other) : Inherited(other)
    {}
    H263ModeComboFlags& operator = (const H263ModeComboFlags& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_enhancedReferencePicSelect,
      e_h263Version3Options
    };

    class unrestrictedVector {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unrestrictedVector
    unrestrictedVector::const_reference get_unrestrictedVector () const;
    unrestrictedVector::reference ref_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector (bool value);
    class arithmeticCoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class arithmeticCoding
    arithmeticCoding::const_reference get_arithmeticCoding () const;
    arithmeticCoding::reference ref_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding (bool value);
    class advancedPrediction {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class advancedPrediction
    advancedPrediction::const_reference get_advancedPrediction () const;
    advancedPrediction::reference ref_advancedPrediction ();
    advancedPrediction::reference set_advancedPrediction ();
    advancedPrediction::reference set_advancedPrediction (bool value);
    class pbFrames {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pbFrames
    pbFrames::const_reference get_pbFrames () const;
    pbFrames::reference ref_pbFrames ();
    pbFrames::reference set_pbFrames ();
    pbFrames::reference set_pbFrames (bool value);
    class advancedIntraCodingMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class advancedIntraCodingMode
    advancedIntraCodingMode::const_reference get_advancedIntraCodingMode () const;
    advancedIntraCodingMode::reference ref_advancedIntraCodingMode ();
    advancedIntraCodingMode::reference set_advancedIntraCodingMode ();
    advancedIntraCodingMode::reference set_advancedIntraCodingMode (bool value);
    class deblockingFilterMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deblockingFilterMode
    deblockingFilterMode::const_reference get_deblockingFilterMode () const;
    deblockingFilterMode::reference ref_deblockingFilterMode ();
    deblockingFilterMode::reference set_deblockingFilterMode ();
    deblockingFilterMode::reference set_deblockingFilterMode (bool value);
    class unlimitedMotionVectors {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unlimitedMotionVectors
    unlimitedMotionVectors::const_reference get_unlimitedMotionVectors () const;
    unlimitedMotionVectors::reference ref_unlimitedMotionVectors ();
    unlimitedMotionVectors::reference set_unlimitedMotionVectors ();
    unlimitedMotionVectors::reference set_unlimitedMotionVectors (bool value);
    class slicesInOrder_NonRect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesInOrder_NonRect
    slicesInOrder_NonRect::const_reference get_slicesInOrder_NonRect () const;
    slicesInOrder_NonRect::reference ref_slicesInOrder_NonRect ();
    slicesInOrder_NonRect::reference set_slicesInOrder_NonRect ();
    slicesInOrder_NonRect::reference set_slicesInOrder_NonRect (bool value);
    class slicesInOrder_Rect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesInOrder_Rect
    slicesInOrder_Rect::const_reference get_slicesInOrder_Rect () const;
    slicesInOrder_Rect::reference ref_slicesInOrder_Rect ();
    slicesInOrder_Rect::reference set_slicesInOrder_Rect ();
    slicesInOrder_Rect::reference set_slicesInOrder_Rect (bool value);
    class slicesNoOrder_NonRect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesNoOrder_NonRect
    slicesNoOrder_NonRect::const_reference get_slicesNoOrder_NonRect () const;
    slicesNoOrder_NonRect::reference ref_slicesNoOrder_NonRect ();
    slicesNoOrder_NonRect::reference set_slicesNoOrder_NonRect ();
    slicesNoOrder_NonRect::reference set_slicesNoOrder_NonRect (bool value);
    class slicesNoOrder_Rect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesNoOrder_Rect
    slicesNoOrder_Rect::const_reference get_slicesNoOrder_Rect () const;
    slicesNoOrder_Rect::reference ref_slicesNoOrder_Rect ();
    slicesNoOrder_Rect::reference set_slicesNoOrder_Rect ();
    slicesNoOrder_Rect::reference set_slicesNoOrder_Rect (bool value);
    class improvedPBFramesMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class improvedPBFramesMode
    improvedPBFramesMode::const_reference get_improvedPBFramesMode () const;
    improvedPBFramesMode::reference ref_improvedPBFramesMode ();
    improvedPBFramesMode::reference set_improvedPBFramesMode ();
    improvedPBFramesMode::reference set_improvedPBFramesMode (bool value);
    class referencePicSelect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class referencePicSelect
    referencePicSelect::const_reference get_referencePicSelect () const;
    referencePicSelect::reference ref_referencePicSelect ();
    referencePicSelect::reference set_referencePicSelect ();
    referencePicSelect::reference set_referencePicSelect (bool value);
    class dynamicPictureResizingByFour {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicPictureResizingByFour
    dynamicPictureResizingByFour::const_reference get_dynamicPictureResizingByFour () const;
    dynamicPictureResizingByFour::reference ref_dynamicPictureResizingByFour ();
    dynamicPictureResizingByFour::reference set_dynamicPictureResizingByFour ();
    dynamicPictureResizingByFour::reference set_dynamicPictureResizingByFour (bool value);
    class dynamicPictureResizingSixteenthPel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicPictureResizingSixteenthPel
    dynamicPictureResizingSixteenthPel::const_reference get_dynamicPictureResizingSixteenthPel () const;
    dynamicPictureResizingSixteenthPel::reference ref_dynamicPictureResizingSixteenthPel ();
    dynamicPictureResizingSixteenthPel::reference set_dynamicPictureResizingSixteenthPel ();
    dynamicPictureResizingSixteenthPel::reference set_dynamicPictureResizingSixteenthPel (bool value);
    class dynamicWarpingHalfPel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicWarpingHalfPel
    dynamicWarpingHalfPel::const_reference get_dynamicWarpingHalfPel () const;
    dynamicWarpingHalfPel::reference ref_dynamicWarpingHalfPel ();
    dynamicWarpingHalfPel::reference set_dynamicWarpingHalfPel ();
    dynamicWarpingHalfPel::reference set_dynamicWarpingHalfPel (bool value);
    class dynamicWarpingSixteenthPel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicWarpingSixteenthPel
    dynamicWarpingSixteenthPel::const_reference get_dynamicWarpingSixteenthPel () const;
    dynamicWarpingSixteenthPel::reference ref_dynamicWarpingSixteenthPel ();
    dynamicWarpingSixteenthPel::reference set_dynamicWarpingSixteenthPel ();
    dynamicWarpingSixteenthPel::reference set_dynamicWarpingSixteenthPel (bool value);
    class reducedResolutionUpdate {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reducedResolutionUpdate
    reducedResolutionUpdate::const_reference get_reducedResolutionUpdate () const;
    reducedResolutionUpdate::reference ref_reducedResolutionUpdate ();
    reducedResolutionUpdate::reference set_reducedResolutionUpdate ();
    reducedResolutionUpdate::reference set_reducedResolutionUpdate (bool value);
    class independentSegmentDecoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class independentSegmentDecoding
    independentSegmentDecoding::const_reference get_independentSegmentDecoding () const;
    independentSegmentDecoding::reference ref_independentSegmentDecoding ();
    independentSegmentDecoding::reference set_independentSegmentDecoding ();
    independentSegmentDecoding::reference set_independentSegmentDecoding (bool value);
    class alternateInterVLCMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alternateInterVLCMode
    alternateInterVLCMode::const_reference get_alternateInterVLCMode () const;
    alternateInterVLCMode::reference ref_alternateInterVLCMode ();
    alternateInterVLCMode::reference set_alternateInterVLCMode ();
    alternateInterVLCMode::reference set_alternateInterVLCMode (bool value);
    class modifiedQuantizationMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class modifiedQuantizationMode
    modifiedQuantizationMode::const_reference get_modifiedQuantizationMode () const;
    modifiedQuantizationMode::reference ref_modifiedQuantizationMode ();
    modifiedQuantizationMode::reference set_modifiedQuantizationMode ();
    modifiedQuantizationMode::reference set_modifiedQuantizationMode (bool value);
    class enhancedReferencePicSelect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enhancedReferencePicSelect
    enhancedReferencePicSelect::const_reference get_enhancedReferencePicSelect () const;
    enhancedReferencePicSelect::reference ref_enhancedReferencePicSelect ();
    enhancedReferencePicSelect::reference set_enhancedReferencePicSelect ();
    enhancedReferencePicSelect::reference set_enhancedReferencePicSelect (bool value);
    void omit_enhancedReferencePicSelect ();
    bool enhancedReferencePicSelect_isPresent () const;
    class h263Version3Options {
      public:
        typedef H263Version3Options value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263Version3Options
    h263Version3Options::const_reference get_h263Version3Options () const;
    h263Version3Options::reference ref_h263Version3Options ();
    h263Version3Options::reference set_h263Version3Options ();
    h263Version3Options::reference set_h263Version3Options (h263Version3Options::const_reference value);
    void omit_h263Version3Options ();
    bool h263Version3Options_isPresent () const;
    void swap(H263ModeComboFlags& other);
    H263ModeComboFlags * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[23];
    static int fieldIds[23];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[23];
};

//
// G7231AnnexCCapability
//

class G7231AnnexCCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    G7231AnnexCCapability(const void* info) : Inherited(info) {}
  public:
    G7231AnnexCCapability() : Inherited(&theInfo) {}
    G7231AnnexCCapability(const G7231AnnexCCapability & other) : Inherited(other)
    {}
    G7231AnnexCCapability& operator = (const G7231AnnexCCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_g723AnnexCAudioMode
    };

    class maxAl_sduAudioFrames {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxAl_sduAudioFrames
    maxAl_sduAudioFrames::const_reference get_maxAl_sduAudioFrames () const;
    maxAl_sduAudioFrames::reference ref_maxAl_sduAudioFrames ();
    maxAl_sduAudioFrames::reference set_maxAl_sduAudioFrames ();
    maxAl_sduAudioFrames::reference set_maxAl_sduAudioFrames (maxAl_sduAudioFrames::value_type::int_type value);
    class silenceSuppression {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class silenceSuppression
    silenceSuppression::const_reference get_silenceSuppression () const;
    silenceSuppression::reference ref_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression (bool value);
    class g723AnnexCAudioMode {
      public:
        typedef G7231AnnexCCapability_g723AnnexCAudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g723AnnexCAudioMode
    g723AnnexCAudioMode::const_reference get_g723AnnexCAudioMode () const;
    g723AnnexCAudioMode::reference ref_g723AnnexCAudioMode ();
    g723AnnexCAudioMode::reference set_g723AnnexCAudioMode ();
    g723AnnexCAudioMode::reference set_g723AnnexCAudioMode (g723AnnexCAudioMode::const_reference value);
    void omit_g723AnnexCAudioMode ();
    bool g723AnnexCAudioMode_isPresent () const;
    void swap(G7231AnnexCCapability& other);
    G7231AnnexCCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// CompressionType
//

class CompressionType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CompressionType(const void* info) : Inherited(info) {}
  public:
    CompressionType() : Inherited(&theInfo) {}
    class v42bis {
      public:
        enum Id { id_ = 0 };
        typedef V42bis value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v42bis

    v42bis::const_reference get_v42bis () const;
    v42bis::reference ref_v42bis (); 
    v42bis::reference select_v42bis (); 
    v42bis::reference select_v42bis (v42bis::const_reference value); 
    bool v42bis_isSelected() const;

    CompressionType(v42bis::Id id, v42bis::const_reference value);
    void swap(CompressionType & other);
    CompressionType(const CompressionType & other)
    : Inherited(other) {} 

    CompressionType & operator = (const CompressionType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CompressionType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// T84Profile
//

class T84Profile : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T84Profile(const void* info) : Inherited(info) {}
  public:
    T84Profile() : Inherited(&theInfo) {}
    class t84Unrestricted {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t84Unrestricted

    t84Unrestricted::reference select_t84Unrestricted (); 
    bool t84Unrestricted_isSelected() const;

    class t84Restricted {
      public:
        enum Id { id_ = 1 };
        typedef T84Profile_t84Restricted value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t84Restricted

    t84Restricted::const_reference get_t84Restricted () const;
    t84Restricted::reference ref_t84Restricted (); 
    t84Restricted::reference select_t84Restricted (); 
    t84Restricted::reference select_t84Restricted (t84Restricted::const_reference value); 
    bool t84Restricted_isSelected() const;

    T84Profile(t84Unrestricted::Id id, t84Unrestricted::const_reference value);
    T84Profile(t84Restricted::Id id, t84Restricted::const_reference value);
    void swap(T84Profile & other);
    T84Profile(const T84Profile & other)
    : Inherited(other) {} 

    T84Profile & operator = (const T84Profile & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    T84Profile * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// T38FaxUdpOptions
//

class T38FaxUdpOptions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T38FaxUdpOptions(const void* info) : Inherited(info) {}
  public:
    T38FaxUdpOptions() : Inherited(&theInfo) {}
    T38FaxUdpOptions(const T38FaxUdpOptions & other) : Inherited(other)
    {}
    T38FaxUdpOptions& operator = (const T38FaxUdpOptions& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_t38FaxMaxBuffer,
      e_t38FaxMaxDatagram
    };

    class t38FaxMaxBuffer {
      public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxMaxBuffer
    t38FaxMaxBuffer::const_reference get_t38FaxMaxBuffer () const;
    t38FaxMaxBuffer::reference ref_t38FaxMaxBuffer ();
    t38FaxMaxBuffer::reference set_t38FaxMaxBuffer ();
    t38FaxMaxBuffer::reference set_t38FaxMaxBuffer (t38FaxMaxBuffer::value_type::int_type value);
    void omit_t38FaxMaxBuffer ();
    bool t38FaxMaxBuffer_isPresent () const;
    class t38FaxMaxDatagram {
      public:
        typedef ASN1::INTEGER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxMaxDatagram
    t38FaxMaxDatagram::const_reference get_t38FaxMaxDatagram () const;
    t38FaxMaxDatagram::reference ref_t38FaxMaxDatagram ();
    t38FaxMaxDatagram::reference set_t38FaxMaxDatagram ();
    t38FaxMaxDatagram::reference set_t38FaxMaxDatagram (t38FaxMaxDatagram::value_type::int_type value);
    void omit_t38FaxMaxDatagram ();
    bool t38FaxMaxDatagram_isPresent () const;
    class t38FaxUdpEC {
      public:
        typedef T38FaxUdpOptions_t38FaxUdpEC value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxUdpEC
    t38FaxUdpEC::const_reference get_t38FaxUdpEC () const;
    t38FaxUdpEC::reference ref_t38FaxUdpEC ();
    t38FaxUdpEC::reference set_t38FaxUdpEC ();
    t38FaxUdpEC::reference set_t38FaxUdpEC (t38FaxUdpEC::const_reference value);
    void swap(T38FaxUdpOptions& other);
    T38FaxUdpOptions * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MultiplePayloadStreamCapability
//

class MultiplePayloadStreamCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplePayloadStreamCapability(const void* info) : Inherited(info) {}
  public:
    MultiplePayloadStreamCapability() : Inherited(&theInfo) {}
    MultiplePayloadStreamCapability(const MultiplePayloadStreamCapability & other) : Inherited(other)
    {}
    MultiplePayloadStreamCapability& operator = (const MultiplePayloadStreamCapability& other)
    { Inherited::operator = (other); return *this; } 
    class capabilities {
      public:
        typedef ASN1::SET_OF<AlternativeCapabilitySet,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilities
    capabilities::const_reference get_capabilities () const;
    capabilities::reference ref_capabilities ();
    capabilities::reference set_capabilities ();
    capabilities::reference set_capabilities (capabilities::const_reference value);
    void swap(MultiplePayloadStreamCapability& other);
    MultiplePayloadStreamCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// FECCapability
//

class FECCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECCapability(const void* info) : Inherited(info) {}
  public:
    FECCapability() : Inherited(&theInfo) {}
    FECCapability(const FECCapability & other) : Inherited(other)
    {}
    FECCapability& operator = (const FECCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_fecScheme,
      e_rfc2733Format
    };

    class protectedCapability {
      public:
        typedef CapabilityTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedCapability
    protectedCapability::const_reference get_protectedCapability () const;
    protectedCapability::reference ref_protectedCapability ();
    protectedCapability::reference set_protectedCapability ();
    protectedCapability::reference set_protectedCapability (protectedCapability::value_type::int_type value);
    class fecScheme {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fecScheme
    fecScheme::const_reference get_fecScheme () const;
    fecScheme::reference ref_fecScheme ();
    fecScheme::reference set_fecScheme ();
    fecScheme::reference set_fecScheme (fecScheme::const_reference value);
    void omit_fecScheme ();
    bool fecScheme_isPresent () const;
    class rfc2733Format {
      public:
        typedef FECCapability_rfc2733Format value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733Format
    rfc2733Format::const_reference get_rfc2733Format () const;
    rfc2733Format::reference ref_rfc2733Format ();
    rfc2733Format::reference set_rfc2733Format ();
    rfc2733Format::reference set_rfc2733Format (rfc2733Format::const_reference value);
    void omit_rfc2733Format ();
    bool rfc2733Format_isPresent () const;
    void swap(FECCapability& other);
    FECCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// Q2931Address
//

class Q2931Address : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    Q2931Address(const void* info) : Inherited(info) {}
  public:
    Q2931Address() : Inherited(&theInfo) {}
    Q2931Address(const Q2931Address & other) : Inherited(other)
    {}
    Q2931Address& operator = (const Q2931Address& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_subaddress
    };

    class address {
      public:
        typedef Q2931Address_address value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class address
    address::const_reference get_address () const;
    address::reference ref_address ();
    address::reference set_address ();
    address::reference set_address (address::const_reference value);
    class subaddress {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 20> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subaddress
    subaddress::const_reference get_subaddress () const;
    subaddress::reference ref_subaddress ();
    subaddress::reference set_subaddress ();
    subaddress::reference set_subaddress (const std::vector<char>& value);
    void omit_subaddress ();
    bool subaddress_isPresent () const;
    void swap(Q2931Address& other);
    Q2931Address * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223AL2MParameters
//

class H223AL2MParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL2MParameters(const void* info) : Inherited(info) {}
  public:
    H223AL2MParameters() : Inherited(&theInfo) {}
    H223AL2MParameters(const H223AL2MParameters & other) : Inherited(other)
    {}
    H223AL2MParameters& operator = (const H223AL2MParameters& other)
    { Inherited::operator = (other); return *this; } 
    class headerFEC {
      public:
        typedef H223AL2MParameters_headerFEC value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class headerFEC
    headerFEC::const_reference get_headerFEC () const;
    headerFEC::reference ref_headerFEC ();
    headerFEC::reference set_headerFEC ();
    headerFEC::reference set_headerFEC (headerFEC::const_reference value);
    class alpduInterleaving {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alpduInterleaving
    alpduInterleaving::const_reference get_alpduInterleaving () const;
    alpduInterleaving::reference ref_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving (bool value);
    void swap(H223AL2MParameters& other);
    H223AL2MParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223AnnexCArqParameters
//

class H223AnnexCArqParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AnnexCArqParameters(const void* info) : Inherited(info) {}
  public:
    H223AnnexCArqParameters() : Inherited(&theInfo) {}
    H223AnnexCArqParameters(const H223AnnexCArqParameters & other) : Inherited(other)
    {}
    H223AnnexCArqParameters& operator = (const H223AnnexCArqParameters& other)
    { Inherited::operator = (other); return *this; } 
    class numberOfRetransmissions {
      public:
        typedef H223AnnexCArqParameters_numberOfRetransmissions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfRetransmissions
    numberOfRetransmissions::const_reference get_numberOfRetransmissions () const;
    numberOfRetransmissions::reference ref_numberOfRetransmissions ();
    numberOfRetransmissions::reference set_numberOfRetransmissions ();
    numberOfRetransmissions::reference set_numberOfRetransmissions (numberOfRetransmissions::const_reference value);
    class sendBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16777215>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendBufferSize
    sendBufferSize::const_reference get_sendBufferSize () const;
    sendBufferSize::reference ref_sendBufferSize ();
    sendBufferSize::reference set_sendBufferSize ();
    sendBufferSize::reference set_sendBufferSize (sendBufferSize::value_type::int_type value);
    void swap(H223AnnexCArqParameters& other);
    H223AnnexCArqParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// V76HDLCParameters
//

class V76HDLCParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76HDLCParameters(const void* info) : Inherited(info) {}
  public:
    V76HDLCParameters() : Inherited(&theInfo) {}
    V76HDLCParameters(const V76HDLCParameters & other) : Inherited(other)
    {}
    V76HDLCParameters& operator = (const V76HDLCParameters& other)
    { Inherited::operator = (other); return *this; } 
    class crcLength {
      public:
        typedef CRCLength value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crcLength
    crcLength::const_reference get_crcLength () const;
    crcLength::reference ref_crcLength ();
    crcLength::reference set_crcLength ();
    crcLength::reference set_crcLength (crcLength::const_reference value);
    class n401 {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4095>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class n401
    n401::const_reference get_n401 () const;
    n401::reference ref_n401 ();
    n401::reference set_n401 ();
    n401::reference set_n401 (n401::value_type::int_type value);
    class loopbackTestProcedure {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class loopbackTestProcedure
    loopbackTestProcedure::const_reference get_loopbackTestProcedure () const;
    loopbackTestProcedure::reference ref_loopbackTestProcedure ();
    loopbackTestProcedure::reference set_loopbackTestProcedure ();
    loopbackTestProcedure::reference set_loopbackTestProcedure (bool value);
    void swap(V76HDLCParameters& other);
    V76HDLCParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// CloseLogicalChannel
//

class CloseLogicalChannel : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CloseLogicalChannel(const void* info) : Inherited(info) {}
  public:
    CloseLogicalChannel() : Inherited(&theInfo) {}
    CloseLogicalChannel(const CloseLogicalChannel & other) : Inherited(other)
    {}
    CloseLogicalChannel& operator = (const CloseLogicalChannel& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_reason
    };

    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class source {
      public:
        typedef CloseLogicalChannel_source value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class source
    source::const_reference get_source () const;
    source::reference ref_source ();
    source::reference set_source ();
    source::reference set_source (source::const_reference value);
    class reason {
      public:
        typedef CloseLogicalChannel_reason value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reason
    reason::const_reference get_reason () const;
    reason::reference ref_reason ();
    reason::reference set_reason ();
    reason::reference set_reason (reason::const_reference value);
    void omit_reason ();
    bool reason_isPresent () const;
    void swap(CloseLogicalChannel& other);
    CloseLogicalChannel * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[3];
};

//
// RequestChannelCloseReject
//

class RequestChannelCloseReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestChannelCloseReject(const void* info) : Inherited(info) {}
  public:
    RequestChannelCloseReject() : Inherited(&theInfo) {}
    RequestChannelCloseReject(const RequestChannelCloseReject & other) : Inherited(other)
    {}
    RequestChannelCloseReject& operator = (const RequestChannelCloseReject& other)
    { Inherited::operator = (other); return *this; } 
    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class cause {
      public:
        typedef RequestChannelCloseReject_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    void swap(RequestChannelCloseReject& other);
    RequestChannelCloseReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultiplexElement
//

class MultiplexElement_type;

class MultiplexElement : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexElement(const void* info) : Inherited(info) {}
  public:
    MultiplexElement() : Inherited(&theInfo) {}
    MultiplexElement(const MultiplexElement & other) : Inherited(other)
    {}
    MultiplexElement& operator = (const MultiplexElement& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef MultiplexElement_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    class repeatCount {
      public:
        typedef MultiplexElement_repeatCount value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class repeatCount
    repeatCount::const_reference get_repeatCount () const;
    repeatCount::reference ref_repeatCount ();
    repeatCount::reference set_repeatCount ();
    repeatCount::reference set_repeatCount (repeatCount::const_reference value);
    void swap(MultiplexElement& other);
    MultiplexElement * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultiplexEntryRejectionDescriptions
//

class MultiplexEntryRejectionDescriptions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntryRejectionDescriptions(const void* info) : Inherited(info) {}
  public:
    MultiplexEntryRejectionDescriptions() : Inherited(&theInfo) {}
    MultiplexEntryRejectionDescriptions(const MultiplexEntryRejectionDescriptions & other) : Inherited(other)
    {}
    MultiplexEntryRejectionDescriptions& operator = (const MultiplexEntryRejectionDescriptions& other)
    { Inherited::operator = (other); return *this; } 
    class multiplexTableEntryNumber {
      public:
        typedef MultiplexTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexTableEntryNumber
    multiplexTableEntryNumber::const_reference get_multiplexTableEntryNumber () const;
    multiplexTableEntryNumber::reference ref_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber (multiplexTableEntryNumber::value_type::int_type value);
    class cause {
      public:
        typedef MultiplexEntryRejectionDescriptions_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    void swap(MultiplexEntryRejectionDescriptions& other);
    MultiplexEntryRejectionDescriptions * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RequestMultiplexEntryRejectionDescriptions
//

class RequestMultiplexEntryRejectionDescriptions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMultiplexEntryRejectionDescriptions(const void* info) : Inherited(info) {}
  public:
    RequestMultiplexEntryRejectionDescriptions() : Inherited(&theInfo) {}
    RequestMultiplexEntryRejectionDescriptions(const RequestMultiplexEntryRejectionDescriptions & other) : Inherited(other)
    {}
    RequestMultiplexEntryRejectionDescriptions& operator = (const RequestMultiplexEntryRejectionDescriptions& other)
    { Inherited::operator = (other); return *this; } 
    class multiplexTableEntryNumber {
      public:
        typedef MultiplexTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexTableEntryNumber
    multiplexTableEntryNumber::const_reference get_multiplexTableEntryNumber () const;
    multiplexTableEntryNumber::reference ref_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber (multiplexTableEntryNumber::value_type::int_type value);
    class cause {
      public:
        typedef RequestMultiplexEntryRejectionDescriptions_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    void swap(RequestMultiplexEntryRejectionDescriptions& other);
    RequestMultiplexEntryRejectionDescriptions * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RequestModeAck
//

class RequestModeAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestModeAck(const void* info) : Inherited(info) {}
  public:
    RequestModeAck() : Inherited(&theInfo) {}
    RequestModeAck(const RequestModeAck & other) : Inherited(other)
    {}
    RequestModeAck& operator = (const RequestModeAck& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class response {
      public:
        typedef RequestModeAck_response value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class response
    response::const_reference get_response () const;
    response::reference ref_response ();
    response::reference set_response ();
    response::reference set_response (response::const_reference value);
    void swap(RequestModeAck& other);
    RequestModeAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RequestModeReject
//

class RequestModeReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestModeReject(const void* info) : Inherited(info) {}
  public:
    RequestModeReject() : Inherited(&theInfo) {}
    RequestModeReject(const RequestModeReject & other) : Inherited(other)
    {}
    RequestModeReject& operator = (const RequestModeReject& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class cause {
      public:
        typedef RequestModeReject_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    void swap(RequestModeReject& other);
    RequestModeReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// FECMode
//

class ModeElementType;

class FECMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECMode(const void* info) : Inherited(info) {}
  public:
    FECMode() : Inherited(&theInfo) {}
    FECMode(const FECMode & other) : Inherited(other)
    {}
    FECMode& operator = (const FECMode& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_fecScheme,
      e_rfc2733Format
    };

    class protectedElement {
      public:
        typedef ModeElementType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedElement
    protectedElement::const_reference get_protectedElement () const;
    protectedElement::reference ref_protectedElement ();
    protectedElement::reference set_protectedElement ();
    protectedElement::reference set_protectedElement (protectedElement::const_reference value);
    class fecScheme {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fecScheme
    fecScheme::const_reference get_fecScheme () const;
    fecScheme::reference ref_fecScheme ();
    fecScheme::reference set_fecScheme ();
    fecScheme::reference set_fecScheme (fecScheme::const_reference value);
    void omit_fecScheme ();
    bool fecScheme_isPresent () const;
    class rfc2733Format {
      public:
        typedef FECMode_rfc2733Format value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733Format
    rfc2733Format::const_reference get_rfc2733Format () const;
    rfc2733Format::reference ref_rfc2733Format ();
    rfc2733Format::reference set_rfc2733Format ();
    rfc2733Format::reference set_rfc2733Format (rfc2733Format::const_reference value);
    void omit_rfc2733Format ();
    bool rfc2733Format_isPresent () const;
    void swap(FECMode& other);
    FECMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H261VideoMode
//

class H261VideoMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H261VideoMode(const void* info) : Inherited(info) {}
  public:
    H261VideoMode() : Inherited(&theInfo) {}
    H261VideoMode(const H261VideoMode & other) : Inherited(other)
    {}
    H261VideoMode& operator = (const H261VideoMode& other)
    { Inherited::operator = (other); return *this; } 
    class resolution {
      public:
        typedef H261VideoMode_resolution value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resolution
    resolution::const_reference get_resolution () const;
    resolution::reference ref_resolution ();
    resolution::reference set_resolution ();
    resolution::reference set_resolution (resolution::const_reference value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 19200>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    class stillImageTransmission {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class stillImageTransmission
    stillImageTransmission::const_reference get_stillImageTransmission () const;
    stillImageTransmission::reference ref_stillImageTransmission ();
    stillImageTransmission::reference set_stillImageTransmission ();
    stillImageTransmission::reference set_stillImageTransmission (bool value);
    void swap(H261VideoMode& other);
    H261VideoMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H262VideoMode
//

class H262VideoMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H262VideoMode(const void* info) : Inherited(info) {}
  public:
    H262VideoMode() : Inherited(&theInfo) {}
    H262VideoMode(const H262VideoMode & other) : Inherited(other)
    {}
    H262VideoMode& operator = (const H262VideoMode& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_videoBitRate,
      e_vbvBufferSize,
      e_samplesPerLine,
      e_linesPerFrame,
      e_framesPerSecond,
      e_luminanceSampleRate
    };

    class profileAndLevel {
      public:
        typedef H262VideoMode_profileAndLevel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class profileAndLevel
    profileAndLevel::const_reference get_profileAndLevel () const;
    profileAndLevel::reference ref_profileAndLevel ();
    profileAndLevel::reference set_profileAndLevel ();
    profileAndLevel::reference set_profileAndLevel (profileAndLevel::const_reference value);
    class videoBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1073741823>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBitRate
    videoBitRate::const_reference get_videoBitRate () const;
    videoBitRate::reference ref_videoBitRate ();
    videoBitRate::reference set_videoBitRate ();
    videoBitRate::reference set_videoBitRate (videoBitRate::value_type::int_type value);
    void omit_videoBitRate ();
    bool videoBitRate_isPresent () const;
    class vbvBufferSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vbvBufferSize
    vbvBufferSize::const_reference get_vbvBufferSize () const;
    vbvBufferSize::reference ref_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize ();
    vbvBufferSize::reference set_vbvBufferSize (vbvBufferSize::value_type::int_type value);
    void omit_vbvBufferSize ();
    bool vbvBufferSize_isPresent () const;
    class samplesPerLine {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samplesPerLine
    samplesPerLine::const_reference get_samplesPerLine () const;
    samplesPerLine::reference ref_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine ();
    samplesPerLine::reference set_samplesPerLine (samplesPerLine::value_type::int_type value);
    void omit_samplesPerLine ();
    bool samplesPerLine_isPresent () const;
    class linesPerFrame {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 16383>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class linesPerFrame
    linesPerFrame::const_reference get_linesPerFrame () const;
    linesPerFrame::reference ref_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame ();
    linesPerFrame::reference set_linesPerFrame (linesPerFrame::value_type::int_type value);
    void omit_linesPerFrame ();
    bool linesPerFrame_isPresent () const;
    class framesPerSecond {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class framesPerSecond
    framesPerSecond::const_reference get_framesPerSecond () const;
    framesPerSecond::reference ref_framesPerSecond ();
    framesPerSecond::reference set_framesPerSecond ();
    framesPerSecond::reference set_framesPerSecond (framesPerSecond::value_type::int_type value);
    void omit_framesPerSecond ();
    bool framesPerSecond_isPresent () const;
    class luminanceSampleRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class luminanceSampleRate
    luminanceSampleRate::const_reference get_luminanceSampleRate () const;
    luminanceSampleRate::reference ref_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate ();
    luminanceSampleRate::reference set_luminanceSampleRate (luminanceSampleRate::value_type::int_type value);
    void omit_luminanceSampleRate ();
    bool luminanceSampleRate_isPresent () const;
    void swap(H262VideoMode& other);
    H262VideoMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* fieldNames[7];
};

//
// IS11172AudioMode
//

class IS11172AudioMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS11172AudioMode(const void* info) : Inherited(info) {}
  public:
    IS11172AudioMode() : Inherited(&theInfo) {}
    IS11172AudioMode(const IS11172AudioMode & other) : Inherited(other)
    {}
    IS11172AudioMode& operator = (const IS11172AudioMode& other)
    { Inherited::operator = (other); return *this; } 
    class audioLayer {
      public:
        typedef IS11172AudioMode_audioLayer value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer
    audioLayer::const_reference get_audioLayer () const;
    audioLayer::reference ref_audioLayer ();
    audioLayer::reference set_audioLayer ();
    audioLayer::reference set_audioLayer (audioLayer::const_reference value);
    class audioSampling {
      public:
        typedef IS11172AudioMode_audioSampling value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling
    audioSampling::const_reference get_audioSampling () const;
    audioSampling::reference ref_audioSampling ();
    audioSampling::reference set_audioSampling ();
    audioSampling::reference set_audioSampling (audioSampling::const_reference value);
    class multichannelType {
      public:
        typedef IS11172AudioMode_multichannelType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multichannelType
    multichannelType::const_reference get_multichannelType () const;
    multichannelType::reference ref_multichannelType ();
    multichannelType::reference set_multichannelType ();
    multichannelType::reference set_multichannelType (multichannelType::const_reference value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 448>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    void swap(IS11172AudioMode& other);
    IS11172AudioMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// IS13818AudioMode
//

class IS13818AudioMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IS13818AudioMode(const void* info) : Inherited(info) {}
  public:
    IS13818AudioMode() : Inherited(&theInfo) {}
    IS13818AudioMode(const IS13818AudioMode & other) : Inherited(other)
    {}
    IS13818AudioMode& operator = (const IS13818AudioMode& other)
    { Inherited::operator = (other); return *this; } 
    class audioLayer {
      public:
        typedef IS13818AudioMode_audioLayer value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioLayer
    audioLayer::const_reference get_audioLayer () const;
    audioLayer::reference ref_audioLayer ();
    audioLayer::reference set_audioLayer ();
    audioLayer::reference set_audioLayer (audioLayer::const_reference value);
    class audioSampling {
      public:
        typedef IS13818AudioMode_audioSampling value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioSampling
    audioSampling::const_reference get_audioSampling () const;
    audioSampling::reference ref_audioSampling ();
    audioSampling::reference set_audioSampling ();
    audioSampling::reference set_audioSampling (audioSampling::const_reference value);
    class multichannelType {
      public:
        typedef IS13818AudioMode_multichannelType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multichannelType
    multichannelType::const_reference get_multichannelType () const;
    multichannelType::reference ref_multichannelType ();
    multichannelType::reference set_multichannelType ();
    multichannelType::reference set_multichannelType (multichannelType::const_reference value);
    class lowFrequencyEnhancement {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lowFrequencyEnhancement
    lowFrequencyEnhancement::const_reference get_lowFrequencyEnhancement () const;
    lowFrequencyEnhancement::reference ref_lowFrequencyEnhancement ();
    lowFrequencyEnhancement::reference set_lowFrequencyEnhancement ();
    lowFrequencyEnhancement::reference set_lowFrequencyEnhancement (bool value);
    class multilingual {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multilingual
    multilingual::const_reference get_multilingual () const;
    multilingual::reference ref_multilingual ();
    multilingual::reference set_multilingual ();
    multilingual::reference set_multilingual (bool value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 1130>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    void swap(IS13818AudioMode& other);
    IS13818AudioMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// G7231AnnexCMode
//

class G7231AnnexCMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    G7231AnnexCMode(const void* info) : Inherited(info) {}
  public:
    G7231AnnexCMode() : Inherited(&theInfo) {}
    G7231AnnexCMode(const G7231AnnexCMode & other) : Inherited(other)
    {}
    G7231AnnexCMode& operator = (const G7231AnnexCMode& other)
    { Inherited::operator = (other); return *this; } 
    class maxAl_sduAudioFrames {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxAl_sduAudioFrames
    maxAl_sduAudioFrames::const_reference get_maxAl_sduAudioFrames () const;
    maxAl_sduAudioFrames::reference ref_maxAl_sduAudioFrames ();
    maxAl_sduAudioFrames::reference set_maxAl_sduAudioFrames ();
    maxAl_sduAudioFrames::reference set_maxAl_sduAudioFrames (maxAl_sduAudioFrames::value_type::int_type value);
    class silenceSuppression {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class silenceSuppression
    silenceSuppression::const_reference get_silenceSuppression () const;
    silenceSuppression::reference ref_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression (bool value);
    class g723AnnexCAudioMode {
      public:
        typedef G7231AnnexCMode_g723AnnexCAudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g723AnnexCAudioMode
    g723AnnexCAudioMode::const_reference get_g723AnnexCAudioMode () const;
    g723AnnexCAudioMode::reference ref_g723AnnexCAudioMode ();
    g723AnnexCAudioMode::reference set_g723AnnexCAudioMode ();
    g723AnnexCAudioMode::reference set_g723AnnexCAudioMode (g723AnnexCAudioMode::const_reference value);
    void swap(G7231AnnexCMode& other);
    G7231AnnexCMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// MaintenanceLoopRequest
//

class MaintenanceLoopRequest : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopRequest(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopRequest() : Inherited(&theInfo) {}
    MaintenanceLoopRequest(const MaintenanceLoopRequest & other) : Inherited(other)
    {}
    MaintenanceLoopRequest& operator = (const MaintenanceLoopRequest& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef MaintenanceLoopRequest_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(MaintenanceLoopRequest& other);
    MaintenanceLoopRequest * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MaintenanceLoopAck
//

class MaintenanceLoopAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopAck(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopAck() : Inherited(&theInfo) {}
    MaintenanceLoopAck(const MaintenanceLoopAck & other) : Inherited(other)
    {}
    MaintenanceLoopAck& operator = (const MaintenanceLoopAck& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef MaintenanceLoopAck_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(MaintenanceLoopAck& other);
    MaintenanceLoopAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MaintenanceLoopReject
//

class MaintenanceLoopReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MaintenanceLoopReject(const void* info) : Inherited(info) {}
  public:
    MaintenanceLoopReject() : Inherited(&theInfo) {}
    MaintenanceLoopReject(const MaintenanceLoopReject & other) : Inherited(other)
    {}
    MaintenanceLoopReject& operator = (const MaintenanceLoopReject& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef MaintenanceLoopReject_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    class cause {
      public:
        typedef MaintenanceLoopReject_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    void swap(MaintenanceLoopReject& other);
    MaintenanceLoopReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

typedef ASN1::SEQUENCE_OF<Criteria,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  CertSelectionCriteria;

//
// TerminalLabel
//

class TerminalLabel : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalLabel(const void* info) : Inherited(info) {}
  public:
    TerminalLabel() : Inherited(&theInfo) {}
    TerminalLabel(const TerminalLabel & other) : Inherited(other)
    {}
    TerminalLabel& operator = (const TerminalLabel& other)
    { Inherited::operator = (other); return *this; } 
    class mcuNumber {
      public:
        typedef McuNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mcuNumber
    mcuNumber::const_reference get_mcuNumber () const;
    mcuNumber::reference ref_mcuNumber ();
    mcuNumber::reference set_mcuNumber ();
    mcuNumber::reference set_mcuNumber (mcuNumber::value_type::int_type value);
    class terminalNumber {
      public:
        typedef TerminalNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalNumber
    terminalNumber::const_reference get_terminalNumber () const;
    terminalNumber::reference ref_terminalNumber ();
    terminalNumber::reference set_terminalNumber ();
    terminalNumber::reference set_terminalNumber (terminalNumber::value_type::int_type value);
    void swap(TerminalLabel& other);
    TerminalLabel * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// TerminalInformation
//

class TerminalInformation : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalInformation(const void* info) : Inherited(info) {}
  public:
    TerminalInformation() : Inherited(&theInfo) {}
    TerminalInformation(const TerminalInformation & other) : Inherited(other)
    {}
    TerminalInformation& operator = (const TerminalInformation& other)
    { Inherited::operator = (other); return *this; } 
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    class terminalID {
      public:
        typedef TerminalID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalID
    terminalID::const_reference get_terminalID () const;
    terminalID::reference ref_terminalID ();
    terminalID::reference set_terminalID ();
    terminalID::reference set_terminalID (const std::vector<char>& value);
    void swap(TerminalInformation& other);
    TerminalInformation * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RemoteMCResponse
//

class RemoteMCResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RemoteMCResponse(const void* info) : Inherited(info) {}
  public:
    RemoteMCResponse() : Inherited(&theInfo) {}
    class accept {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class accept

    accept::reference select_accept (); 
    bool accept_isSelected() const;

    class reject {
      public:
        enum Id { id_ = 1 };
        typedef RemoteMCResponse_reject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reject

    reject::const_reference get_reject () const;
    reject::reference ref_reject (); 
    reject::reference select_reject (); 
    reject::reference select_reject (reject::const_reference value); 
    bool reject_isSelected() const;

    RemoteMCResponse(accept::Id id, accept::const_reference value);
    RemoteMCResponse(reject::Id id, reject::const_reference value);
    void swap(RemoteMCResponse & other);
    RemoteMCResponse(const RemoteMCResponse & other)
    : Inherited(other) {} 

    RemoteMCResponse & operator = (const RemoteMCResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RemoteMCResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// LogicalChannelRateReject
//

class LogicalChannelRateReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    LogicalChannelRateReject(const void* info) : Inherited(info) {}
  public:
    LogicalChannelRateReject() : Inherited(&theInfo) {}
    LogicalChannelRateReject(const LogicalChannelRateReject & other) : Inherited(other)
    {}
    LogicalChannelRateReject& operator = (const LogicalChannelRateReject& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_currentMaximumBitRate
    };

    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    class rejectReason {
      public:
        typedef LogicalChannelRateRejectReason value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rejectReason
    rejectReason::const_reference get_rejectReason () const;
    rejectReason::reference ref_rejectReason ();
    rejectReason::reference set_rejectReason ();
    rejectReason::reference set_rejectReason (rejectReason::const_reference value);
    class currentMaximumBitRate {
      public:
        typedef MaximumBitRate value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class currentMaximumBitRate
    currentMaximumBitRate::const_reference get_currentMaximumBitRate () const;
    currentMaximumBitRate::reference ref_currentMaximumBitRate ();
    currentMaximumBitRate::reference set_currentMaximumBitRate ();
    currentMaximumBitRate::reference set_currentMaximumBitRate (currentMaximumBitRate::value_type::int_type value);
    void omit_currentMaximumBitRate ();
    bool currentMaximumBitRate_isPresent () const;
    void swap(LogicalChannelRateReject& other);
    LogicalChannelRateReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// SendTerminalCapabilitySet
//

class SendTerminalCapabilitySet : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    SendTerminalCapabilitySet(const void* info) : Inherited(info) {}
  public:
    SendTerminalCapabilitySet() : Inherited(&theInfo) {}
    class specificRequest {
      public:
        enum Id { id_ = 0 };
        typedef SendTerminalCapabilitySet_specificRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class specificRequest

    specificRequest::const_reference get_specificRequest () const;
    specificRequest::reference ref_specificRequest (); 
    specificRequest::reference select_specificRequest (); 
    specificRequest::reference select_specificRequest (specificRequest::const_reference value); 
    bool specificRequest_isSelected() const;

    class genericRequest {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericRequest

    genericRequest::reference select_genericRequest (); 
    bool genericRequest_isSelected() const;

    SendTerminalCapabilitySet(specificRequest::Id id, specificRequest::const_reference value);
    SendTerminalCapabilitySet(genericRequest::Id id, genericRequest::const_reference value);
    void swap(SendTerminalCapabilitySet & other);
    SendTerminalCapabilitySet(const SendTerminalCapabilitySet & other)
    : Inherited(other) {} 

    SendTerminalCapabilitySet & operator = (const SendTerminalCapabilitySet & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    SendTerminalCapabilitySet * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// FlowControlCommand
//

class FlowControlCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FlowControlCommand(const void* info) : Inherited(info) {}
  public:
    FlowControlCommand() : Inherited(&theInfo) {}
    FlowControlCommand(const FlowControlCommand & other) : Inherited(other)
    {}
    FlowControlCommand& operator = (const FlowControlCommand& other)
    { Inherited::operator = (other); return *this; } 
    class scope {
      public:
        typedef FlowControlCommand_scope value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class scope
    scope::const_reference get_scope () const;
    scope::reference ref_scope ();
    scope::reference set_scope ();
    scope::reference set_scope (scope::const_reference value);
    class restriction {
      public:
        typedef FlowControlCommand_restriction value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class restriction
    restriction::const_reference get_restriction () const;
    restriction::reference ref_restriction ();
    restriction::reference set_restriction ();
    restriction::reference set_restriction (restriction::const_reference value);
    void swap(FlowControlCommand& other);
    FlowControlCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceCommand
//

class ConferenceCommand : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceCommand(const void* info) : Inherited(info) {}
  public:
    ConferenceCommand() : Inherited(&theInfo) {}
    class broadcastMyLogicalChannel {
      public:
        enum Id { id_ = 0 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class broadcastMyLogicalChannel

    broadcastMyLogicalChannel::const_reference get_broadcastMyLogicalChannel () const;
    broadcastMyLogicalChannel::reference ref_broadcastMyLogicalChannel (); 
    broadcastMyLogicalChannel::reference select_broadcastMyLogicalChannel (); 
    broadcastMyLogicalChannel::reference select_broadcastMyLogicalChannel (broadcastMyLogicalChannel::value_type::int_type value); 
    bool broadcastMyLogicalChannel_isSelected() const;

    class cancelBroadcastMyLogicalChannel {
      public:
        enum Id { id_ = 1 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelBroadcastMyLogicalChannel

    cancelBroadcastMyLogicalChannel::const_reference get_cancelBroadcastMyLogicalChannel () const;
    cancelBroadcastMyLogicalChannel::reference ref_cancelBroadcastMyLogicalChannel (); 
    cancelBroadcastMyLogicalChannel::reference select_cancelBroadcastMyLogicalChannel (); 
    cancelBroadcastMyLogicalChannel::reference select_cancelBroadcastMyLogicalChannel (cancelBroadcastMyLogicalChannel::value_type::int_type value); 
    bool cancelBroadcastMyLogicalChannel_isSelected() const;

    class makeTerminalBroadcaster {
      public:
        enum Id { id_ = 2 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class makeTerminalBroadcaster

    makeTerminalBroadcaster::const_reference get_makeTerminalBroadcaster () const;
    makeTerminalBroadcaster::reference ref_makeTerminalBroadcaster (); 
    makeTerminalBroadcaster::reference select_makeTerminalBroadcaster (); 
    makeTerminalBroadcaster::reference select_makeTerminalBroadcaster (makeTerminalBroadcaster::const_reference value); 
    bool makeTerminalBroadcaster_isSelected() const;

    class cancelMakeTerminalBroadcaster {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelMakeTerminalBroadcaster

    cancelMakeTerminalBroadcaster::reference select_cancelMakeTerminalBroadcaster (); 
    bool cancelMakeTerminalBroadcaster_isSelected() const;

    class sendThisSource {
      public:
        enum Id { id_ = 4 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendThisSource

    sendThisSource::const_reference get_sendThisSource () const;
    sendThisSource::reference ref_sendThisSource (); 
    sendThisSource::reference select_sendThisSource (); 
    sendThisSource::reference select_sendThisSource (sendThisSource::const_reference value); 
    bool sendThisSource_isSelected() const;

    class cancelSendThisSource {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelSendThisSource

    cancelSendThisSource::reference select_cancelSendThisSource (); 
    bool cancelSendThisSource_isSelected() const;

    class dropConference {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dropConference

    dropConference::reference select_dropConference (); 
    bool dropConference_isSelected() const;

    class substituteConferenceIDCommand {
      public:
        enum Id { id_ = 7 };
        typedef SubstituteConferenceIDCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class substituteConferenceIDCommand

    substituteConferenceIDCommand::const_reference get_substituteConferenceIDCommand () const;
    substituteConferenceIDCommand::reference ref_substituteConferenceIDCommand (); 
    substituteConferenceIDCommand::reference select_substituteConferenceIDCommand (); 
    substituteConferenceIDCommand::reference select_substituteConferenceIDCommand (substituteConferenceIDCommand::const_reference value); 
    bool substituteConferenceIDCommand_isSelected() const;

    ConferenceCommand(broadcastMyLogicalChannel::Id id, broadcastMyLogicalChannel::value_type::int_type value);
    ConferenceCommand(cancelBroadcastMyLogicalChannel::Id id, cancelBroadcastMyLogicalChannel::value_type::int_type value);
    ConferenceCommand(makeTerminalBroadcaster::Id id, makeTerminalBroadcaster::const_reference value);
    ConferenceCommand(cancelMakeTerminalBroadcaster::Id id, cancelMakeTerminalBroadcaster::const_reference value);
    ConferenceCommand(sendThisSource::Id id, sendThisSource::const_reference value);
    ConferenceCommand(cancelSendThisSource::Id id, cancelSendThisSource::const_reference value);
    ConferenceCommand(dropConference::Id id, dropConference::const_reference value);
    ConferenceCommand(substituteConferenceIDCommand::Id id, substituteConferenceIDCommand::const_reference value);
    void swap(ConferenceCommand & other);
    ConferenceCommand(const ConferenceCommand & other)
    : Inherited(other) {} 

    ConferenceCommand & operator = (const ConferenceCommand & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceCommand * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[8];
    static const char* selectionNames[8];
};

//
// H223MultiplexReconfiguration
//

class H223MultiplexReconfiguration : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223MultiplexReconfiguration(const void* info) : Inherited(info) {}
  public:
    H223MultiplexReconfiguration() : Inherited(&theInfo) {}
    class h223ModeChange {
      public:
        enum Id { id_ = 0 };
        typedef H223MultiplexReconfiguration_h223ModeChange value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223ModeChange

    h223ModeChange::const_reference get_h223ModeChange () const;
    h223ModeChange::reference ref_h223ModeChange (); 
    h223ModeChange::reference select_h223ModeChange (); 
    h223ModeChange::reference select_h223ModeChange (h223ModeChange::const_reference value); 
    bool h223ModeChange_isSelected() const;

    class h223AnnexADoubleFlag {
      public:
        enum Id { id_ = 1 };
        typedef H223MultiplexReconfiguration_h223AnnexADoubleFlag value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223AnnexADoubleFlag

    h223AnnexADoubleFlag::const_reference get_h223AnnexADoubleFlag () const;
    h223AnnexADoubleFlag::reference ref_h223AnnexADoubleFlag (); 
    h223AnnexADoubleFlag::reference select_h223AnnexADoubleFlag (); 
    h223AnnexADoubleFlag::reference select_h223AnnexADoubleFlag (h223AnnexADoubleFlag::const_reference value); 
    bool h223AnnexADoubleFlag_isSelected() const;

    H223MultiplexReconfiguration(h223ModeChange::Id id, h223ModeChange::const_reference value);
    H223MultiplexReconfiguration(h223AnnexADoubleFlag::Id id, h223AnnexADoubleFlag::const_reference value);
    void swap(H223MultiplexReconfiguration & other);
    H223MultiplexReconfiguration(const H223MultiplexReconfiguration & other)
    : Inherited(other) {} 

    H223MultiplexReconfiguration & operator = (const H223MultiplexReconfiguration & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223MultiplexReconfiguration * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MobileMultilinkReconfigurationCommand
//

class MobileMultilinkReconfigurationCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MobileMultilinkReconfigurationCommand(const void* info) : Inherited(info) {}
  public:
    MobileMultilinkReconfigurationCommand() : Inherited(&theInfo) {}
    MobileMultilinkReconfigurationCommand(const MobileMultilinkReconfigurationCommand & other) : Inherited(other)
    {}
    MobileMultilinkReconfigurationCommand& operator = (const MobileMultilinkReconfigurationCommand& other)
    { Inherited::operator = (other); return *this; } 
    class sampleSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sampleSize
    sampleSize::const_reference get_sampleSize () const;
    sampleSize::reference ref_sampleSize ();
    sampleSize::reference set_sampleSize ();
    sampleSize::reference set_sampleSize (sampleSize::value_type::int_type value);
    class samplesPerFrame {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samplesPerFrame
    samplesPerFrame::const_reference get_samplesPerFrame () const;
    samplesPerFrame::reference ref_samplesPerFrame ();
    samplesPerFrame::reference set_samplesPerFrame ();
    samplesPerFrame::reference set_samplesPerFrame (samplesPerFrame::value_type::int_type value);
    class status {
      public:
        typedef MobileMultilinkReconfigurationCommand_status value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class status
    status::const_reference get_status () const;
    status::reference ref_status ();
    status::reference set_status ();
    status::reference set_status (status::const_reference value);
    void swap(MobileMultilinkReconfigurationCommand& other);
    MobileMultilinkReconfigurationCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// FunctionNotSupported
//

class FunctionNotSupported : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FunctionNotSupported(const void* info) : Inherited(info) {}
  public:
    FunctionNotSupported() : Inherited(&theInfo) {}
    FunctionNotSupported(const FunctionNotSupported & other) : Inherited(other)
    {}
    FunctionNotSupported& operator = (const FunctionNotSupported& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_returnedFunction
    };

    class cause {
      public:
        typedef FunctionNotSupported_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    class returnedFunction {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class returnedFunction
    returnedFunction::const_reference get_returnedFunction () const;
    returnedFunction::reference ref_returnedFunction ();
    returnedFunction::reference set_returnedFunction ();
    returnedFunction::reference set_returnedFunction (const std::vector<char>& value);
    void omit_returnedFunction ();
    bool returnedFunction_isPresent () const;
    void swap(FunctionNotSupported& other);
    FunctionNotSupported * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceIndication
//

class ConferenceIndication : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceIndication(const void* info) : Inherited(info) {}
  public:
    ConferenceIndication() : Inherited(&theInfo) {}
    class sbeNumber {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 9>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sbeNumber

    sbeNumber::const_reference get_sbeNumber () const;
    sbeNumber::reference ref_sbeNumber (); 
    sbeNumber::reference select_sbeNumber (); 
    sbeNumber::reference select_sbeNumber (sbeNumber::value_type::int_type value); 
    bool sbeNumber_isSelected() const;

    class terminalNumberAssign {
      public:
        enum Id { id_ = 1 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalNumberAssign

    terminalNumberAssign::const_reference get_terminalNumberAssign () const;
    terminalNumberAssign::reference ref_terminalNumberAssign (); 
    terminalNumberAssign::reference select_terminalNumberAssign (); 
    terminalNumberAssign::reference select_terminalNumberAssign (terminalNumberAssign::const_reference value); 
    bool terminalNumberAssign_isSelected() const;

    class terminalJoinedConference {
      public:
        enum Id { id_ = 2 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalJoinedConference

    terminalJoinedConference::const_reference get_terminalJoinedConference () const;
    terminalJoinedConference::reference ref_terminalJoinedConference (); 
    terminalJoinedConference::reference select_terminalJoinedConference (); 
    terminalJoinedConference::reference select_terminalJoinedConference (terminalJoinedConference::const_reference value); 
    bool terminalJoinedConference_isSelected() const;

    class terminalLeftConference {
      public:
        enum Id { id_ = 3 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLeftConference

    terminalLeftConference::const_reference get_terminalLeftConference () const;
    terminalLeftConference::reference ref_terminalLeftConference (); 
    terminalLeftConference::reference select_terminalLeftConference (); 
    terminalLeftConference::reference select_terminalLeftConference (terminalLeftConference::const_reference value); 
    bool terminalLeftConference_isSelected() const;

    class seenByAtLeastOneOther {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class seenByAtLeastOneOther

    seenByAtLeastOneOther::reference select_seenByAtLeastOneOther (); 
    bool seenByAtLeastOneOther_isSelected() const;

    class cancelSeenByAtLeastOneOther {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelSeenByAtLeastOneOther

    cancelSeenByAtLeastOneOther::reference select_cancelSeenByAtLeastOneOther (); 
    bool cancelSeenByAtLeastOneOther_isSelected() const;

    class seenByAll {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class seenByAll

    seenByAll::reference select_seenByAll (); 
    bool seenByAll_isSelected() const;

    class cancelSeenByAll {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelSeenByAll

    cancelSeenByAll::reference select_cancelSeenByAll (); 
    bool cancelSeenByAll_isSelected() const;

    class terminalYouAreSeeing {
      public:
        enum Id { id_ = 8 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalYouAreSeeing

    terminalYouAreSeeing::const_reference get_terminalYouAreSeeing () const;
    terminalYouAreSeeing::reference ref_terminalYouAreSeeing (); 
    terminalYouAreSeeing::reference select_terminalYouAreSeeing (); 
    terminalYouAreSeeing::reference select_terminalYouAreSeeing (terminalYouAreSeeing::const_reference value); 
    bool terminalYouAreSeeing_isSelected() const;

    class requestForFloor {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestForFloor

    requestForFloor::reference select_requestForFloor (); 
    bool requestForFloor_isSelected() const;

    class withdrawChairToken {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class withdrawChairToken

    withdrawChairToken::reference select_withdrawChairToken (); 
    bool withdrawChairToken_isSelected() const;

    class floorRequested {
      public:
        enum Id { id_ = 11 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class floorRequested

    floorRequested::const_reference get_floorRequested () const;
    floorRequested::reference ref_floorRequested (); 
    floorRequested::reference select_floorRequested (); 
    floorRequested::reference select_floorRequested (floorRequested::const_reference value); 
    bool floorRequested_isSelected() const;

    class terminalYouAreSeeingInSubPictureNumber {
      public:
        enum Id { id_ = 12 };
        typedef TerminalYouAreSeeingInSubPictureNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalYouAreSeeingInSubPictureNumber

    terminalYouAreSeeingInSubPictureNumber::const_reference get_terminalYouAreSeeingInSubPictureNumber () const;
    terminalYouAreSeeingInSubPictureNumber::reference ref_terminalYouAreSeeingInSubPictureNumber (); 
    terminalYouAreSeeingInSubPictureNumber::reference select_terminalYouAreSeeingInSubPictureNumber (); 
    terminalYouAreSeeingInSubPictureNumber::reference select_terminalYouAreSeeingInSubPictureNumber (terminalYouAreSeeingInSubPictureNumber::const_reference value); 
    bool terminalYouAreSeeingInSubPictureNumber_isSelected() const;

    class videoIndicateCompose {
      public:
        enum Id { id_ = 13 };
        typedef VideoIndicateCompose value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoIndicateCompose

    videoIndicateCompose::const_reference get_videoIndicateCompose () const;
    videoIndicateCompose::reference ref_videoIndicateCompose (); 
    videoIndicateCompose::reference select_videoIndicateCompose (); 
    videoIndicateCompose::reference select_videoIndicateCompose (videoIndicateCompose::const_reference value); 
    bool videoIndicateCompose_isSelected() const;

    ConferenceIndication(sbeNumber::Id id, sbeNumber::value_type::int_type value);
    ConferenceIndication(terminalNumberAssign::Id id, terminalNumberAssign::const_reference value);
    ConferenceIndication(terminalJoinedConference::Id id, terminalJoinedConference::const_reference value);
    ConferenceIndication(terminalLeftConference::Id id, terminalLeftConference::const_reference value);
    ConferenceIndication(seenByAtLeastOneOther::Id id, seenByAtLeastOneOther::const_reference value);
    ConferenceIndication(cancelSeenByAtLeastOneOther::Id id, cancelSeenByAtLeastOneOther::const_reference value);
    ConferenceIndication(seenByAll::Id id, seenByAll::const_reference value);
    ConferenceIndication(cancelSeenByAll::Id id, cancelSeenByAll::const_reference value);
    ConferenceIndication(terminalYouAreSeeing::Id id, terminalYouAreSeeing::const_reference value);
    ConferenceIndication(requestForFloor::Id id, requestForFloor::const_reference value);
    ConferenceIndication(withdrawChairToken::Id id, withdrawChairToken::const_reference value);
    ConferenceIndication(floorRequested::Id id, floorRequested::const_reference value);
    ConferenceIndication(terminalYouAreSeeingInSubPictureNumber::Id id, terminalYouAreSeeingInSubPictureNumber::const_reference value);
    ConferenceIndication(videoIndicateCompose::Id id, videoIndicateCompose::const_reference value);
    void swap(ConferenceIndication & other);
    ConferenceIndication(const ConferenceIndication & other)
    : Inherited(other) {} 

    ConferenceIndication & operator = (const ConferenceIndication & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceIndication * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[14];
    static const char* selectionNames[14];
};

//
// JitterIndication
//

class JitterIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    JitterIndication(const void* info) : Inherited(info) {}
  public:
    JitterIndication() : Inherited(&theInfo) {}
    JitterIndication(const JitterIndication & other) : Inherited(other)
    {}
    JitterIndication& operator = (const JitterIndication& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_skippedFrameCount,
      e_additionalDecoderBuffer
    };

    class scope {
      public:
        typedef JitterIndication_scope value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class scope
    scope::const_reference get_scope () const;
    scope::reference ref_scope ();
    scope::reference set_scope ();
    scope::reference set_scope (scope::const_reference value);
    class estimatedReceivedJitterMantissa {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 3>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class estimatedReceivedJitterMantissa
    estimatedReceivedJitterMantissa::const_reference get_estimatedReceivedJitterMantissa () const;
    estimatedReceivedJitterMantissa::reference ref_estimatedReceivedJitterMantissa ();
    estimatedReceivedJitterMantissa::reference set_estimatedReceivedJitterMantissa ();
    estimatedReceivedJitterMantissa::reference set_estimatedReceivedJitterMantissa (estimatedReceivedJitterMantissa::value_type::int_type value);
    class estimatedReceivedJitterExponent {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 7>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class estimatedReceivedJitterExponent
    estimatedReceivedJitterExponent::const_reference get_estimatedReceivedJitterExponent () const;
    estimatedReceivedJitterExponent::reference ref_estimatedReceivedJitterExponent ();
    estimatedReceivedJitterExponent::reference set_estimatedReceivedJitterExponent ();
    estimatedReceivedJitterExponent::reference set_estimatedReceivedJitterExponent (estimatedReceivedJitterExponent::value_type::int_type value);
    class skippedFrameCount {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 15>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class skippedFrameCount
    skippedFrameCount::const_reference get_skippedFrameCount () const;
    skippedFrameCount::reference ref_skippedFrameCount ();
    skippedFrameCount::reference set_skippedFrameCount ();
    skippedFrameCount::reference set_skippedFrameCount (skippedFrameCount::value_type::int_type value);
    void omit_skippedFrameCount ();
    bool skippedFrameCount_isPresent () const;
    class additionalDecoderBuffer {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 262143>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class additionalDecoderBuffer
    additionalDecoderBuffer::const_reference get_additionalDecoderBuffer () const;
    additionalDecoderBuffer::reference ref_additionalDecoderBuffer ();
    additionalDecoderBuffer::reference set_additionalDecoderBuffer ();
    additionalDecoderBuffer::reference set_additionalDecoderBuffer (additionalDecoderBuffer::value_type::int_type value);
    void omit_additionalDecoderBuffer ();
    bool additionalDecoderBuffer_isPresent () const;
    void swap(JitterIndication& other);
    JitterIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// VendorIdentification
//

class VendorIdentification : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VendorIdentification(const void* info) : Inherited(info) {}
  public:
    VendorIdentification() : Inherited(&theInfo) {}
    VendorIdentification(const VendorIdentification & other) : Inherited(other)
    {}
    VendorIdentification& operator = (const VendorIdentification& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_productNumber,
      e_versionNumber
    };

    class vendor {
      public:
        typedef NonStandardIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vendor
    vendor::const_reference get_vendor () const;
    vendor::reference ref_vendor ();
    vendor::reference set_vendor ();
    vendor::reference set_vendor (vendor::const_reference value);
    class productNumber {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class productNumber
    productNumber::const_reference get_productNumber () const;
    productNumber::reference ref_productNumber ();
    productNumber::reference set_productNumber ();
    productNumber::reference set_productNumber (const std::vector<char>& value);
    void omit_productNumber ();
    bool productNumber_isPresent () const;
    class versionNumber {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class versionNumber
    versionNumber::const_reference get_versionNumber () const;
    versionNumber::reference ref_versionNumber ();
    versionNumber::reference set_versionNumber ();
    versionNumber::reference set_versionNumber (const std::vector<char>& value);
    void omit_versionNumber ();
    bool versionNumber_isPresent () const;
    void swap(VendorIdentification& other);
    VendorIdentification * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// FlowControlIndication
//

class FlowControlIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FlowControlIndication(const void* info) : Inherited(info) {}
  public:
    FlowControlIndication() : Inherited(&theInfo) {}
    FlowControlIndication(const FlowControlIndication & other) : Inherited(other)
    {}
    FlowControlIndication& operator = (const FlowControlIndication& other)
    { Inherited::operator = (other); return *this; } 
    class scope {
      public:
        typedef FlowControlIndication_scope value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class scope
    scope::const_reference get_scope () const;
    scope::reference ref_scope ();
    scope::reference set_scope ();
    scope::reference set_scope (scope::const_reference value);
    class restriction {
      public:
        typedef FlowControlIndication_restriction value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class restriction
    restriction::const_reference get_restriction () const;
    restriction::reference ref_restriction ();
    restriction::reference set_restriction ();
    restriction::reference set_restriction (restriction::const_reference value);
    void swap(FlowControlIndication& other);
    FlowControlIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// TerminalCapabilitySetReject_cause
//

class TerminalCapabilitySetReject_cause : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalCapabilitySetReject_cause(const void* info) : Inherited(info) {}
  public:
    TerminalCapabilitySetReject_cause() : Inherited(&theInfo) {}
    class unspecified {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unspecified

    unspecified::reference select_unspecified (); 
    bool unspecified_isSelected() const;

    class undefinedTableEntryUsed {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class undefinedTableEntryUsed

    undefinedTableEntryUsed::reference select_undefinedTableEntryUsed (); 
    bool undefinedTableEntryUsed_isSelected() const;

    class descriptorCapacityExceeded {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class descriptorCapacityExceeded

    descriptorCapacityExceeded::reference select_descriptorCapacityExceeded (); 
    bool descriptorCapacityExceeded_isSelected() const;

    class tableEntryCapacityExceeded {
      public:
        enum Id { id_ = 3 };
        typedef TerminalCapabilitySetReject_cause_tableEntryCapacityExceeded value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tableEntryCapacityExceeded

    tableEntryCapacityExceeded::const_reference get_tableEntryCapacityExceeded () const;
    tableEntryCapacityExceeded::reference ref_tableEntryCapacityExceeded (); 
    tableEntryCapacityExceeded::reference select_tableEntryCapacityExceeded (); 
    tableEntryCapacityExceeded::reference select_tableEntryCapacityExceeded (tableEntryCapacityExceeded::const_reference value); 
    bool tableEntryCapacityExceeded_isSelected() const;

    TerminalCapabilitySetReject_cause(unspecified::Id id, unspecified::const_reference value);
    TerminalCapabilitySetReject_cause(undefinedTableEntryUsed::Id id, undefinedTableEntryUsed::const_reference value);
    TerminalCapabilitySetReject_cause(descriptorCapacityExceeded::Id id, descriptorCapacityExceeded::const_reference value);
    TerminalCapabilitySetReject_cause(tableEntryCapacityExceeded::Id id, tableEntryCapacityExceeded::const_reference value);
    void swap(TerminalCapabilitySetReject_cause & other);
    TerminalCapabilitySetReject_cause(const TerminalCapabilitySetReject_cause & other)
    : Inherited(other) {} 

    TerminalCapabilitySetReject_cause & operator = (const TerminalCapabilitySetReject_cause & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    TerminalCapabilitySetReject_cause * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// VCCapability_aal1ViaGateway
//

class VCCapability_aal1ViaGateway : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability_aal1ViaGateway(const void* info) : Inherited(info) {}
  public:
    VCCapability_aal1ViaGateway() : Inherited(&theInfo) {}
    VCCapability_aal1ViaGateway(const VCCapability_aal1ViaGateway & other) : Inherited(other)
    {}
    VCCapability_aal1ViaGateway& operator = (const VCCapability_aal1ViaGateway& other)
    { Inherited::operator = (other); return *this; } 
    class gatewayAddress {
      public:
        typedef ASN1::SET_OF<Q2931Address,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gatewayAddress
    gatewayAddress::const_reference get_gatewayAddress () const;
    gatewayAddress::reference ref_gatewayAddress ();
    gatewayAddress::reference set_gatewayAddress ();
    gatewayAddress::reference set_gatewayAddress (gatewayAddress::const_reference value);
    class nullClockRecovery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullClockRecovery
    nullClockRecovery::const_reference get_nullClockRecovery () const;
    nullClockRecovery::reference ref_nullClockRecovery ();
    nullClockRecovery::reference set_nullClockRecovery ();
    nullClockRecovery::reference set_nullClockRecovery (bool value);
    class srtsClockRecovery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class srtsClockRecovery
    srtsClockRecovery::const_reference get_srtsClockRecovery () const;
    srtsClockRecovery::reference ref_srtsClockRecovery ();
    srtsClockRecovery::reference set_srtsClockRecovery ();
    srtsClockRecovery::reference set_srtsClockRecovery (bool value);
    class adaptiveClockRecovery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class adaptiveClockRecovery
    adaptiveClockRecovery::const_reference get_adaptiveClockRecovery () const;
    adaptiveClockRecovery::reference ref_adaptiveClockRecovery ();
    adaptiveClockRecovery::reference set_adaptiveClockRecovery ();
    adaptiveClockRecovery::reference set_adaptiveClockRecovery (bool value);
    class nullErrorCorrection {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullErrorCorrection
    nullErrorCorrection::const_reference get_nullErrorCorrection () const;
    nullErrorCorrection::reference ref_nullErrorCorrection ();
    nullErrorCorrection::reference set_nullErrorCorrection ();
    nullErrorCorrection::reference set_nullErrorCorrection (bool value);
    class longInterleaver {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class longInterleaver
    longInterleaver::const_reference get_longInterleaver () const;
    longInterleaver::reference ref_longInterleaver ();
    longInterleaver::reference set_longInterleaver ();
    longInterleaver::reference set_longInterleaver (bool value);
    class shortInterleaver {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class shortInterleaver
    shortInterleaver::const_reference get_shortInterleaver () const;
    shortInterleaver::reference ref_shortInterleaver ();
    shortInterleaver::reference set_shortInterleaver ();
    shortInterleaver::reference set_shortInterleaver (bool value);
    class errorCorrectionOnly {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCorrectionOnly
    errorCorrectionOnly::const_reference get_errorCorrectionOnly () const;
    errorCorrectionOnly::reference ref_errorCorrectionOnly ();
    errorCorrectionOnly::reference set_errorCorrectionOnly ();
    errorCorrectionOnly::reference set_errorCorrectionOnly (bool value);
    class structuredDataTransfer {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class structuredDataTransfer
    structuredDataTransfer::const_reference get_structuredDataTransfer () const;
    structuredDataTransfer::reference ref_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer (bool value);
    class partiallyFilledCells {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class partiallyFilledCells
    partiallyFilledCells::const_reference get_partiallyFilledCells () const;
    partiallyFilledCells::reference ref_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells (bool value);
    void swap(VCCapability_aal1ViaGateway& other);
    VCCapability_aal1ViaGateway * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[10];
    static int fieldIds[10];
    static const char* fieldNames[10];
};

//
// H223Capability_h223MultiplexTableCapability
//

class H223Capability_h223MultiplexTableCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223Capability_h223MultiplexTableCapability(const void* info) : Inherited(info) {}
  public:
    H223Capability_h223MultiplexTableCapability() : Inherited(&theInfo) {}
    class basic {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class basic

    basic::reference select_basic (); 
    bool basic_isSelected() const;

    class enhanced {
      public:
        enum Id { id_ = 1 };
        typedef H223Capability_h223MultiplexTableCapability_enhanced value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enhanced

    enhanced::const_reference get_enhanced () const;
    enhanced::reference ref_enhanced (); 
    enhanced::reference select_enhanced (); 
    enhanced::reference select_enhanced (enhanced::const_reference value); 
    bool enhanced_isSelected() const;

    H223Capability_h223MultiplexTableCapability(basic::Id id, basic::const_reference value);
    H223Capability_h223MultiplexTableCapability(enhanced::Id id, enhanced::const_reference value);
    void swap(H223Capability_h223MultiplexTableCapability & other);
    H223Capability_h223MultiplexTableCapability(const H223Capability_h223MultiplexTableCapability & other)
    : Inherited(other) {} 

    H223Capability_h223MultiplexTableCapability & operator = (const H223Capability_h223MultiplexTableCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223Capability_h223MultiplexTableCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// RTPH263VideoRedundancyEncoding_frameToThreadMapping
//

class RTPH263VideoRedundancyEncoding_frameToThreadMapping : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RTPH263VideoRedundancyEncoding_frameToThreadMapping(const void* info) : Inherited(info) {}
  public:
    RTPH263VideoRedundancyEncoding_frameToThreadMapping() : Inherited(&theInfo) {}
    class roundrobin {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class roundrobin

    roundrobin::reference select_roundrobin (); 
    bool roundrobin_isSelected() const;

    class custom {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::SEQUENCE_OF<RTPH263VideoRedundancyFrameMapping,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class custom

    custom::const_reference get_custom () const;
    custom::reference ref_custom (); 
    custom::reference select_custom (); 
    custom::reference select_custom (custom::const_reference value); 
    bool custom_isSelected() const;

    RTPH263VideoRedundancyEncoding_frameToThreadMapping(roundrobin::Id id, roundrobin::const_reference value);
    RTPH263VideoRedundancyEncoding_frameToThreadMapping(custom::Id id, custom::const_reference value);
    void swap(RTPH263VideoRedundancyEncoding_frameToThreadMapping & other);
    RTPH263VideoRedundancyEncoding_frameToThreadMapping(const RTPH263VideoRedundancyEncoding_frameToThreadMapping & other)
    : Inherited(other) {} 

    RTPH263VideoRedundancyEncoding_frameToThreadMapping & operator = (const RTPH263VideoRedundancyEncoding_frameToThreadMapping & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RTPH263VideoRedundancyEncoding_frameToThreadMapping * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// RefPictureSelection_enhancedReferencePicSelect
//

class RefPictureSelection_enhancedReferencePicSelect : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RefPictureSelection_enhancedReferencePicSelect(const void* info) : Inherited(info) {}
  public:
    RefPictureSelection_enhancedReferencePicSelect() : Inherited(&theInfo) {}
    RefPictureSelection_enhancedReferencePicSelect(const RefPictureSelection_enhancedReferencePicSelect & other) : Inherited(other)
    {}
    RefPictureSelection_enhancedReferencePicSelect& operator = (const RefPictureSelection_enhancedReferencePicSelect& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_subPictureRemovalParameters
    };

    class subPictureRemovalParameters {
      public:
        typedef RefPictureSelection_enhancedReferencePicSelect_subPictureRemovalParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subPictureRemovalParameters
    subPictureRemovalParameters::const_reference get_subPictureRemovalParameters () const;
    subPictureRemovalParameters::reference ref_subPictureRemovalParameters ();
    subPictureRemovalParameters::reference set_subPictureRemovalParameters ();
    subPictureRemovalParameters::reference set_subPictureRemovalParameters (subPictureRemovalParameters::const_reference value);
    void omit_subPictureRemovalParameters ();
    bool subPictureRemovalParameters_isPresent () const;
    void swap(RefPictureSelection_enhancedReferencePicSelect& other);
    RefPictureSelection_enhancedReferencePicSelect * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// DataProtocolCapability_v76wCompression
//

class DataProtocolCapability_v76wCompression : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataProtocolCapability_v76wCompression(const void* info) : Inherited(info) {}
  public:
    DataProtocolCapability_v76wCompression() : Inherited(&theInfo) {}
    class transmitCompression {
      public:
        enum Id { id_ = 0 };
        typedef CompressionType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitCompression

    transmitCompression::const_reference get_transmitCompression () const;
    transmitCompression::reference ref_transmitCompression (); 
    transmitCompression::reference select_transmitCompression (); 
    transmitCompression::reference select_transmitCompression (transmitCompression::const_reference value); 
    bool transmitCompression_isSelected() const;

    class receiveCompression {
      public:
        enum Id { id_ = 1 };
        typedef CompressionType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveCompression

    receiveCompression::const_reference get_receiveCompression () const;
    receiveCompression::reference ref_receiveCompression (); 
    receiveCompression::reference select_receiveCompression (); 
    receiveCompression::reference select_receiveCompression (receiveCompression::const_reference value); 
    bool receiveCompression_isSelected() const;

    class transmitAndReceiveCompression {
      public:
        enum Id { id_ = 2 };
        typedef CompressionType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitAndReceiveCompression

    transmitAndReceiveCompression::const_reference get_transmitAndReceiveCompression () const;
    transmitAndReceiveCompression::reference ref_transmitAndReceiveCompression (); 
    transmitAndReceiveCompression::reference select_transmitAndReceiveCompression (); 
    transmitAndReceiveCompression::reference select_transmitAndReceiveCompression (transmitAndReceiveCompression::const_reference value); 
    bool transmitAndReceiveCompression_isSelected() const;

    DataProtocolCapability_v76wCompression(transmitCompression::Id id, transmitCompression::const_reference value);
    DataProtocolCapability_v76wCompression(receiveCompression::Id id, receiveCompression::const_reference value);
    DataProtocolCapability_v76wCompression(transmitAndReceiveCompression::Id id, transmitAndReceiveCompression::const_reference value);
    void swap(DataProtocolCapability_v76wCompression & other);
    DataProtocolCapability_v76wCompression(const DataProtocolCapability_v76wCompression & other)
    : Inherited(other) {} 

    DataProtocolCapability_v76wCompression & operator = (const DataProtocolCapability_v76wCompression & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DataProtocolCapability_v76wCompression * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// DepFECCapability_rfc2733
//

class DepFECCapability_rfc2733 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECCapability_rfc2733(const void* info) : Inherited(info) {}
  public:
    DepFECCapability_rfc2733() : Inherited(&theInfo) {}
    DepFECCapability_rfc2733(const DepFECCapability_rfc2733 & other) : Inherited(other)
    {}
    DepFECCapability_rfc2733& operator = (const DepFECCapability_rfc2733& other)
    { Inherited::operator = (other); return *this; } 
    class redundancyEncoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncoding
    redundancyEncoding::const_reference get_redundancyEncoding () const;
    redundancyEncoding::reference ref_redundancyEncoding ();
    redundancyEncoding::reference set_redundancyEncoding ();
    redundancyEncoding::reference set_redundancyEncoding (bool value);
    class separateStream {
      public:
        typedef DepFECCapability_rfc2733_separateStream value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateStream
    separateStream::const_reference get_separateStream () const;
    separateStream::reference ref_separateStream ();
    separateStream::reference set_separateStream ();
    separateStream::reference set_separateStream (separateStream::const_reference value);
    void swap(DepFECCapability_rfc2733& other);
    DepFECCapability_rfc2733 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223AL1MParameters_arqType
//

class H223AL1MParameters_arqType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL1MParameters_arqType(const void* info) : Inherited(info) {}
  public:
    H223AL1MParameters_arqType() : Inherited(&theInfo) {}
    class noArq {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noArq

    noArq::reference select_noArq (); 
    bool noArq_isSelected() const;

    class typeIArq {
      public:
        enum Id { id_ = 1 };
        typedef H223AnnexCArqParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class typeIArq

    typeIArq::const_reference get_typeIArq () const;
    typeIArq::reference ref_typeIArq (); 
    typeIArq::reference select_typeIArq (); 
    typeIArq::reference select_typeIArq (typeIArq::const_reference value); 
    bool typeIArq_isSelected() const;

    class typeIIArq {
      public:
        enum Id { id_ = 2 };
        typedef H223AnnexCArqParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class typeIIArq

    typeIIArq::const_reference get_typeIIArq () const;
    typeIIArq::reference ref_typeIIArq (); 
    typeIIArq::reference select_typeIIArq (); 
    typeIIArq::reference select_typeIIArq (typeIIArq::const_reference value); 
    bool typeIIArq_isSelected() const;

    H223AL1MParameters_arqType(noArq::Id id, noArq::const_reference value);
    H223AL1MParameters_arqType(typeIArq::Id id, typeIArq::const_reference value);
    H223AL1MParameters_arqType(typeIIArq::Id id, typeIIArq::const_reference value);
    void swap(H223AL1MParameters_arqType & other);
    H223AL1MParameters_arqType(const H223AL1MParameters_arqType & other)
    : Inherited(other) {} 

    H223AL1MParameters_arqType & operator = (const H223AL1MParameters_arqType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL1MParameters_arqType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// H223AL3MParameters_arqType
//

class H223AL3MParameters_arqType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL3MParameters_arqType(const void* info) : Inherited(info) {}
  public:
    H223AL3MParameters_arqType() : Inherited(&theInfo) {}
    class noArq {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class noArq

    noArq::reference select_noArq (); 
    bool noArq_isSelected() const;

    class typeIArq {
      public:
        enum Id { id_ = 1 };
        typedef H223AnnexCArqParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class typeIArq

    typeIArq::const_reference get_typeIArq () const;
    typeIArq::reference ref_typeIArq (); 
    typeIArq::reference select_typeIArq (); 
    typeIArq::reference select_typeIArq (typeIArq::const_reference value); 
    bool typeIArq_isSelected() const;

    class typeIIArq {
      public:
        enum Id { id_ = 2 };
        typedef H223AnnexCArqParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class typeIIArq

    typeIIArq::const_reference get_typeIIArq () const;
    typeIIArq::reference ref_typeIIArq (); 
    typeIIArq::reference select_typeIIArq (); 
    typeIIArq::reference select_typeIIArq (typeIIArq::const_reference value); 
    bool typeIIArq_isSelected() const;

    H223AL3MParameters_arqType(noArq::Id id, noArq::const_reference value);
    H223AL3MParameters_arqType(typeIArq::Id id, typeIArq::const_reference value);
    H223AL3MParameters_arqType(typeIIArq::Id id, typeIIArq::const_reference value);
    void swap(H223AL3MParameters_arqType & other);
    H223AL3MParameters_arqType(const H223AL3MParameters_arqType & other)
    : Inherited(other) {} 

    H223AL3MParameters_arqType & operator = (const H223AL3MParameters_arqType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223AL3MParameters_arqType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// UnicastAddress_iPSourceRouteAddress
//

class UnicastAddress_iPSourceRouteAddress : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UnicastAddress_iPSourceRouteAddress(const void* info) : Inherited(info) {}
  public:
    UnicastAddress_iPSourceRouteAddress() : Inherited(&theInfo) {}
    UnicastAddress_iPSourceRouteAddress(const UnicastAddress_iPSourceRouteAddress & other) : Inherited(other)
    {}
    UnicastAddress_iPSourceRouteAddress& operator = (const UnicastAddress_iPSourceRouteAddress& other)
    { Inherited::operator = (other); return *this; } 
    class routing {
      public:
        typedef UnicastAddress_iPSourceRouteAddress_routing value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class routing
    routing::const_reference get_routing () const;
    routing::reference ref_routing ();
    routing::reference set_routing ();
    routing::reference set_routing (routing::const_reference value);
    class network {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 4, 4> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class network
    network::const_reference get_network () const;
    network::reference ref_network ();
    network::reference set_network ();
    network::reference set_network (const std::vector<char>& value);
    class tsapIdentifier {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tsapIdentifier
    tsapIdentifier::const_reference get_tsapIdentifier () const;
    tsapIdentifier::reference ref_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier ();
    tsapIdentifier::reference set_tsapIdentifier (tsapIdentifier::value_type::int_type value);
    class route {
      public:
        typedef UnicastAddress_iPSourceRouteAddress_route value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class route
    route::const_reference get_route () const;
    route::reference ref_route ();
    route::reference set_route ();
    route::reference set_route (route::const_reference value);
    void swap(UnicastAddress_iPSourceRouteAddress& other);
    UnicastAddress_iPSourceRouteAddress * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// MultiplexElement_type
//

class MultiplexElement_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexElement_type(const void* info) : Inherited(info) {}
  public:
    MultiplexElement_type() : Inherited(&theInfo) {}
    class logicalChannelNumber {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber

    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (); 
    logicalChannelNumber::reference select_logicalChannelNumber (logicalChannelNumber::value_type::int_type value); 
    bool logicalChannelNumber_isSelected() const;

    class subElementList {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::SEQUENCE_OF<MultiplexElement,  ASN1::SizeConstraint<ASN1::FixedConstraint, 2, 255> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subElementList

    subElementList::const_reference get_subElementList () const;
    subElementList::reference ref_subElementList (); 
    subElementList::reference select_subElementList (); 
    subElementList::reference select_subElementList (subElementList::const_reference value); 
    bool subElementList_isSelected() const;

    MultiplexElement_type(logicalChannelNumber::Id id, logicalChannelNumber::value_type::int_type value);
    MultiplexElement_type(subElementList::Id id, subElementList::const_reference value);
    void swap(MultiplexElement_type & other);
    MultiplexElement_type(const MultiplexElement_type & other)
    : Inherited(other) {} 

    MultiplexElement_type & operator = (const MultiplexElement_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultiplexElement_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// ConferenceRequest_requestTerminalCertificate
//

class ConferenceRequest_requestTerminalCertificate : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceRequest_requestTerminalCertificate(const void* info) : Inherited(info) {}
  public:
    ConferenceRequest_requestTerminalCertificate() : Inherited(&theInfo) {}
    ConferenceRequest_requestTerminalCertificate(const ConferenceRequest_requestTerminalCertificate & other) : Inherited(other)
    {}
    ConferenceRequest_requestTerminalCertificate& operator = (const ConferenceRequest_requestTerminalCertificate& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_terminalLabel,
      e_certSelectionCriteria,
      e_sRandom
    };

    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    void omit_terminalLabel ();
    bool terminalLabel_isPresent () const;
    class certSelectionCriteria {
      public:
        typedef CertSelectionCriteria value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class certSelectionCriteria
    certSelectionCriteria::const_reference get_certSelectionCriteria () const;
    certSelectionCriteria::reference ref_certSelectionCriteria ();
    certSelectionCriteria::reference set_certSelectionCriteria ();
    certSelectionCriteria::reference set_certSelectionCriteria (certSelectionCriteria::const_reference value);
    void omit_certSelectionCriteria ();
    bool certSelectionCriteria_isPresent () const;
    class sRandom {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sRandom
    sRandom::const_reference get_sRandom () const;
    sRandom::reference ref_sRandom ();
    sRandom::reference set_sRandom ();
    sRandom::reference set_sRandom (sRandom::value_type::int_type value);
    void omit_sRandom ();
    bool sRandom_isPresent () const;
    void swap(ConferenceRequest_requestTerminalCertificate& other);
    ConferenceRequest_requestTerminalCertificate * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// ConferenceResponse_mCTerminalIDResponse
//

class ConferenceResponse_mCTerminalIDResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_mCTerminalIDResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_mCTerminalIDResponse() : Inherited(&theInfo) {}
    ConferenceResponse_mCTerminalIDResponse(const ConferenceResponse_mCTerminalIDResponse & other) : Inherited(other)
    {}
    ConferenceResponse_mCTerminalIDResponse& operator = (const ConferenceResponse_mCTerminalIDResponse& other)
    { Inherited::operator = (other); return *this; } 
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    class terminalID {
      public:
        typedef TerminalID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalID
    terminalID::const_reference get_terminalID () const;
    terminalID::reference ref_terminalID ();
    terminalID::reference set_terminalID ();
    terminalID::reference set_terminalID (const std::vector<char>& value);
    void swap(ConferenceResponse_mCTerminalIDResponse& other);
    ConferenceResponse_mCTerminalIDResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceResponse_terminalIDResponse
//

class ConferenceResponse_terminalIDResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_terminalIDResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_terminalIDResponse() : Inherited(&theInfo) {}
    ConferenceResponse_terminalIDResponse(const ConferenceResponse_terminalIDResponse & other) : Inherited(other)
    {}
    ConferenceResponse_terminalIDResponse& operator = (const ConferenceResponse_terminalIDResponse& other)
    { Inherited::operator = (other); return *this; } 
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    class terminalID {
      public:
        typedef TerminalID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalID
    terminalID::const_reference get_terminalID () const;
    terminalID::reference ref_terminalID ();
    terminalID::reference set_terminalID ();
    terminalID::reference set_terminalID (const std::vector<char>& value);
    void swap(ConferenceResponse_terminalIDResponse& other);
    ConferenceResponse_terminalIDResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceResponse_conferenceIDResponse
//

class ConferenceResponse_conferenceIDResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_conferenceIDResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_conferenceIDResponse() : Inherited(&theInfo) {}
    ConferenceResponse_conferenceIDResponse(const ConferenceResponse_conferenceIDResponse & other) : Inherited(other)
    {}
    ConferenceResponse_conferenceIDResponse& operator = (const ConferenceResponse_conferenceIDResponse& other)
    { Inherited::operator = (other); return *this; } 
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    class conferenceID {
      public:
        typedef ConferenceID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceID
    conferenceID::const_reference get_conferenceID () const;
    conferenceID::reference ref_conferenceID ();
    conferenceID::reference set_conferenceID ();
    conferenceID::reference set_conferenceID (const std::vector<char>& value);
    void swap(ConferenceResponse_conferenceIDResponse& other);
    ConferenceResponse_conferenceIDResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceResponse_passwordResponse
//

class ConferenceResponse_passwordResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_passwordResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_passwordResponse() : Inherited(&theInfo) {}
    ConferenceResponse_passwordResponse(const ConferenceResponse_passwordResponse & other) : Inherited(other)
    {}
    ConferenceResponse_passwordResponse& operator = (const ConferenceResponse_passwordResponse& other)
    { Inherited::operator = (other); return *this; } 
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    class password {
      public:
        typedef Password value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class password
    password::const_reference get_password () const;
    password::reference ref_password ();
    password::reference set_password ();
    password::reference set_password (const std::vector<char>& value);
    void swap(ConferenceResponse_passwordResponse& other);
    ConferenceResponse_passwordResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceResponse_chairTokenOwnerResponse
//

class ConferenceResponse_chairTokenOwnerResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_chairTokenOwnerResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_chairTokenOwnerResponse() : Inherited(&theInfo) {}
    ConferenceResponse_chairTokenOwnerResponse(const ConferenceResponse_chairTokenOwnerResponse & other) : Inherited(other)
    {}
    ConferenceResponse_chairTokenOwnerResponse& operator = (const ConferenceResponse_chairTokenOwnerResponse& other)
    { Inherited::operator = (other); return *this; } 
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    class terminalID {
      public:
        typedef TerminalID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalID
    terminalID::const_reference get_terminalID () const;
    terminalID::reference ref_terminalID ();
    terminalID::reference set_terminalID ();
    terminalID::reference set_terminalID (const std::vector<char>& value);
    void swap(ConferenceResponse_chairTokenOwnerResponse& other);
    ConferenceResponse_chairTokenOwnerResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceResponse_terminalCertificateResponse
//

class ConferenceResponse_terminalCertificateResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse_terminalCertificateResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse_terminalCertificateResponse() : Inherited(&theInfo) {}
    ConferenceResponse_terminalCertificateResponse(const ConferenceResponse_terminalCertificateResponse & other) : Inherited(other)
    {}
    ConferenceResponse_terminalCertificateResponse& operator = (const ConferenceResponse_terminalCertificateResponse& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_terminalLabel,
      e_certificateResponse
    };

    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    void omit_terminalLabel ();
    bool terminalLabel_isPresent () const;
    class certificateResponse {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 65535> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class certificateResponse
    certificateResponse::const_reference get_certificateResponse () const;
    certificateResponse::reference ref_certificateResponse ();
    certificateResponse::reference set_certificateResponse ();
    certificateResponse::reference set_certificateResponse (const std::vector<char>& value);
    void omit_certificateResponse ();
    bool certificateResponse_isPresent () const;
    void swap(ConferenceResponse_terminalCertificateResponse& other);
    ConferenceResponse_terminalCertificateResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultilinkRequest_maximumHeaderInterval
//

class MultilinkRequest_maximumHeaderInterval : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkRequest_maximumHeaderInterval(const void* info) : Inherited(info) {}
  public:
    MultilinkRequest_maximumHeaderInterval() : Inherited(&theInfo) {}
    MultilinkRequest_maximumHeaderInterval(const MultilinkRequest_maximumHeaderInterval & other) : Inherited(other)
    {}
    MultilinkRequest_maximumHeaderInterval& operator = (const MultilinkRequest_maximumHeaderInterval& other)
    { Inherited::operator = (other); return *this; } 
    class requestType {
      public:
        typedef MultilinkRequest_maximumHeaderInterval_requestType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestType
    requestType::const_reference get_requestType () const;
    requestType::reference ref_requestType ();
    requestType::reference set_requestType ();
    requestType::reference set_requestType (requestType::const_reference value);
    void swap(MultilinkRequest_maximumHeaderInterval& other);
    MultilinkRequest_maximumHeaderInterval * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NewATMVCCommand_reverseParameters
//

class NewATMVCCommand_reverseParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_reverseParameters(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_reverseParameters() : Inherited(&theInfo) {}
    NewATMVCCommand_reverseParameters(const NewATMVCCommand_reverseParameters & other) : Inherited(other)
    {}
    NewATMVCCommand_reverseParameters& operator = (const NewATMVCCommand_reverseParameters& other)
    { Inherited::operator = (other); return *this; } 
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    class bitRateLockedToPCRClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToPCRClock
    bitRateLockedToPCRClock::const_reference get_bitRateLockedToPCRClock () const;
    bitRateLockedToPCRClock::reference ref_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock (bool value);
    class bitRateLockedToNetworkClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToNetworkClock
    bitRateLockedToNetworkClock::const_reference get_bitRateLockedToNetworkClock () const;
    bitRateLockedToNetworkClock::reference ref_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock (bool value);
    class multiplex {
      public:
        typedef NewATMVCCommand_reverseParameters_multiplex value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplex
    multiplex::const_reference get_multiplex () const;
    multiplex::reference ref_multiplex ();
    multiplex::reference set_multiplex ();
    multiplex::reference set_multiplex (multiplex::const_reference value);
    void swap(NewATMVCCommand_reverseParameters& other);
    NewATMVCCommand_reverseParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// NewATMVCIndication_reverseParameters
//

class NewATMVCIndication_reverseParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_reverseParameters(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_reverseParameters() : Inherited(&theInfo) {}
    NewATMVCIndication_reverseParameters(const NewATMVCIndication_reverseParameters & other) : Inherited(other)
    {}
    NewATMVCIndication_reverseParameters& operator = (const NewATMVCIndication_reverseParameters& other)
    { Inherited::operator = (other); return *this; } 
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    class bitRateLockedToPCRClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToPCRClock
    bitRateLockedToPCRClock::const_reference get_bitRateLockedToPCRClock () const;
    bitRateLockedToPCRClock::reference ref_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock (bool value);
    class bitRateLockedToNetworkClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToNetworkClock
    bitRateLockedToNetworkClock::const_reference get_bitRateLockedToNetworkClock () const;
    bitRateLockedToNetworkClock::reference ref_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock (bool value);
    class multiplex {
      public:
        typedef NewATMVCIndication_reverseParameters_multiplex value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplex
    multiplex::const_reference get_multiplex () const;
    multiplex::reference ref_multiplex ();
    multiplex::reference set_multiplex ();
    multiplex::reference set_multiplex (multiplex::const_reference value);
    void swap(NewATMVCIndication_reverseParameters& other);
    NewATMVCIndication_reverseParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// UserInputIndication_signal
//

class UserInputIndication_signal : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_signal(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_signal() : Inherited(&theInfo) {}
    UserInputIndication_signal(const UserInputIndication_signal & other) : Inherited(other)
    {}
    UserInputIndication_signal& operator = (const UserInputIndication_signal& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_duration,
      e_rtp,
      e_rtpPayloadIndication,
      e_paramS,
      e_encryptedSignalType,
      e_algorithmOID
    };

    class signalType {
      public:
        class value_type : public ASN1::IA5String
        {
            typedef ASN1::IA5String Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class signalType
    signalType::const_reference get_signalType () const;
    signalType::reference ref_signalType ();
    signalType::reference set_signalType ();
    signalType::reference set_signalType (const std::string& value);
    class duration {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class duration
    duration::const_reference get_duration () const;
    duration::reference ref_duration ();
    duration::reference set_duration ();
    duration::reference set_duration (duration::value_type::int_type value);
    void omit_duration ();
    bool duration_isPresent () const;
    class rtp {
      public:
        typedef UserInputIndication_signal_rtp value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtp
    rtp::const_reference get_rtp () const;
    rtp::reference ref_rtp ();
    rtp::reference set_rtp ();
    rtp::reference set_rtp (rtp::const_reference value);
    void omit_rtp ();
    bool rtp_isPresent () const;
    class rtpPayloadIndication {
      public:
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtpPayloadIndication
    rtpPayloadIndication::reference set_rtpPayloadIndication ();
    void omit_rtpPayloadIndication ();
    bool rtpPayloadIndication_isPresent () const;
    class paramS {
      public:
        typedef Params value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class paramS
    paramS::const_reference get_paramS () const;
    paramS::reference ref_paramS ();
    paramS::reference set_paramS ();
    paramS::reference set_paramS (paramS::const_reference value);
    void omit_paramS ();
    bool paramS_isPresent () const;
    class encryptedSignalType {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 1> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedSignalType
    encryptedSignalType::const_reference get_encryptedSignalType () const;
    encryptedSignalType::reference ref_encryptedSignalType ();
    encryptedSignalType::reference set_encryptedSignalType ();
    encryptedSignalType::reference set_encryptedSignalType (const std::vector<char>& value);
    void omit_encryptedSignalType ();
    bool encryptedSignalType_isPresent () const;
    class algorithmOID {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class algorithmOID
    algorithmOID::const_reference get_algorithmOID () const;
    algorithmOID::reference ref_algorithmOID ();
    algorithmOID::reference set_algorithmOID ();
    algorithmOID::reference set_algorithmOID (algorithmOID::const_reference value);
    void omit_algorithmOID ();
    bool algorithmOID_isPresent () const;
    void swap(UserInputIndication_signal& other);
    UserInputIndication_signal * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* fieldNames[7];
};

//
// UserInputIndication_signalUpdate
//

class UserInputIndication_signalUpdate : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_signalUpdate(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_signalUpdate() : Inherited(&theInfo) {}
    UserInputIndication_signalUpdate(const UserInputIndication_signalUpdate & other) : Inherited(other)
    {}
    UserInputIndication_signalUpdate& operator = (const UserInputIndication_signalUpdate& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_rtp
    };

    class duration {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class duration
    duration::const_reference get_duration () const;
    duration::reference ref_duration ();
    duration::reference set_duration ();
    duration::reference set_duration (duration::value_type::int_type value);
    class rtp {
      public:
        typedef UserInputIndication_signalUpdate_rtp value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtp
    rtp::const_reference get_rtp () const;
    rtp::reference ref_rtp ();
    rtp::reference set_rtp ();
    rtp::reference set_rtp (rtp::const_reference value);
    void omit_rtp ();
    bool rtp_isPresent () const;
    void swap(UserInputIndication_signalUpdate& other);
    UserInputIndication_signalUpdate * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// UserInputIndication_extendedAlphanumeric
//

class UserInputIndication_extendedAlphanumeric : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_extendedAlphanumeric(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_extendedAlphanumeric() : Inherited(&theInfo) {}
    UserInputIndication_extendedAlphanumeric(const UserInputIndication_extendedAlphanumeric & other) : Inherited(other)
    {}
    UserInputIndication_extendedAlphanumeric& operator = (const UserInputIndication_extendedAlphanumeric& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_rtpPayloadIndication,
      e_encryptedAlphanumeric
    };

    class alphanumeric {
      public:
        typedef ASN1::GeneralString value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alphanumeric
    alphanumeric::const_reference get_alphanumeric () const;
    alphanumeric::reference ref_alphanumeric ();
    alphanumeric::reference set_alphanumeric ();
    alphanumeric::reference set_alphanumeric (const std::string& value);
    class rtpPayloadIndication {
      public:
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtpPayloadIndication
    rtpPayloadIndication::reference set_rtpPayloadIndication ();
    void omit_rtpPayloadIndication ();
    bool rtpPayloadIndication_isPresent () const;
    class encryptedAlphanumeric {
      public:
        typedef UserInputIndication_extendedAlphanumeric_encryptedAlphanumeric value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedAlphanumeric
    encryptedAlphanumeric::const_reference get_encryptedAlphanumeric () const;
    encryptedAlphanumeric::reference ref_encryptedAlphanumeric ();
    encryptedAlphanumeric::reference set_encryptedAlphanumeric ();
    encryptedAlphanumeric::reference set_encryptedAlphanumeric (encryptedAlphanumeric::const_reference value);
    void omit_encryptedAlphanumeric ();
    bool encryptedAlphanumeric_isPresent () const;
    void swap(UserInputIndication_extendedAlphanumeric& other);
    UserInputIndication_extendedAlphanumeric * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// VCCapability_availableBitRates_type
//

class VCCapability_availableBitRates_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability_availableBitRates_type(const void* info) : Inherited(info) {}
  public:
    VCCapability_availableBitRates_type() : Inherited(&theInfo) {}
    class singleBitRate {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class singleBitRate

    singleBitRate::const_reference get_singleBitRate () const;
    singleBitRate::reference ref_singleBitRate (); 
    singleBitRate::reference select_singleBitRate (); 
    singleBitRate::reference select_singleBitRate (singleBitRate::value_type::int_type value); 
    bool singleBitRate_isSelected() const;

    class rangeOfBitRates {
      public:
        enum Id { id_ = 1 };
        typedef VCCapability_availableBitRates_type_rangeOfBitRates value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rangeOfBitRates

    rangeOfBitRates::const_reference get_rangeOfBitRates () const;
    rangeOfBitRates::reference ref_rangeOfBitRates (); 
    rangeOfBitRates::reference select_rangeOfBitRates (); 
    rangeOfBitRates::reference select_rangeOfBitRates (rangeOfBitRates::const_reference value); 
    bool rangeOfBitRates_isSelected() const;

    VCCapability_availableBitRates_type(singleBitRate::Id id, singleBitRate::value_type::int_type value);
    VCCapability_availableBitRates_type(rangeOfBitRates::Id id, rangeOfBitRates::const_reference value);
    void swap(VCCapability_availableBitRates_type & other);
    VCCapability_availableBitRates_type(const VCCapability_availableBitRates_type & other)
    : Inherited(other) {} 

    VCCapability_availableBitRates_type & operator = (const VCCapability_availableBitRates_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    VCCapability_availableBitRates_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

typedef ASN1::SET_OF<CustomPictureFormat_mPI_customPCF_subtype,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  CustomPictureFormat_mPI_customPCF;

typedef ASN1::SET_OF<CustomPictureFormat_pixelAspectInformation_extendedPAR_subtype,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  CustomPictureFormat_pixelAspectInformation_extendedPAR;

//
// V76LogicalChannelParameters_mode_eRM
//

class V76LogicalChannelParameters_mode_eRM : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76LogicalChannelParameters_mode_eRM(const void* info) : Inherited(info) {}
  public:
    V76LogicalChannelParameters_mode_eRM() : Inherited(&theInfo) {}
    V76LogicalChannelParameters_mode_eRM(const V76LogicalChannelParameters_mode_eRM & other) : Inherited(other)
    {}
    V76LogicalChannelParameters_mode_eRM& operator = (const V76LogicalChannelParameters_mode_eRM& other)
    { Inherited::operator = (other); return *this; } 
    class windowSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class windowSize
    windowSize::const_reference get_windowSize () const;
    windowSize::reference ref_windowSize ();
    windowSize::reference set_windowSize ();
    windowSize::reference set_windowSize (windowSize::value_type::int_type value);
    class recovery {
      public:
        typedef V76LogicalChannelParameters_mode_eRM_recovery value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class recovery
    recovery::const_reference get_recovery () const;
    recovery::reference ref_recovery ();
    recovery::reference set_recovery ();
    recovery::reference set_recovery (recovery::const_reference value);
    void swap(V76LogicalChannelParameters_mode_eRM& other);
    V76LogicalChannelParameters_mode_eRM * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// FECData_rfc2733_pktMode
//

class FECData_rfc2733_pktMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECData_rfc2733_pktMode(const void* info) : Inherited(info) {}
  public:
    FECData_rfc2733_pktMode() : Inherited(&theInfo) {}
    class rfc2198coding {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2198coding

    rfc2198coding::reference select_rfc2198coding (); 
    bool rfc2198coding_isSelected() const;

    class rfc2733sameport {
      public:
        enum Id { id_ = 1 };
        typedef FECData_rfc2733_pktMode_rfc2733sameport value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733sameport

    rfc2733sameport::const_reference get_rfc2733sameport () const;
    rfc2733sameport::reference ref_rfc2733sameport (); 
    rfc2733sameport::reference select_rfc2733sameport (); 
    rfc2733sameport::reference select_rfc2733sameport (rfc2733sameport::const_reference value); 
    bool rfc2733sameport_isSelected() const;

    class rfc2733diffport {
      public:
        enum Id { id_ = 2 };
        typedef FECData_rfc2733_pktMode_rfc2733diffport value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733diffport

    rfc2733diffport::const_reference get_rfc2733diffport () const;
    rfc2733diffport::reference ref_rfc2733diffport (); 
    rfc2733diffport::reference select_rfc2733diffport (); 
    rfc2733diffport::reference select_rfc2733diffport (rfc2733diffport::const_reference value); 
    bool rfc2733diffport_isSelected() const;

    FECData_rfc2733_pktMode(rfc2198coding::Id id, rfc2198coding::const_reference value);
    FECData_rfc2733_pktMode(rfc2733sameport::Id id, rfc2733sameport::const_reference value);
    FECData_rfc2733_pktMode(rfc2733diffport::Id id, rfc2733diffport::const_reference value);
    void swap(FECData_rfc2733_pktMode & other);
    FECData_rfc2733_pktMode(const FECData_rfc2733_pktMode & other)
    : Inherited(other) {} 

    FECData_rfc2733_pktMode & operator = (const FECData_rfc2733_pktMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FECData_rfc2733_pktMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MultilinkResponse_addConnection_responseCode
//

class MultilinkResponse_addConnection_responseCode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse_addConnection_responseCode(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse_addConnection_responseCode() : Inherited(&theInfo) {}
    class accepted {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class accepted

    accepted::reference select_accepted (); 
    bool accepted_isSelected() const;

    class rejected {
      public:
        enum Id { id_ = 1 };
        typedef MultilinkResponse_addConnection_responseCode_rejected value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rejected

    rejected::const_reference get_rejected () const;
    rejected::reference ref_rejected (); 
    rejected::reference select_rejected (); 
    rejected::reference select_rejected (rejected::const_reference value); 
    bool rejected_isSelected() const;

    MultilinkResponse_addConnection_responseCode(accepted::Id id, accepted::const_reference value);
    MultilinkResponse_addConnection_responseCode(rejected::Id id, rejected::const_reference value);
    void swap(MultilinkResponse_addConnection_responseCode & other);
    MultilinkResponse_addConnection_responseCode(const MultilinkResponse_addConnection_responseCode & other)
    : Inherited(other) {} 

    MultilinkResponse_addConnection_responseCode & operator = (const MultilinkResponse_addConnection_responseCode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultilinkResponse_addConnection_responseCode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MiscellaneousCommand_type_progressiveRefinementStart
//

class MiscellaneousCommand_type_progressiveRefinementStart : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_progressiveRefinementStart(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_progressiveRefinementStart() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_progressiveRefinementStart(const MiscellaneousCommand_type_progressiveRefinementStart & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_progressiveRefinementStart& operator = (const MiscellaneousCommand_type_progressiveRefinementStart& other)
    { Inherited::operator = (other); return *this; } 
    class repeatCount {
      public:
        typedef MiscellaneousCommand_type_progressiveRefinementStart_repeatCount value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class repeatCount
    repeatCount::const_reference get_repeatCount () const;
    repeatCount::reference ref_repeatCount ();
    repeatCount::reference set_repeatCount ();
    repeatCount::reference set_repeatCount (repeatCount::const_reference value);
    void swap(MiscellaneousCommand_type_progressiveRefinementStart& other);
    MiscellaneousCommand_type_progressiveRefinementStart * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NewATMVCCommand_aal_aal1
//

class NewATMVCCommand_aal_aal1 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_aal_aal1(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_aal_aal1() : Inherited(&theInfo) {}
    NewATMVCCommand_aal_aal1(const NewATMVCCommand_aal_aal1 & other) : Inherited(other)
    {}
    NewATMVCCommand_aal_aal1& operator = (const NewATMVCCommand_aal_aal1& other)
    { Inherited::operator = (other); return *this; } 
    class clockRecovery {
      public:
        typedef NewATMVCCommand_aal_aal1_clockRecovery value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class clockRecovery
    clockRecovery::const_reference get_clockRecovery () const;
    clockRecovery::reference ref_clockRecovery ();
    clockRecovery::reference set_clockRecovery ();
    clockRecovery::reference set_clockRecovery (clockRecovery::const_reference value);
    class errorCorrection {
      public:
        typedef NewATMVCCommand_aal_aal1_errorCorrection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCorrection
    errorCorrection::const_reference get_errorCorrection () const;
    errorCorrection::reference ref_errorCorrection ();
    errorCorrection::reference set_errorCorrection ();
    errorCorrection::reference set_errorCorrection (errorCorrection::const_reference value);
    class structuredDataTransfer {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class structuredDataTransfer
    structuredDataTransfer::const_reference get_structuredDataTransfer () const;
    structuredDataTransfer::reference ref_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer (bool value);
    class partiallyFilledCells {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class partiallyFilledCells
    partiallyFilledCells::const_reference get_partiallyFilledCells () const;
    partiallyFilledCells::reference ref_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells (bool value);
    void swap(NewATMVCCommand_aal_aal1& other);
    NewATMVCCommand_aal_aal1 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// NewATMVCIndication_aal_aal1
//

class NewATMVCIndication_aal_aal1 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_aal_aal1(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_aal_aal1() : Inherited(&theInfo) {}
    NewATMVCIndication_aal_aal1(const NewATMVCIndication_aal_aal1 & other) : Inherited(other)
    {}
    NewATMVCIndication_aal_aal1& operator = (const NewATMVCIndication_aal_aal1& other)
    { Inherited::operator = (other); return *this; } 
    class clockRecovery {
      public:
        typedef NewATMVCIndication_aal_aal1_clockRecovery value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class clockRecovery
    clockRecovery::const_reference get_clockRecovery () const;
    clockRecovery::reference ref_clockRecovery ();
    clockRecovery::reference set_clockRecovery ();
    clockRecovery::reference set_clockRecovery (clockRecovery::const_reference value);
    class errorCorrection {
      public:
        typedef NewATMVCIndication_aal_aal1_errorCorrection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCorrection
    errorCorrection::const_reference get_errorCorrection () const;
    errorCorrection::reference ref_errorCorrection ();
    errorCorrection::reference set_errorCorrection ();
    errorCorrection::reference set_errorCorrection (errorCorrection::const_reference value);
    class structuredDataTransfer {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class structuredDataTransfer
    structuredDataTransfer::const_reference get_structuredDataTransfer () const;
    structuredDataTransfer::reference ref_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer ();
    structuredDataTransfer::reference set_structuredDataTransfer (bool value);
    class partiallyFilledCells {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class partiallyFilledCells
    partiallyFilledCells::const_reference get_partiallyFilledCells () const;
    partiallyFilledCells::reference ref_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells ();
    partiallyFilledCells::reference set_partiallyFilledCells (bool value);
    void swap(NewATMVCIndication_aal_aal1& other);
    NewATMVCIndication_aal_aal1 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// DepFECData_rfc2733_mode_separateStream
//

class DepFECData_rfc2733_mode_separateStream : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECData_rfc2733_mode_separateStream(const void* info) : Inherited(info) {}
  public:
    DepFECData_rfc2733_mode_separateStream() : Inherited(&theInfo) {}
    class differentPort {
      public:
        enum Id { id_ = 0 };
        typedef DepFECData_rfc2733_mode_separateStream_differentPort value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class differentPort

    differentPort::const_reference get_differentPort () const;
    differentPort::reference ref_differentPort (); 
    differentPort::reference select_differentPort (); 
    differentPort::reference select_differentPort (differentPort::const_reference value); 
    bool differentPort_isSelected() const;

    class samePort {
      public:
        enum Id { id_ = 1 };
        typedef DepFECData_rfc2733_mode_separateStream_samePort value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class samePort

    samePort::const_reference get_samePort () const;
    samePort::reference ref_samePort (); 
    samePort::reference select_samePort (); 
    samePort::reference select_samePort (samePort::const_reference value); 
    bool samePort_isSelected() const;

    DepFECData_rfc2733_mode_separateStream(differentPort::Id id, differentPort::const_reference value);
    DepFECData_rfc2733_mode_separateStream(samePort::Id id, samePort::const_reference value);
    void swap(DepFECData_rfc2733_mode_separateStream & other);
    DepFECData_rfc2733_mode_separateStream(const DepFECData_rfc2733_mode_separateStream & other)
    : Inherited(other) {} 

    DepFECData_rfc2733_mode_separateStream & operator = (const DepFECData_rfc2733_mode_separateStream & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DepFECData_rfc2733_mode_separateStream * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// NonStandardParameter
//

class NonStandardParameter : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NonStandardParameter(const void* info) : Inherited(info) {}
  public:
    NonStandardParameter() : Inherited(&theInfo) {}
    NonStandardParameter(const NonStandardParameter & other) : Inherited(other)
    {}
    NonStandardParameter& operator = (const NonStandardParameter& other)
    { Inherited::operator = (other); return *this; } 
    class nonStandardIdentifier {
      public:
        typedef NonStandardIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardIdentifier
    nonStandardIdentifier::const_reference get_nonStandardIdentifier () const;
    nonStandardIdentifier::reference ref_nonStandardIdentifier ();
    nonStandardIdentifier::reference set_nonStandardIdentifier ();
    nonStandardIdentifier::reference set_nonStandardIdentifier (nonStandardIdentifier::const_reference value);
    class data {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class data
    data::const_reference get_data () const;
    data::reference ref_data ();
    data::reference set_data ();
    data::reference set_data (const std::vector<char>& value);
    void swap(NonStandardParameter& other);
    NonStandardParameter * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// CapabilityDescriptor
//

class CapabilityDescriptor : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CapabilityDescriptor(const void* info) : Inherited(info) {}
  public:
    CapabilityDescriptor() : Inherited(&theInfo) {}
    CapabilityDescriptor(const CapabilityDescriptor & other) : Inherited(other)
    {}
    CapabilityDescriptor& operator = (const CapabilityDescriptor& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_simultaneousCapabilities
    };

    class capabilityDescriptorNumber {
      public:
        typedef CapabilityDescriptorNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityDescriptorNumber
    capabilityDescriptorNumber::const_reference get_capabilityDescriptorNumber () const;
    capabilityDescriptorNumber::reference ref_capabilityDescriptorNumber ();
    capabilityDescriptorNumber::reference set_capabilityDescriptorNumber ();
    capabilityDescriptorNumber::reference set_capabilityDescriptorNumber (capabilityDescriptorNumber::value_type::int_type value);
    class simultaneousCapabilities {
      public:
        typedef ASN1::SET_OF<AlternativeCapabilitySet,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class simultaneousCapabilities
    simultaneousCapabilities::const_reference get_simultaneousCapabilities () const;
    simultaneousCapabilities::reference ref_simultaneousCapabilities ();
    simultaneousCapabilities::reference set_simultaneousCapabilities ();
    simultaneousCapabilities::reference set_simultaneousCapabilities (simultaneousCapabilities::const_reference value);
    void omit_simultaneousCapabilities ();
    bool simultaneousCapabilities_isPresent () const;
    void swap(CapabilityDescriptor& other);
    CapabilityDescriptor * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223Capability
//

class H223Capability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223Capability(const void* info) : Inherited(info) {}
  public:
    H223Capability() : Inherited(&theInfo) {}
    H223Capability(const H223Capability & other) : Inherited(other)
    {}
    H223Capability& operator = (const H223Capability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_maxMUXPDUSizeCapability,
      e_nsrpSupport,
      e_mobileOperationTransmitCapability,
      e_h223AnnexCCapability,
      e_bitRate,
      e_mobileMultilinkFrameCapability
    };

    class transportWithI_frames {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportWithI_frames
    transportWithI_frames::const_reference get_transportWithI_frames () const;
    transportWithI_frames::reference ref_transportWithI_frames ();
    transportWithI_frames::reference set_transportWithI_frames ();
    transportWithI_frames::reference set_transportWithI_frames (bool value);
    class videoWithAL1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoWithAL1
    videoWithAL1::const_reference get_videoWithAL1 () const;
    videoWithAL1::reference ref_videoWithAL1 ();
    videoWithAL1::reference set_videoWithAL1 ();
    videoWithAL1::reference set_videoWithAL1 (bool value);
    class videoWithAL2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoWithAL2
    videoWithAL2::const_reference get_videoWithAL2 () const;
    videoWithAL2::reference ref_videoWithAL2 ();
    videoWithAL2::reference set_videoWithAL2 ();
    videoWithAL2::reference set_videoWithAL2 (bool value);
    class videoWithAL3 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoWithAL3
    videoWithAL3::const_reference get_videoWithAL3 () const;
    videoWithAL3::reference ref_videoWithAL3 ();
    videoWithAL3::reference set_videoWithAL3 ();
    videoWithAL3::reference set_videoWithAL3 (bool value);
    class audioWithAL1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioWithAL1
    audioWithAL1::const_reference get_audioWithAL1 () const;
    audioWithAL1::reference ref_audioWithAL1 ();
    audioWithAL1::reference set_audioWithAL1 ();
    audioWithAL1::reference set_audioWithAL1 (bool value);
    class audioWithAL2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioWithAL2
    audioWithAL2::const_reference get_audioWithAL2 () const;
    audioWithAL2::reference ref_audioWithAL2 ();
    audioWithAL2::reference set_audioWithAL2 ();
    audioWithAL2::reference set_audioWithAL2 (bool value);
    class audioWithAL3 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioWithAL3
    audioWithAL3::const_reference get_audioWithAL3 () const;
    audioWithAL3::reference ref_audioWithAL3 ();
    audioWithAL3::reference set_audioWithAL3 ();
    audioWithAL3::reference set_audioWithAL3 (bool value);
    class dataWithAL1 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataWithAL1
    dataWithAL1::const_reference get_dataWithAL1 () const;
    dataWithAL1::reference ref_dataWithAL1 ();
    dataWithAL1::reference set_dataWithAL1 ();
    dataWithAL1::reference set_dataWithAL1 (bool value);
    class dataWithAL2 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataWithAL2
    dataWithAL2::const_reference get_dataWithAL2 () const;
    dataWithAL2::reference ref_dataWithAL2 ();
    dataWithAL2::reference set_dataWithAL2 ();
    dataWithAL2::reference set_dataWithAL2 (bool value);
    class dataWithAL3 {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataWithAL3
    dataWithAL3::const_reference get_dataWithAL3 () const;
    dataWithAL3::reference ref_dataWithAL3 ();
    dataWithAL3::reference set_dataWithAL3 ();
    dataWithAL3::reference set_dataWithAL3 (bool value);
    class maximumAl2SDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumAl2SDUSize
    maximumAl2SDUSize::const_reference get_maximumAl2SDUSize () const;
    maximumAl2SDUSize::reference ref_maximumAl2SDUSize ();
    maximumAl2SDUSize::reference set_maximumAl2SDUSize ();
    maximumAl2SDUSize::reference set_maximumAl2SDUSize (maximumAl2SDUSize::value_type::int_type value);
    class maximumAl3SDUSize {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumAl3SDUSize
    maximumAl3SDUSize::const_reference get_maximumAl3SDUSize () const;
    maximumAl3SDUSize::reference ref_maximumAl3SDUSize ();
    maximumAl3SDUSize::reference set_maximumAl3SDUSize ();
    maximumAl3SDUSize::reference set_maximumAl3SDUSize (maximumAl3SDUSize::value_type::int_type value);
    class maximumDelayJitter {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1023>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumDelayJitter
    maximumDelayJitter::const_reference get_maximumDelayJitter () const;
    maximumDelayJitter::reference ref_maximumDelayJitter ();
    maximumDelayJitter::reference set_maximumDelayJitter ();
    maximumDelayJitter::reference set_maximumDelayJitter (maximumDelayJitter::value_type::int_type value);
    class h223MultiplexTableCapability {
      public:
        typedef H223Capability_h223MultiplexTableCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223MultiplexTableCapability
    h223MultiplexTableCapability::const_reference get_h223MultiplexTableCapability () const;
    h223MultiplexTableCapability::reference ref_h223MultiplexTableCapability ();
    h223MultiplexTableCapability::reference set_h223MultiplexTableCapability ();
    h223MultiplexTableCapability::reference set_h223MultiplexTableCapability (h223MultiplexTableCapability::const_reference value);
    class maxMUXPDUSizeCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxMUXPDUSizeCapability
    maxMUXPDUSizeCapability::const_reference get_maxMUXPDUSizeCapability () const;
    maxMUXPDUSizeCapability::reference ref_maxMUXPDUSizeCapability ();
    maxMUXPDUSizeCapability::reference set_maxMUXPDUSizeCapability ();
    maxMUXPDUSizeCapability::reference set_maxMUXPDUSizeCapability (bool value);
    void omit_maxMUXPDUSizeCapability ();
    bool maxMUXPDUSizeCapability_isPresent () const;
    class nsrpSupport {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nsrpSupport
    nsrpSupport::const_reference get_nsrpSupport () const;
    nsrpSupport::reference ref_nsrpSupport ();
    nsrpSupport::reference set_nsrpSupport ();
    nsrpSupport::reference set_nsrpSupport (bool value);
    void omit_nsrpSupport ();
    bool nsrpSupport_isPresent () const;
    class mobileOperationTransmitCapability {
      public:
        typedef H223Capability_mobileOperationTransmitCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mobileOperationTransmitCapability
    mobileOperationTransmitCapability::const_reference get_mobileOperationTransmitCapability () const;
    mobileOperationTransmitCapability::reference ref_mobileOperationTransmitCapability ();
    mobileOperationTransmitCapability::reference set_mobileOperationTransmitCapability ();
    mobileOperationTransmitCapability::reference set_mobileOperationTransmitCapability (mobileOperationTransmitCapability::const_reference value);
    void omit_mobileOperationTransmitCapability ();
    bool mobileOperationTransmitCapability_isPresent () const;
    class h223AnnexCCapability {
      public:
        typedef H223AnnexCCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223AnnexCCapability
    h223AnnexCCapability::const_reference get_h223AnnexCCapability () const;
    h223AnnexCCapability::reference ref_h223AnnexCCapability ();
    h223AnnexCCapability::reference set_h223AnnexCCapability ();
    h223AnnexCCapability::reference set_h223AnnexCCapability (h223AnnexCCapability::const_reference value);
    void omit_h223AnnexCCapability ();
    bool h223AnnexCCapability_isPresent () const;
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 19200>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    void omit_bitRate ();
    bool bitRate_isPresent () const;
    class mobileMultilinkFrameCapability {
      public:
        typedef H223Capability_mobileMultilinkFrameCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mobileMultilinkFrameCapability
    mobileMultilinkFrameCapability::const_reference get_mobileMultilinkFrameCapability () const;
    mobileMultilinkFrameCapability::reference ref_mobileMultilinkFrameCapability ();
    mobileMultilinkFrameCapability::reference set_mobileMultilinkFrameCapability ();
    mobileMultilinkFrameCapability::reference set_mobileMultilinkFrameCapability (mobileMultilinkFrameCapability::const_reference value);
    void omit_mobileMultilinkFrameCapability ();
    bool mobileMultilinkFrameCapability_isPresent () const;
    void swap(H223Capability& other);
    H223Capability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[20];
    static int fieldIds[20];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[20];
};

//
// QOSCapability
//

class QOSCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    QOSCapability(const void* info) : Inherited(info) {}
  public:
    QOSCapability() : Inherited(&theInfo) {}
    QOSCapability(const QOSCapability & other) : Inherited(other)
    {}
    QOSCapability& operator = (const QOSCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandardData,
      e_rsvpParameters,
      e_atmParameters
    };

    class nonStandardData {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardData
    nonStandardData::const_reference get_nonStandardData () const;
    nonStandardData::reference ref_nonStandardData ();
    nonStandardData::reference set_nonStandardData ();
    nonStandardData::reference set_nonStandardData (nonStandardData::const_reference value);
    void omit_nonStandardData ();
    bool nonStandardData_isPresent () const;
    class rsvpParameters {
      public:
        typedef RSVPParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rsvpParameters
    rsvpParameters::const_reference get_rsvpParameters () const;
    rsvpParameters::reference ref_rsvpParameters ();
    rsvpParameters::reference set_rsvpParameters ();
    rsvpParameters::reference set_rsvpParameters (rsvpParameters::const_reference value);
    void omit_rsvpParameters ();
    bool rsvpParameters_isPresent () const;
    class atmParameters {
      public:
        typedef ATMParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class atmParameters
    atmParameters::const_reference get_atmParameters () const;
    atmParameters::reference ref_atmParameters ();
    atmParameters::reference set_atmParameters ();
    atmParameters::reference set_atmParameters (atmParameters::const_reference value);
    void omit_atmParameters ();
    bool atmParameters_isPresent () const;
    void swap(QOSCapability& other);
    QOSCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// TransportCapability
//

class TransportCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TransportCapability(const void* info) : Inherited(info) {}
  public:
    TransportCapability() : Inherited(&theInfo) {}
    TransportCapability(const TransportCapability & other) : Inherited(other)
    {}
    TransportCapability& operator = (const TransportCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard,
      e_qOSCapabilities,
      e_mediaChannelCapabilities
    };

    class nonStandard {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    class qOSCapabilities {
      public:
        typedef ASN1::SEQUENCE_OF<QOSCapability,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qOSCapabilities
    qOSCapabilities::const_reference get_qOSCapabilities () const;
    qOSCapabilities::reference ref_qOSCapabilities ();
    qOSCapabilities::reference set_qOSCapabilities ();
    qOSCapabilities::reference set_qOSCapabilities (qOSCapabilities::const_reference value);
    void omit_qOSCapabilities ();
    bool qOSCapabilities_isPresent () const;
    class mediaChannelCapabilities {
      public:
        typedef ASN1::SEQUENCE_OF<MediaChannelCapability,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaChannelCapabilities
    mediaChannelCapabilities::const_reference get_mediaChannelCapabilities () const;
    mediaChannelCapabilities::reference ref_mediaChannelCapabilities ();
    mediaChannelCapabilities::reference set_mediaChannelCapabilities ();
    mediaChannelCapabilities::reference set_mediaChannelCapabilities (mediaChannelCapabilities::const_reference value);
    void omit_mediaChannelCapabilities ();
    bool mediaChannelCapabilities_isPresent () const;
    void swap(TransportCapability& other);
    TransportCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// RTPH263VideoRedundancyEncoding
//

class RTPH263VideoRedundancyEncoding : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RTPH263VideoRedundancyEncoding(const void* info) : Inherited(info) {}
  public:
    RTPH263VideoRedundancyEncoding() : Inherited(&theInfo) {}
    RTPH263VideoRedundancyEncoding(const RTPH263VideoRedundancyEncoding & other) : Inherited(other)
    {}
    RTPH263VideoRedundancyEncoding& operator = (const RTPH263VideoRedundancyEncoding& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_containedThreads
    };

    class numberOfThreads {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 16>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfThreads
    numberOfThreads::const_reference get_numberOfThreads () const;
    numberOfThreads::reference ref_numberOfThreads ();
    numberOfThreads::reference set_numberOfThreads ();
    numberOfThreads::reference set_numberOfThreads (numberOfThreads::value_type::int_type value);
    class framesBetweenSyncPoints {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class framesBetweenSyncPoints
    framesBetweenSyncPoints::const_reference get_framesBetweenSyncPoints () const;
    framesBetweenSyncPoints::reference ref_framesBetweenSyncPoints ();
    framesBetweenSyncPoints::reference set_framesBetweenSyncPoints ();
    framesBetweenSyncPoints::reference set_framesBetweenSyncPoints (framesBetweenSyncPoints::value_type::int_type value);
    class frameToThreadMapping {
      public:
        typedef RTPH263VideoRedundancyEncoding_frameToThreadMapping value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class frameToThreadMapping
    frameToThreadMapping::const_reference get_frameToThreadMapping () const;
    frameToThreadMapping::reference ref_frameToThreadMapping ();
    frameToThreadMapping::reference set_frameToThreadMapping ();
    frameToThreadMapping::reference set_frameToThreadMapping (frameToThreadMapping::const_reference value);
    class containedThreads {
      public:
        typedef RTPH263VideoRedundancyEncoding_containedThreads value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class containedThreads
    containedThreads::const_reference get_containedThreads () const;
    containedThreads::reference ref_containedThreads ();
    containedThreads::reference set_containedThreads ();
    containedThreads::reference set_containedThreads (containedThreads::const_reference value);
    void omit_containedThreads ();
    bool containedThreads_isPresent () const;
    void swap(RTPH263VideoRedundancyEncoding& other);
    RTPH263VideoRedundancyEncoding * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// RefPictureSelection
//

class RefPictureSelection : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RefPictureSelection(const void* info) : Inherited(info) {}
  public:
    RefPictureSelection() : Inherited(&theInfo) {}
    RefPictureSelection(const RefPictureSelection & other) : Inherited(other)
    {}
    RefPictureSelection& operator = (const RefPictureSelection& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_additionalPictureMemory,
      e_enhancedReferencePicSelect
    };

    class additionalPictureMemory {
      public:
        typedef RefPictureSelection_additionalPictureMemory value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class additionalPictureMemory
    additionalPictureMemory::const_reference get_additionalPictureMemory () const;
    additionalPictureMemory::reference ref_additionalPictureMemory ();
    additionalPictureMemory::reference set_additionalPictureMemory ();
    additionalPictureMemory::reference set_additionalPictureMemory (additionalPictureMemory::const_reference value);
    void omit_additionalPictureMemory ();
    bool additionalPictureMemory_isPresent () const;
    class videoMux {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoMux
    videoMux::const_reference get_videoMux () const;
    videoMux::reference ref_videoMux ();
    videoMux::reference set_videoMux ();
    videoMux::reference set_videoMux (bool value);
    class videoBackChannelSend {
      public:
        typedef RefPictureSelection_videoBackChannelSend value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBackChannelSend
    videoBackChannelSend::const_reference get_videoBackChannelSend () const;
    videoBackChannelSend::reference ref_videoBackChannelSend ();
    videoBackChannelSend::reference set_videoBackChannelSend ();
    videoBackChannelSend::reference set_videoBackChannelSend (videoBackChannelSend::const_reference value);
    class enhancedReferencePicSelect {
      public:
        typedef RefPictureSelection_enhancedReferencePicSelect value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enhancedReferencePicSelect
    enhancedReferencePicSelect::const_reference get_enhancedReferencePicSelect () const;
    enhancedReferencePicSelect::reference ref_enhancedReferencePicSelect ();
    enhancedReferencePicSelect::reference set_enhancedReferencePicSelect ();
    enhancedReferencePicSelect::reference set_enhancedReferencePicSelect (enhancedReferencePicSelect::const_reference value);
    void omit_enhancedReferencePicSelect ();
    bool enhancedReferencePicSelect_isPresent () const;
    void swap(RefPictureSelection& other);
    RefPictureSelection * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[4];
};

//
// H263VideoModeCombos
//

class H263VideoModeCombos : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263VideoModeCombos(const void* info) : Inherited(info) {}
  public:
    H263VideoModeCombos() : Inherited(&theInfo) {}
    H263VideoModeCombos(const H263VideoModeCombos & other) : Inherited(other)
    {}
    H263VideoModeCombos& operator = (const H263VideoModeCombos& other)
    { Inherited::operator = (other); return *this; } 
    class h263VideoUncoupledModes {
      public:
        typedef H263ModeComboFlags value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263VideoUncoupledModes
    h263VideoUncoupledModes::const_reference get_h263VideoUncoupledModes () const;
    h263VideoUncoupledModes::reference ref_h263VideoUncoupledModes ();
    h263VideoUncoupledModes::reference set_h263VideoUncoupledModes ();
    h263VideoUncoupledModes::reference set_h263VideoUncoupledModes (h263VideoUncoupledModes::const_reference value);
    class h263VideoCoupledModes {
      public:
        typedef ASN1::SET_OF<H263ModeComboFlags,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263VideoCoupledModes
    h263VideoCoupledModes::const_reference get_h263VideoCoupledModes () const;
    h263VideoCoupledModes::reference ref_h263VideoCoupledModes ();
    h263VideoCoupledModes::reference set_h263VideoCoupledModes ();
    h263VideoCoupledModes::reference set_h263VideoCoupledModes (h263VideoCoupledModes::const_reference value);
    void swap(H263VideoModeCombos& other);
    H263VideoModeCombos * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DataProtocolCapability
//

class DataProtocolCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataProtocolCapability(const void* info) : Inherited(info) {}
  public:
    DataProtocolCapability() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class v14buffered {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v14buffered

    v14buffered::reference select_v14buffered (); 
    bool v14buffered_isSelected() const;

    class v42lapm {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v42lapm

    v42lapm::reference select_v42lapm (); 
    bool v42lapm_isSelected() const;

    class hdlcFrameTunnelling {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hdlcFrameTunnelling

    hdlcFrameTunnelling::reference select_hdlcFrameTunnelling (); 
    bool hdlcFrameTunnelling_isSelected() const;

    class h310SeparateVCStack {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h310SeparateVCStack

    h310SeparateVCStack::reference select_h310SeparateVCStack (); 
    bool h310SeparateVCStack_isSelected() const;

    class h310SingleVCStack {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h310SingleVCStack

    h310SingleVCStack::reference select_h310SingleVCStack (); 
    bool h310SingleVCStack_isSelected() const;

    class transparent {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transparent

    transparent::reference select_transparent (); 
    bool transparent_isSelected() const;

    class segmentationAndReassembly {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class segmentationAndReassembly

    segmentationAndReassembly::reference select_segmentationAndReassembly (); 
    bool segmentationAndReassembly_isSelected() const;

    class hdlcFrameTunnelingwSAR {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hdlcFrameTunnelingwSAR

    hdlcFrameTunnelingwSAR::reference select_hdlcFrameTunnelingwSAR (); 
    bool hdlcFrameTunnelingwSAR_isSelected() const;

    class v120 {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v120

    v120::reference select_v120 (); 
    bool v120_isSelected() const;

    class separateLANStack {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateLANStack

    separateLANStack::reference select_separateLANStack (); 
    bool separateLANStack_isSelected() const;

    class v76wCompression {
      public:
        enum Id { id_ = 11 };
        typedef DataProtocolCapability_v76wCompression value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v76wCompression

    v76wCompression::const_reference get_v76wCompression () const;
    v76wCompression::reference ref_v76wCompression (); 
    v76wCompression::reference select_v76wCompression (); 
    v76wCompression::reference select_v76wCompression (v76wCompression::const_reference value); 
    bool v76wCompression_isSelected() const;

    class tcp {
      public:
        enum Id { id_ = 12 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class tcp

    tcp::reference select_tcp (); 
    bool tcp_isSelected() const;

    class udp {
      public:
        enum Id { id_ = 13 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class udp

    udp::reference select_udp (); 
    bool udp_isSelected() const;

    DataProtocolCapability(nonStandard::Id id, nonStandard::const_reference value);
    DataProtocolCapability(v14buffered::Id id, v14buffered::const_reference value);
    DataProtocolCapability(v42lapm::Id id, v42lapm::const_reference value);
    DataProtocolCapability(hdlcFrameTunnelling::Id id, hdlcFrameTunnelling::const_reference value);
    DataProtocolCapability(h310SeparateVCStack::Id id, h310SeparateVCStack::const_reference value);
    DataProtocolCapability(h310SingleVCStack::Id id, h310SingleVCStack::const_reference value);
    DataProtocolCapability(transparent::Id id, transparent::const_reference value);
    DataProtocolCapability(segmentationAndReassembly::Id id, segmentationAndReassembly::const_reference value);
    DataProtocolCapability(hdlcFrameTunnelingwSAR::Id id, hdlcFrameTunnelingwSAR::const_reference value);
    DataProtocolCapability(v120::Id id, v120::const_reference value);
    DataProtocolCapability(separateLANStack::Id id, separateLANStack::const_reference value);
    DataProtocolCapability(v76wCompression::Id id, v76wCompression::const_reference value);
    DataProtocolCapability(tcp::Id id, tcp::const_reference value);
    DataProtocolCapability(udp::Id id, udp::const_reference value);
    void swap(DataProtocolCapability & other);
    DataProtocolCapability(const DataProtocolCapability & other)
    : Inherited(other) {} 

    DataProtocolCapability & operator = (const DataProtocolCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DataProtocolCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[14];
    static const char* selectionNames[14];
};

//
// T38FaxProfile
//

class T38FaxProfile : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    T38FaxProfile(const void* info) : Inherited(info) {}
  public:
    T38FaxProfile() : Inherited(&theInfo) {}
    T38FaxProfile(const T38FaxProfile & other) : Inherited(other)
    {}
    T38FaxProfile& operator = (const T38FaxProfile& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_version,
      e_t38FaxRateManagement,
      e_t38FaxUdpOptions,
      e_t38FaxTcpOptions
    };

    class fillBitRemoval {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fillBitRemoval
    fillBitRemoval::const_reference get_fillBitRemoval () const;
    fillBitRemoval::reference ref_fillBitRemoval ();
    fillBitRemoval::reference set_fillBitRemoval ();
    fillBitRemoval::reference set_fillBitRemoval (bool value);
    class transcodingJBIG {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transcodingJBIG
    transcodingJBIG::const_reference get_transcodingJBIG () const;
    transcodingJBIG::reference ref_transcodingJBIG ();
    transcodingJBIG::reference set_transcodingJBIG ();
    transcodingJBIG::reference set_transcodingJBIG (bool value);
    class transcodingMMR {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transcodingMMR
    transcodingMMR::const_reference get_transcodingMMR () const;
    transcodingMMR::reference ref_transcodingMMR ();
    transcodingMMR::reference set_transcodingMMR ();
    transcodingMMR::reference set_transcodingMMR (bool value);
    class version {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class version
    version::const_reference get_version () const;
    version::reference ref_version ();
    version::reference set_version ();
    version::reference set_version (version::value_type::int_type value);
    void omit_version ();
    bool version_isPresent () const;
    class t38FaxRateManagement {
      public:
        typedef T38FaxRateManagement value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxRateManagement
    t38FaxRateManagement::const_reference get_t38FaxRateManagement () const;
    t38FaxRateManagement::reference ref_t38FaxRateManagement ();
    t38FaxRateManagement::reference set_t38FaxRateManagement ();
    t38FaxRateManagement::reference set_t38FaxRateManagement (t38FaxRateManagement::const_reference value);
    void omit_t38FaxRateManagement ();
    bool t38FaxRateManagement_isPresent () const;
    class t38FaxUdpOptions {
      public:
        typedef T38FaxUdpOptions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxUdpOptions
    t38FaxUdpOptions::const_reference get_t38FaxUdpOptions () const;
    t38FaxUdpOptions::reference ref_t38FaxUdpOptions ();
    t38FaxUdpOptions::reference set_t38FaxUdpOptions ();
    t38FaxUdpOptions::reference set_t38FaxUdpOptions (t38FaxUdpOptions::const_reference value);
    void omit_t38FaxUdpOptions ();
    bool t38FaxUdpOptions_isPresent () const;
    class t38FaxTcpOptions {
      public:
        typedef T38FaxTcpOptions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxTcpOptions
    t38FaxTcpOptions::const_reference get_t38FaxTcpOptions () const;
    t38FaxTcpOptions::reference ref_t38FaxTcpOptions ();
    t38FaxTcpOptions::reference set_t38FaxTcpOptions ();
    t38FaxTcpOptions::reference set_t38FaxTcpOptions (t38FaxTcpOptions::const_reference value);
    void omit_t38FaxTcpOptions ();
    bool t38FaxTcpOptions_isPresent () const;
    void swap(T38FaxProfile& other);
    T38FaxProfile * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[7];
};

//
// MediaEncryptionAlgorithm
//

class MediaEncryptionAlgorithm : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MediaEncryptionAlgorithm(const void* info) : Inherited(info) {}
  public:
    MediaEncryptionAlgorithm() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class algorithm {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class algorithm

    algorithm::const_reference get_algorithm () const;
    algorithm::reference ref_algorithm (); 
    algorithm::reference select_algorithm (); 
    algorithm::reference select_algorithm (algorithm::const_reference value); 
    bool algorithm_isSelected() const;

    MediaEncryptionAlgorithm(nonStandard::Id id, nonStandard::const_reference value);
    MediaEncryptionAlgorithm(algorithm::Id id, algorithm::const_reference value);
    void swap(MediaEncryptionAlgorithm & other);
    MediaEncryptionAlgorithm(const MediaEncryptionAlgorithm & other)
    : Inherited(other) {} 

    MediaEncryptionAlgorithm & operator = (const MediaEncryptionAlgorithm & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MediaEncryptionAlgorithm * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// AuthenticationCapability
//

class AuthenticationCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AuthenticationCapability(const void* info) : Inherited(info) {}
  public:
    AuthenticationCapability() : Inherited(&theInfo) {}
    AuthenticationCapability(const AuthenticationCapability & other) : Inherited(other)
    {}
    AuthenticationCapability& operator = (const AuthenticationCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard,
      e_antiSpamAlgorithm
    };

    class nonStandard {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    class antiSpamAlgorithm {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class antiSpamAlgorithm
    antiSpamAlgorithm::const_reference get_antiSpamAlgorithm () const;
    antiSpamAlgorithm::reference ref_antiSpamAlgorithm ();
    antiSpamAlgorithm::reference set_antiSpamAlgorithm ();
    antiSpamAlgorithm::reference set_antiSpamAlgorithm (antiSpamAlgorithm::const_reference value);
    void omit_antiSpamAlgorithm ();
    bool antiSpamAlgorithm_isPresent () const;
    void swap(AuthenticationCapability& other);
    AuthenticationCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// IntegrityCapability
//

class IntegrityCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IntegrityCapability(const void* info) : Inherited(info) {}
  public:
    IntegrityCapability() : Inherited(&theInfo) {}
    IntegrityCapability(const IntegrityCapability & other) : Inherited(other)
    {}
    IntegrityCapability& operator = (const IntegrityCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard
    };

    class nonStandard {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    void swap(IntegrityCapability& other);
    IntegrityCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// ConferenceCapability
//

class ConferenceCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceCapability(const void* info) : Inherited(info) {}
  public:
    ConferenceCapability() : Inherited(&theInfo) {}
    ConferenceCapability(const ConferenceCapability & other) : Inherited(other)
    {}
    ConferenceCapability& operator = (const ConferenceCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandardData,
      e_videoIndicateMixingCapability,
      e_multipointVisualizationCapability
    };

    class nonStandardData {
      public:
        typedef ASN1::SEQUENCE_OF<NonStandardParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardData
    nonStandardData::const_reference get_nonStandardData () const;
    nonStandardData::reference ref_nonStandardData ();
    nonStandardData::reference set_nonStandardData ();
    nonStandardData::reference set_nonStandardData (nonStandardData::const_reference value);
    void omit_nonStandardData ();
    bool nonStandardData_isPresent () const;
    class chairControlCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class chairControlCapability
    chairControlCapability::const_reference get_chairControlCapability () const;
    chairControlCapability::reference ref_chairControlCapability ();
    chairControlCapability::reference set_chairControlCapability ();
    chairControlCapability::reference set_chairControlCapability (bool value);
    class videoIndicateMixingCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoIndicateMixingCapability
    videoIndicateMixingCapability::const_reference get_videoIndicateMixingCapability () const;
    videoIndicateMixingCapability::reference ref_videoIndicateMixingCapability ();
    videoIndicateMixingCapability::reference set_videoIndicateMixingCapability ();
    videoIndicateMixingCapability::reference set_videoIndicateMixingCapability (bool value);
    void omit_videoIndicateMixingCapability ();
    bool videoIndicateMixingCapability_isPresent () const;
    class multipointVisualizationCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multipointVisualizationCapability
    multipointVisualizationCapability::const_reference get_multipointVisualizationCapability () const;
    multipointVisualizationCapability::reference ref_multipointVisualizationCapability ();
    multipointVisualizationCapability::reference set_multipointVisualizationCapability ();
    multipointVisualizationCapability::reference set_multipointVisualizationCapability (bool value);
    void omit_multipointVisualizationCapability ();
    bool multipointVisualizationCapability_isPresent () const;
    void swap(ConferenceCapability& other);
    ConferenceCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[4];
};

//
// CapabilityIdentifier
//

class CapabilityIdentifier : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CapabilityIdentifier(const void* info) : Inherited(info) {}
  public:
    CapabilityIdentifier() : Inherited(&theInfo) {}
    class standard {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class standard

    standard::const_reference get_standard () const;
    standard::reference ref_standard (); 
    standard::reference select_standard (); 
    standard::reference select_standard (standard::const_reference value); 
    bool standard_isSelected() const;

    class h221NonStandard {
      public:
        enum Id { id_ = 1 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h221NonStandard

    h221NonStandard::const_reference get_h221NonStandard () const;
    h221NonStandard::reference ref_h221NonStandard (); 
    h221NonStandard::reference select_h221NonStandard (); 
    h221NonStandard::reference select_h221NonStandard (h221NonStandard::const_reference value); 
    bool h221NonStandard_isSelected() const;

    class uuid {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class uuid

    uuid::const_reference get_uuid () const;
    uuid::reference ref_uuid (); 
    uuid::reference select_uuid (); 
    uuid::reference select_uuid (const std::vector<char>& value); 
    bool uuid_isSelected() const;

    class domainBased {
      public:
        enum Id { id_ = 3 };
        class value_type : public ASN1::IA5String
        {
            typedef ASN1::IA5String Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class domainBased

    domainBased::const_reference get_domainBased () const;
    domainBased::reference ref_domainBased (); 
    domainBased::reference select_domainBased (); 
    domainBased::reference select_domainBased (const std::string& value); 
    bool domainBased_isSelected() const;

    CapabilityIdentifier(standard::Id id, standard::const_reference value);
    CapabilityIdentifier(h221NonStandard::Id id, h221NonStandard::const_reference value);
    CapabilityIdentifier(uuid::Id id, const std::vector<char>& value);
    CapabilityIdentifier(domainBased::Id id, const std::string& value);
    void swap(CapabilityIdentifier & other);
    CapabilityIdentifier(const CapabilityIdentifier & other)
    : Inherited(other) {} 

    CapabilityIdentifier & operator = (const CapabilityIdentifier & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CapabilityIdentifier * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// ParameterIdentifier
//

class ParameterIdentifier : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ParameterIdentifier(const void* info) : Inherited(info) {}
  public:
    ParameterIdentifier() : Inherited(&theInfo) {}
    class standard {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class standard

    standard::const_reference get_standard () const;
    standard::reference ref_standard (); 
    standard::reference select_standard (); 
    standard::reference select_standard (standard::value_type::int_type value); 
    bool standard_isSelected() const;

    class h221NonStandard {
      public:
        enum Id { id_ = 1 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h221NonStandard

    h221NonStandard::const_reference get_h221NonStandard () const;
    h221NonStandard::reference ref_h221NonStandard (); 
    h221NonStandard::reference select_h221NonStandard (); 
    h221NonStandard::reference select_h221NonStandard (h221NonStandard::const_reference value); 
    bool h221NonStandard_isSelected() const;

    class uuid {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class uuid

    uuid::const_reference get_uuid () const;
    uuid::reference ref_uuid (); 
    uuid::reference select_uuid (); 
    uuid::reference select_uuid (const std::vector<char>& value); 
    bool uuid_isSelected() const;

    class domainBased {
      public:
        enum Id { id_ = 3 };
        class value_type : public ASN1::IA5String
        {
            typedef ASN1::IA5String Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class domainBased

    domainBased::const_reference get_domainBased () const;
    domainBased::reference ref_domainBased (); 
    domainBased::reference select_domainBased (); 
    domainBased::reference select_domainBased (const std::string& value); 
    bool domainBased_isSelected() const;

    ParameterIdentifier(standard::Id id, standard::value_type::int_type value);
    ParameterIdentifier(h221NonStandard::Id id, h221NonStandard::const_reference value);
    ParameterIdentifier(uuid::Id id, const std::vector<char>& value);
    ParameterIdentifier(domainBased::Id id, const std::string& value);
    void swap(ParameterIdentifier & other);
    ParameterIdentifier(const ParameterIdentifier & other)
    : Inherited(other) {} 

    ParameterIdentifier & operator = (const ParameterIdentifier & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ParameterIdentifier * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// DepFECCapability
//

class DepFECCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECCapability(const void* info) : Inherited(info) {}
  public:
    DepFECCapability() : Inherited(&theInfo) {}
    class rfc2733 {
      public:
        enum Id { id_ = 0 };
        typedef DepFECCapability_rfc2733 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733

    rfc2733::const_reference get_rfc2733 () const;
    rfc2733::reference ref_rfc2733 (); 
    rfc2733::reference select_rfc2733 (); 
    rfc2733::reference select_rfc2733 (rfc2733::const_reference value); 
    bool rfc2733_isSelected() const;

    DepFECCapability(rfc2733::Id id, rfc2733::const_reference value);
    void swap(DepFECCapability & other);
    DepFECCapability(const DepFECCapability & other)
    : Inherited(other) {} 

    DepFECCapability & operator = (const DepFECCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DepFECCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// H223AL1MParameters
//

class H223AL1MParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL1MParameters(const void* info) : Inherited(info) {}
  public:
    H223AL1MParameters() : Inherited(&theInfo) {}
    H223AL1MParameters(const H223AL1MParameters & other) : Inherited(other)
    {}
    H223AL1MParameters& operator = (const H223AL1MParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_rsCodeCorrection
    };

    class transferMode {
      public:
        typedef H223AL1MParameters_transferMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transferMode
    transferMode::const_reference get_transferMode () const;
    transferMode::reference ref_transferMode ();
    transferMode::reference set_transferMode ();
    transferMode::reference set_transferMode (transferMode::const_reference value);
    class headerFEC {
      public:
        typedef H223AL1MParameters_headerFEC value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class headerFEC
    headerFEC::const_reference get_headerFEC () const;
    headerFEC::reference ref_headerFEC ();
    headerFEC::reference set_headerFEC ();
    headerFEC::reference set_headerFEC (headerFEC::const_reference value);
    class crcLength {
      public:
        typedef H223AL1MParameters_crcLength value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crcLength
    crcLength::const_reference get_crcLength () const;
    crcLength::reference ref_crcLength ();
    crcLength::reference set_crcLength ();
    crcLength::reference set_crcLength (crcLength::const_reference value);
    class rcpcCodeRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 8, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rcpcCodeRate
    rcpcCodeRate::const_reference get_rcpcCodeRate () const;
    rcpcCodeRate::reference ref_rcpcCodeRate ();
    rcpcCodeRate::reference set_rcpcCodeRate ();
    rcpcCodeRate::reference set_rcpcCodeRate (rcpcCodeRate::value_type::int_type value);
    class arqType {
      public:
        typedef H223AL1MParameters_arqType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class arqType
    arqType::const_reference get_arqType () const;
    arqType::reference ref_arqType ();
    arqType::reference set_arqType ();
    arqType::reference set_arqType (arqType::const_reference value);
    class alpduInterleaving {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alpduInterleaving
    alpduInterleaving::const_reference get_alpduInterleaving () const;
    alpduInterleaving::reference ref_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving (bool value);
    class alsduSplitting {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alsduSplitting
    alsduSplitting::const_reference get_alsduSplitting () const;
    alsduSplitting::reference ref_alsduSplitting ();
    alsduSplitting::reference set_alsduSplitting ();
    alsduSplitting::reference set_alsduSplitting (bool value);
    class rsCodeCorrection {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rsCodeCorrection
    rsCodeCorrection::const_reference get_rsCodeCorrection () const;
    rsCodeCorrection::reference ref_rsCodeCorrection ();
    rsCodeCorrection::reference set_rsCodeCorrection ();
    rsCodeCorrection::reference set_rsCodeCorrection (rsCodeCorrection::value_type::int_type value);
    void omit_rsCodeCorrection ();
    bool rsCodeCorrection_isPresent () const;
    void swap(H223AL1MParameters& other);
    H223AL1MParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[8];
    static int fieldIds[8];
    static const char* fieldNames[8];
};

//
// H223AL3MParameters
//

class H223AL3MParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223AL3MParameters(const void* info) : Inherited(info) {}
  public:
    H223AL3MParameters() : Inherited(&theInfo) {}
    H223AL3MParameters(const H223AL3MParameters & other) : Inherited(other)
    {}
    H223AL3MParameters& operator = (const H223AL3MParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_rsCodeCorrection
    };

    class headerFormat {
      public:
        typedef H223AL3MParameters_headerFormat value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class headerFormat
    headerFormat::const_reference get_headerFormat () const;
    headerFormat::reference ref_headerFormat ();
    headerFormat::reference set_headerFormat ();
    headerFormat::reference set_headerFormat (headerFormat::const_reference value);
    class crcLength {
      public:
        typedef H223AL3MParameters_crcLength value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crcLength
    crcLength::const_reference get_crcLength () const;
    crcLength::reference ref_crcLength ();
    crcLength::reference set_crcLength ();
    crcLength::reference set_crcLength (crcLength::const_reference value);
    class rcpcCodeRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 8, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rcpcCodeRate
    rcpcCodeRate::const_reference get_rcpcCodeRate () const;
    rcpcCodeRate::reference ref_rcpcCodeRate ();
    rcpcCodeRate::reference set_rcpcCodeRate ();
    rcpcCodeRate::reference set_rcpcCodeRate (rcpcCodeRate::value_type::int_type value);
    class arqType {
      public:
        typedef H223AL3MParameters_arqType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class arqType
    arqType::const_reference get_arqType () const;
    arqType::reference ref_arqType ();
    arqType::reference set_arqType ();
    arqType::reference set_arqType (arqType::const_reference value);
    class alpduInterleaving {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alpduInterleaving
    alpduInterleaving::const_reference get_alpduInterleaving () const;
    alpduInterleaving::reference ref_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving ();
    alpduInterleaving::reference set_alpduInterleaving (bool value);
    class rsCodeCorrection {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rsCodeCorrection
    rsCodeCorrection::const_reference get_rsCodeCorrection () const;
    rsCodeCorrection::reference ref_rsCodeCorrection ();
    rsCodeCorrection::reference set_rsCodeCorrection ();
    rsCodeCorrection::reference set_rsCodeCorrection (rsCodeCorrection::value_type::int_type value);
    void omit_rsCodeCorrection ();
    bool rsCodeCorrection_isPresent () const;
    void swap(H223AL3MParameters& other);
    H223AL3MParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// UnicastAddress
//

class UnicastAddress : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UnicastAddress(const void* info) : Inherited(info) {}
  public:
    UnicastAddress() : Inherited(&theInfo) {}
    class iPAddress {
      public:
        enum Id { id_ = 0 };
        typedef UnicastAddress_iPAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iPAddress

    iPAddress::const_reference get_iPAddress () const;
    iPAddress::reference ref_iPAddress (); 
    iPAddress::reference select_iPAddress (); 
    iPAddress::reference select_iPAddress (iPAddress::const_reference value); 
    bool iPAddress_isSelected() const;

    class iPXAddress {
      public:
        enum Id { id_ = 1 };
        typedef UnicastAddress_iPXAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iPXAddress

    iPXAddress::const_reference get_iPXAddress () const;
    iPXAddress::reference ref_iPXAddress (); 
    iPXAddress::reference select_iPXAddress (); 
    iPXAddress::reference select_iPXAddress (iPXAddress::const_reference value); 
    bool iPXAddress_isSelected() const;

    class iP6Address {
      public:
        enum Id { id_ = 2 };
        typedef UnicastAddress_iP6Address value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iP6Address

    iP6Address::const_reference get_iP6Address () const;
    iP6Address::reference ref_iP6Address (); 
    iP6Address::reference select_iP6Address (); 
    iP6Address::reference select_iP6Address (iP6Address::const_reference value); 
    bool iP6Address_isSelected() const;

    class netBios {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 16, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class netBios

    netBios::const_reference get_netBios () const;
    netBios::reference ref_netBios (); 
    netBios::reference select_netBios (); 
    netBios::reference select_netBios (const std::vector<char>& value); 
    bool netBios_isSelected() const;

    class iPSourceRouteAddress {
      public:
        enum Id { id_ = 4 };
        typedef UnicastAddress_iPSourceRouteAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iPSourceRouteAddress

    iPSourceRouteAddress::const_reference get_iPSourceRouteAddress () const;
    iPSourceRouteAddress::reference ref_iPSourceRouteAddress (); 
    iPSourceRouteAddress::reference select_iPSourceRouteAddress (); 
    iPSourceRouteAddress::reference select_iPSourceRouteAddress (iPSourceRouteAddress::const_reference value); 
    bool iPSourceRouteAddress_isSelected() const;

    class nsap {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 20> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nsap

    nsap::const_reference get_nsap () const;
    nsap::reference ref_nsap (); 
    nsap::reference select_nsap (); 
    nsap::reference select_nsap (const std::vector<char>& value); 
    bool nsap_isSelected() const;

    class nonStandardAddress {
      public:
        enum Id { id_ = 6 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardAddress

    nonStandardAddress::const_reference get_nonStandardAddress () const;
    nonStandardAddress::reference ref_nonStandardAddress (); 
    nonStandardAddress::reference select_nonStandardAddress (); 
    nonStandardAddress::reference select_nonStandardAddress (nonStandardAddress::const_reference value); 
    bool nonStandardAddress_isSelected() const;

    UnicastAddress(iPAddress::Id id, iPAddress::const_reference value);
    UnicastAddress(iPXAddress::Id id, iPXAddress::const_reference value);
    UnicastAddress(iP6Address::Id id, iP6Address::const_reference value);
    UnicastAddress(netBios::Id id, const std::vector<char>& value);
    UnicastAddress(iPSourceRouteAddress::Id id, iPSourceRouteAddress::const_reference value);
    UnicastAddress(nsap::Id id, const std::vector<char>& value);
    UnicastAddress(nonStandardAddress::Id id, nonStandardAddress::const_reference value);
    void swap(UnicastAddress & other);
    UnicastAddress(const UnicastAddress & other)
    : Inherited(other) {} 

    UnicastAddress & operator = (const UnicastAddress & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    UnicastAddress * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[7];
    static const char* selectionNames[7];
};

//
// MulticastAddress
//

class MulticastAddress : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MulticastAddress(const void* info) : Inherited(info) {}
  public:
    MulticastAddress() : Inherited(&theInfo) {}
    class iPAddress {
      public:
        enum Id { id_ = 0 };
        typedef MulticastAddress_iPAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iPAddress

    iPAddress::const_reference get_iPAddress () const;
    iPAddress::reference ref_iPAddress (); 
    iPAddress::reference select_iPAddress (); 
    iPAddress::reference select_iPAddress (iPAddress::const_reference value); 
    bool iPAddress_isSelected() const;

    class iP6Address {
      public:
        enum Id { id_ = 1 };
        typedef MulticastAddress_iP6Address value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iP6Address

    iP6Address::const_reference get_iP6Address () const;
    iP6Address::reference ref_iP6Address (); 
    iP6Address::reference select_iP6Address (); 
    iP6Address::reference select_iP6Address (iP6Address::const_reference value); 
    bool iP6Address_isSelected() const;

    class nsap {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 20> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nsap

    nsap::const_reference get_nsap () const;
    nsap::reference ref_nsap (); 
    nsap::reference select_nsap (); 
    nsap::reference select_nsap (const std::vector<char>& value); 
    bool nsap_isSelected() const;

    class nonStandardAddress {
      public:
        enum Id { id_ = 3 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardAddress

    nonStandardAddress::const_reference get_nonStandardAddress () const;
    nonStandardAddress::reference ref_nonStandardAddress (); 
    nonStandardAddress::reference select_nonStandardAddress (); 
    nonStandardAddress::reference select_nonStandardAddress (nonStandardAddress::const_reference value); 
    bool nonStandardAddress_isSelected() const;

    MulticastAddress(iPAddress::Id id, iPAddress::const_reference value);
    MulticastAddress(iP6Address::Id id, iP6Address::const_reference value);
    MulticastAddress(nsap::Id id, const std::vector<char>& value);
    MulticastAddress(nonStandardAddress::Id id, nonStandardAddress::const_reference value);
    void swap(MulticastAddress & other);
    MulticastAddress(const MulticastAddress & other)
    : Inherited(other) {} 

    MulticastAddress & operator = (const MulticastAddress & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MulticastAddress * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// RequestChannelClose
//

class RequestChannelClose : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestChannelClose(const void* info) : Inherited(info) {}
  public:
    RequestChannelClose() : Inherited(&theInfo) {}
    RequestChannelClose(const RequestChannelClose & other) : Inherited(other)
    {}
    RequestChannelClose& operator = (const RequestChannelClose& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_qosCapability,
      e_reason
    };

    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class qosCapability {
      public:
        typedef QOSCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qosCapability
    qosCapability::const_reference get_qosCapability () const;
    qosCapability::reference ref_qosCapability ();
    qosCapability::reference set_qosCapability ();
    qosCapability::reference set_qosCapability (qosCapability::const_reference value);
    void omit_qosCapability ();
    bool qosCapability_isPresent () const;
    class reason {
      public:
        typedef RequestChannelClose_reason value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reason
    reason::const_reference get_reason () const;
    reason::reference ref_reason ();
    reason::reference set_reason ();
    reason::reference set_reason (reason::const_reference value);
    void omit_reason ();
    bool reason_isPresent () const;
    void swap(RequestChannelClose& other);
    RequestChannelClose * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[3];
};

//
// MultiplexEntryDescriptor
//

class MultiplexEntryDescriptor : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntryDescriptor(const void* info) : Inherited(info) {}
  public:
    MultiplexEntryDescriptor() : Inherited(&theInfo) {}
    MultiplexEntryDescriptor(const MultiplexEntryDescriptor & other) : Inherited(other)
    {}
    MultiplexEntryDescriptor& operator = (const MultiplexEntryDescriptor& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_elementList
    };

    class multiplexTableEntryNumber {
      public:
        typedef MultiplexTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexTableEntryNumber
    multiplexTableEntryNumber::const_reference get_multiplexTableEntryNumber () const;
    multiplexTableEntryNumber::reference ref_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber ();
    multiplexTableEntryNumber::reference set_multiplexTableEntryNumber (multiplexTableEntryNumber::value_type::int_type value);
    class elementList {
      public:
        typedef ASN1::SEQUENCE_OF<MultiplexElement,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class elementList
    elementList::const_reference get_elementList () const;
    elementList::reference ref_elementList ();
    elementList::reference set_elementList ();
    elementList::reference set_elementList (elementList::const_reference value);
    void omit_elementList ();
    bool elementList_isPresent () const;
    void swap(MultiplexEntryDescriptor& other);
    MultiplexEntryDescriptor * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultiplexEntrySendReject
//

class MultiplexEntrySendReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntrySendReject(const void* info) : Inherited(info) {}
  public:
    MultiplexEntrySendReject() : Inherited(&theInfo) {}
    MultiplexEntrySendReject(const MultiplexEntrySendReject & other) : Inherited(other)
    {}
    MultiplexEntrySendReject& operator = (const MultiplexEntrySendReject& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class rejectionDescriptions {
      public:
        typedef ASN1::SET_OF<MultiplexEntryRejectionDescriptions,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rejectionDescriptions
    rejectionDescriptions::const_reference get_rejectionDescriptions () const;
    rejectionDescriptions::reference ref_rejectionDescriptions ();
    rejectionDescriptions::reference set_rejectionDescriptions ();
    rejectionDescriptions::reference set_rejectionDescriptions (rejectionDescriptions::const_reference value);
    void swap(MultiplexEntrySendReject& other);
    MultiplexEntrySendReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RequestMultiplexEntryReject
//

class RequestMultiplexEntryReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMultiplexEntryReject(const void* info) : Inherited(info) {}
  public:
    RequestMultiplexEntryReject() : Inherited(&theInfo) {}
    RequestMultiplexEntryReject(const RequestMultiplexEntryReject & other) : Inherited(other)
    {}
    RequestMultiplexEntryReject& operator = (const RequestMultiplexEntryReject& other)
    { Inherited::operator = (other); return *this; } 
    class entryNumbers {
      public:
        typedef ASN1::SET_OF<MultiplexTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class entryNumbers
    entryNumbers::const_reference get_entryNumbers () const;
    entryNumbers::reference ref_entryNumbers ();
    entryNumbers::reference set_entryNumbers ();
    entryNumbers::reference set_entryNumbers (entryNumbers::const_reference value);
    class rejectionDescriptions {
      public:
        typedef ASN1::SET_OF<RequestMultiplexEntryRejectionDescriptions,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rejectionDescriptions
    rejectionDescriptions::const_reference get_rejectionDescriptions () const;
    rejectionDescriptions::reference ref_rejectionDescriptions ();
    rejectionDescriptions::reference set_rejectionDescriptions ();
    rejectionDescriptions::reference set_rejectionDescriptions (rejectionDescriptions::const_reference value);
    void swap(RequestMultiplexEntryReject& other);
    RequestMultiplexEntryReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// EncryptionMode
//

class EncryptionMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionMode(const void* info) : Inherited(info) {}
  public:
    EncryptionMode() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class h233Encryption {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h233Encryption

    h233Encryption::reference select_h233Encryption (); 
    bool h233Encryption_isSelected() const;

    EncryptionMode(nonStandard::Id id, nonStandard::const_reference value);
    EncryptionMode(h233Encryption::Id id, h233Encryption::const_reference value);
    void swap(EncryptionMode & other);
    EncryptionMode(const EncryptionMode & other)
    : Inherited(other) {} 

    EncryptionMode & operator = (const EncryptionMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    EncryptionMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// ConferenceRequest
//

class ConferenceRequest : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceRequest(const void* info) : Inherited(info) {}
  public:
    ConferenceRequest() : Inherited(&theInfo) {}
    class terminalListRequest {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalListRequest

    terminalListRequest::reference select_terminalListRequest (); 
    bool terminalListRequest_isSelected() const;

    class makeMeChair {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class makeMeChair

    makeMeChair::reference select_makeMeChair (); 
    bool makeMeChair_isSelected() const;

    class cancelMakeMeChair {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelMakeMeChair

    cancelMakeMeChair::reference select_cancelMakeMeChair (); 
    bool cancelMakeMeChair_isSelected() const;

    class dropTerminal {
      public:
        enum Id { id_ = 3 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dropTerminal

    dropTerminal::const_reference get_dropTerminal () const;
    dropTerminal::reference ref_dropTerminal (); 
    dropTerminal::reference select_dropTerminal (); 
    dropTerminal::reference select_dropTerminal (dropTerminal::const_reference value); 
    bool dropTerminal_isSelected() const;

    class requestTerminalID {
      public:
        enum Id { id_ = 4 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestTerminalID

    requestTerminalID::const_reference get_requestTerminalID () const;
    requestTerminalID::reference ref_requestTerminalID (); 
    requestTerminalID::reference select_requestTerminalID (); 
    requestTerminalID::reference select_requestTerminalID (requestTerminalID::const_reference value); 
    bool requestTerminalID_isSelected() const;

    class enterH243Password {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enterH243Password

    enterH243Password::reference select_enterH243Password (); 
    bool enterH243Password_isSelected() const;

    class enterH243TerminalID {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enterH243TerminalID

    enterH243TerminalID::reference select_enterH243TerminalID (); 
    bool enterH243TerminalID_isSelected() const;

    class enterH243ConferenceID {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enterH243ConferenceID

    enterH243ConferenceID::reference select_enterH243ConferenceID (); 
    bool enterH243ConferenceID_isSelected() const;

    class enterExtensionAddress {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enterExtensionAddress

    enterExtensionAddress::reference select_enterExtensionAddress (); 
    bool enterExtensionAddress_isSelected() const;

    class requestChairTokenOwner {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestChairTokenOwner

    requestChairTokenOwner::reference select_requestChairTokenOwner (); 
    bool requestChairTokenOwner_isSelected() const;

    class requestTerminalCertificate {
      public:
        enum Id { id_ = 10 };
        typedef ConferenceRequest_requestTerminalCertificate value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestTerminalCertificate

    requestTerminalCertificate::const_reference get_requestTerminalCertificate () const;
    requestTerminalCertificate::reference ref_requestTerminalCertificate (); 
    requestTerminalCertificate::reference select_requestTerminalCertificate (); 
    requestTerminalCertificate::reference select_requestTerminalCertificate (requestTerminalCertificate::const_reference value); 
    bool requestTerminalCertificate_isSelected() const;

    class broadcastMyLogicalChannel {
      public:
        enum Id { id_ = 11 };
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class broadcastMyLogicalChannel

    broadcastMyLogicalChannel::const_reference get_broadcastMyLogicalChannel () const;
    broadcastMyLogicalChannel::reference ref_broadcastMyLogicalChannel (); 
    broadcastMyLogicalChannel::reference select_broadcastMyLogicalChannel (); 
    broadcastMyLogicalChannel::reference select_broadcastMyLogicalChannel (broadcastMyLogicalChannel::value_type::int_type value); 
    bool broadcastMyLogicalChannel_isSelected() const;

    class makeTerminalBroadcaster {
      public:
        enum Id { id_ = 12 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class makeTerminalBroadcaster

    makeTerminalBroadcaster::const_reference get_makeTerminalBroadcaster () const;
    makeTerminalBroadcaster::reference ref_makeTerminalBroadcaster (); 
    makeTerminalBroadcaster::reference select_makeTerminalBroadcaster (); 
    makeTerminalBroadcaster::reference select_makeTerminalBroadcaster (makeTerminalBroadcaster::const_reference value); 
    bool makeTerminalBroadcaster_isSelected() const;

    class sendThisSource {
      public:
        enum Id { id_ = 13 };
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendThisSource

    sendThisSource::const_reference get_sendThisSource () const;
    sendThisSource::reference ref_sendThisSource (); 
    sendThisSource::reference select_sendThisSource (); 
    sendThisSource::reference select_sendThisSource (sendThisSource::const_reference value); 
    bool sendThisSource_isSelected() const;

    class requestAllTerminalIDs {
      public:
        enum Id { id_ = 14 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestAllTerminalIDs

    requestAllTerminalIDs::reference select_requestAllTerminalIDs (); 
    bool requestAllTerminalIDs_isSelected() const;

    class remoteMCRequest {
      public:
        enum Id { id_ = 15 };
        typedef RemoteMCRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class remoteMCRequest

    remoteMCRequest::const_reference get_remoteMCRequest () const;
    remoteMCRequest::reference ref_remoteMCRequest (); 
    remoteMCRequest::reference select_remoteMCRequest (); 
    remoteMCRequest::reference select_remoteMCRequest (remoteMCRequest::const_reference value); 
    bool remoteMCRequest_isSelected() const;

    ConferenceRequest(terminalListRequest::Id id, terminalListRequest::const_reference value);
    ConferenceRequest(makeMeChair::Id id, makeMeChair::const_reference value);
    ConferenceRequest(cancelMakeMeChair::Id id, cancelMakeMeChair::const_reference value);
    ConferenceRequest(dropTerminal::Id id, dropTerminal::const_reference value);
    ConferenceRequest(requestTerminalID::Id id, requestTerminalID::const_reference value);
    ConferenceRequest(enterH243Password::Id id, enterH243Password::const_reference value);
    ConferenceRequest(enterH243TerminalID::Id id, enterH243TerminalID::const_reference value);
    ConferenceRequest(enterH243ConferenceID::Id id, enterH243ConferenceID::const_reference value);
    ConferenceRequest(enterExtensionAddress::Id id, enterExtensionAddress::const_reference value);
    ConferenceRequest(requestChairTokenOwner::Id id, requestChairTokenOwner::const_reference value);
    ConferenceRequest(requestTerminalCertificate::Id id, requestTerminalCertificate::const_reference value);
    ConferenceRequest(broadcastMyLogicalChannel::Id id, broadcastMyLogicalChannel::value_type::int_type value);
    ConferenceRequest(makeTerminalBroadcaster::Id id, makeTerminalBroadcaster::const_reference value);
    ConferenceRequest(sendThisSource::Id id, sendThisSource::const_reference value);
    ConferenceRequest(requestAllTerminalIDs::Id id, requestAllTerminalIDs::const_reference value);
    ConferenceRequest(remoteMCRequest::Id id, remoteMCRequest::const_reference value);
    void swap(ConferenceRequest & other);
    ConferenceRequest(const ConferenceRequest & other)
    : Inherited(other) {} 

    ConferenceRequest & operator = (const ConferenceRequest & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceRequest * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[16];
    static const char* selectionNames[16];
};

//
// RequestAllTerminalIDsResponse
//

class RequestAllTerminalIDsResponse : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestAllTerminalIDsResponse(const void* info) : Inherited(info) {}
  public:
    RequestAllTerminalIDsResponse() : Inherited(&theInfo) {}
    RequestAllTerminalIDsResponse(const RequestAllTerminalIDsResponse & other) : Inherited(other)
    {}
    RequestAllTerminalIDsResponse& operator = (const RequestAllTerminalIDsResponse& other)
    { Inherited::operator = (other); return *this; } 
    class terminalInformation {
      public:
        typedef ASN1::SEQUENCE_OF<TerminalInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalInformation
    terminalInformation::const_reference get_terminalInformation () const;
    terminalInformation::reference ref_terminalInformation ();
    terminalInformation::reference set_terminalInformation ();
    terminalInformation::reference set_terminalInformation (terminalInformation::const_reference value);
    void swap(RequestAllTerminalIDsResponse& other);
    RequestAllTerminalIDsResponse * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// VCCapability_availableBitRates
//

class VCCapability_availableBitRates : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability_availableBitRates(const void* info) : Inherited(info) {}
  public:
    VCCapability_availableBitRates() : Inherited(&theInfo) {}
    VCCapability_availableBitRates(const VCCapability_availableBitRates & other) : Inherited(other)
    {}
    VCCapability_availableBitRates& operator = (const VCCapability_availableBitRates& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef VCCapability_availableBitRates_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(VCCapability_availableBitRates& other);
    VCCapability_availableBitRates * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// CustomPictureFormat_mPI
//

class CustomPictureFormat_mPI : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CustomPictureFormat_mPI(const void* info) : Inherited(info) {}
  public:
    CustomPictureFormat_mPI() : Inherited(&theInfo) {}
    CustomPictureFormat_mPI(const CustomPictureFormat_mPI & other) : Inherited(other)
    {}
    CustomPictureFormat_mPI& operator = (const CustomPictureFormat_mPI& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_standardMPI,
      e_customPCF
    };

    class standardMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 31>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class standardMPI
    standardMPI::const_reference get_standardMPI () const;
    standardMPI::reference ref_standardMPI ();
    standardMPI::reference set_standardMPI ();
    standardMPI::reference set_standardMPI (standardMPI::value_type::int_type value);
    void omit_standardMPI ();
    bool standardMPI_isPresent () const;
    class customPCF {
      public:
        typedef CustomPictureFormat_mPI_customPCF value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class customPCF
    customPCF::const_reference get_customPCF () const;
    customPCF::reference ref_customPCF ();
    customPCF::reference set_customPCF ();
    customPCF::reference set_customPCF (customPCF::const_reference value);
    void omit_customPCF ();
    bool customPCF_isPresent () const;
    void swap(CustomPictureFormat_mPI& other);
    CustomPictureFormat_mPI * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// CustomPictureFormat_pixelAspectInformation
//

class CustomPictureFormat_pixelAspectInformation : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CustomPictureFormat_pixelAspectInformation(const void* info) : Inherited(info) {}
  public:
    CustomPictureFormat_pixelAspectInformation() : Inherited(&theInfo) {}
    class anyPixelAspectRatio {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class anyPixelAspectRatio

    anyPixelAspectRatio::const_reference get_anyPixelAspectRatio () const;
    anyPixelAspectRatio::reference ref_anyPixelAspectRatio (); 
    anyPixelAspectRatio::reference select_anyPixelAspectRatio (); 
    anyPixelAspectRatio::reference select_anyPixelAspectRatio (bool value); 
    bool anyPixelAspectRatio_isSelected() const;

    class pixelAspectCode {
      public:
        enum Id { id_ = 1 };
        typedef CustomPictureFormat_pixelAspectInformation_pixelAspectCode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pixelAspectCode

    pixelAspectCode::const_reference get_pixelAspectCode () const;
    pixelAspectCode::reference ref_pixelAspectCode (); 
    pixelAspectCode::reference select_pixelAspectCode (); 
    pixelAspectCode::reference select_pixelAspectCode (pixelAspectCode::const_reference value); 
    bool pixelAspectCode_isSelected() const;

    class extendedPAR {
      public:
        enum Id { id_ = 2 };
        typedef CustomPictureFormat_pixelAspectInformation_extendedPAR value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class extendedPAR

    extendedPAR::const_reference get_extendedPAR () const;
    extendedPAR::reference ref_extendedPAR (); 
    extendedPAR::reference select_extendedPAR (); 
    extendedPAR::reference select_extendedPAR (extendedPAR::const_reference value); 
    bool extendedPAR_isSelected() const;

    CustomPictureFormat_pixelAspectInformation(anyPixelAspectRatio::Id id, bool value);
    CustomPictureFormat_pixelAspectInformation(pixelAspectCode::Id id, pixelAspectCode::const_reference value);
    CustomPictureFormat_pixelAspectInformation(extendedPAR::Id id, extendedPAR::const_reference value);
    void swap(CustomPictureFormat_pixelAspectInformation & other);
    CustomPictureFormat_pixelAspectInformation(const CustomPictureFormat_pixelAspectInformation & other)
    : Inherited(other) {} 

    CustomPictureFormat_pixelAspectInformation & operator = (const CustomPictureFormat_pixelAspectInformation & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CustomPictureFormat_pixelAspectInformation * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// H223LogicalChannelParameters_adaptationLayerType
//

class H223LogicalChannelParameters_adaptationLayerType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223LogicalChannelParameters_adaptationLayerType(const void* info) : Inherited(info) {}
  public:
    H223LogicalChannelParameters_adaptationLayerType() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class al1Framed {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al1Framed

    al1Framed::reference select_al1Framed (); 
    bool al1Framed_isSelected() const;

    class al1NotFramed {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al1NotFramed

    al1NotFramed::reference select_al1NotFramed (); 
    bool al1NotFramed_isSelected() const;

    class al2WithoutSequenceNumbers {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al2WithoutSequenceNumbers

    al2WithoutSequenceNumbers::reference select_al2WithoutSequenceNumbers (); 
    bool al2WithoutSequenceNumbers_isSelected() const;

    class al2WithSequenceNumbers {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al2WithSequenceNumbers

    al2WithSequenceNumbers::reference select_al2WithSequenceNumbers (); 
    bool al2WithSequenceNumbers_isSelected() const;

    class al3 {
      public:
        enum Id { id_ = 5 };
        typedef H223LogicalChannelParameters_adaptationLayerType_al3 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al3

    al3::const_reference get_al3 () const;
    al3::reference ref_al3 (); 
    al3::reference select_al3 (); 
    al3::reference select_al3 (al3::const_reference value); 
    bool al3_isSelected() const;

    class al1M {
      public:
        enum Id { id_ = 6 };
        typedef H223AL1MParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al1M

    al1M::const_reference get_al1M () const;
    al1M::reference ref_al1M (); 
    al1M::reference select_al1M (); 
    al1M::reference select_al1M (al1M::const_reference value); 
    bool al1M_isSelected() const;

    class al2M {
      public:
        enum Id { id_ = 7 };
        typedef H223AL2MParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al2M

    al2M::const_reference get_al2M () const;
    al2M::reference ref_al2M (); 
    al2M::reference select_al2M (); 
    al2M::reference select_al2M (al2M::const_reference value); 
    bool al2M_isSelected() const;

    class al3M {
      public:
        enum Id { id_ = 8 };
        typedef H223AL3MParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al3M

    al3M::const_reference get_al3M () const;
    al3M::reference ref_al3M (); 
    al3M::reference select_al3M (); 
    al3M::reference select_al3M (al3M::const_reference value); 
    bool al3M_isSelected() const;

    H223LogicalChannelParameters_adaptationLayerType(nonStandard::Id id, nonStandard::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al1Framed::Id id, al1Framed::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al1NotFramed::Id id, al1NotFramed::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al2WithoutSequenceNumbers::Id id, al2WithoutSequenceNumbers::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al2WithSequenceNumbers::Id id, al2WithSequenceNumbers::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al3::Id id, al3::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al1M::Id id, al1M::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al2M::Id id, al2M::const_reference value);
    H223LogicalChannelParameters_adaptationLayerType(al3M::Id id, al3M::const_reference value);
    void swap(H223LogicalChannelParameters_adaptationLayerType & other);
    H223LogicalChannelParameters_adaptationLayerType(const H223LogicalChannelParameters_adaptationLayerType & other)
    : Inherited(other) {} 

    H223LogicalChannelParameters_adaptationLayerType & operator = (const H223LogicalChannelParameters_adaptationLayerType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223LogicalChannelParameters_adaptationLayerType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[9];
    static const char* selectionNames[9];
};

//
// V76LogicalChannelParameters_mode
//

class V76LogicalChannelParameters_mode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76LogicalChannelParameters_mode(const void* info) : Inherited(info) {}
  public:
    V76LogicalChannelParameters_mode() : Inherited(&theInfo) {}
    class eRM {
      public:
        enum Id { id_ = 0 };
        typedef V76LogicalChannelParameters_mode_eRM value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class eRM

    eRM::const_reference get_eRM () const;
    eRM::reference ref_eRM (); 
    eRM::reference select_eRM (); 
    eRM::reference select_eRM (eRM::const_reference value); 
    bool eRM_isSelected() const;

    class uNERM {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class uNERM

    uNERM::reference select_uNERM (); 
    bool uNERM_isSelected() const;

    V76LogicalChannelParameters_mode(eRM::Id id, eRM::const_reference value);
    V76LogicalChannelParameters_mode(uNERM::Id id, uNERM::const_reference value);
    void swap(V76LogicalChannelParameters_mode & other);
    V76LogicalChannelParameters_mode(const V76LogicalChannelParameters_mode & other)
    : Inherited(other) {} 

    V76LogicalChannelParameters_mode & operator = (const V76LogicalChannelParameters_mode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    V76LogicalChannelParameters_mode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// RTPPayloadType_payloadDescriptor
//

class RTPPayloadType_payloadDescriptor : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RTPPayloadType_payloadDescriptor(const void* info) : Inherited(info) {}
  public:
    RTPPayloadType_payloadDescriptor() : Inherited(&theInfo) {}
    class nonStandardIdentifier {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardIdentifier

    nonStandardIdentifier::const_reference get_nonStandardIdentifier () const;
    nonStandardIdentifier::reference ref_nonStandardIdentifier (); 
    nonStandardIdentifier::reference select_nonStandardIdentifier (); 
    nonStandardIdentifier::reference select_nonStandardIdentifier (nonStandardIdentifier::const_reference value); 
    bool nonStandardIdentifier_isSelected() const;

    class rfc_number {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::ExtendableConstraint, 1, 32768>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc_number

    rfc_number::const_reference get_rfc_number () const;
    rfc_number::reference ref_rfc_number (); 
    rfc_number::reference select_rfc_number (); 
    rfc_number::reference select_rfc_number (rfc_number::value_type::int_type value); 
    bool rfc_number_isSelected() const;

    class oid {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class oid

    oid::const_reference get_oid () const;
    oid::reference ref_oid (); 
    oid::reference select_oid (); 
    oid::reference select_oid (oid::const_reference value); 
    bool oid_isSelected() const;

    RTPPayloadType_payloadDescriptor(nonStandardIdentifier::Id id, nonStandardIdentifier::const_reference value);
    RTPPayloadType_payloadDescriptor(rfc_number::Id id, rfc_number::value_type::int_type value);
    RTPPayloadType_payloadDescriptor(oid::Id id, oid::const_reference value);
    void swap(RTPPayloadType_payloadDescriptor & other);
    RTPPayloadType_payloadDescriptor(const RTPPayloadType_payloadDescriptor & other)
    : Inherited(other) {} 

    RTPPayloadType_payloadDescriptor & operator = (const RTPPayloadType_payloadDescriptor & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RTPPayloadType_payloadDescriptor * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// FECData_rfc2733
//

class FECData_rfc2733 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECData_rfc2733(const void* info) : Inherited(info) {}
  public:
    FECData_rfc2733() : Inherited(&theInfo) {}
    FECData_rfc2733(const FECData_rfc2733 & other) : Inherited(other)
    {}
    FECData_rfc2733& operator = (const FECData_rfc2733& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_fecScheme
    };

    class protectedPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protectedPayloadType
    protectedPayloadType::const_reference get_protectedPayloadType () const;
    protectedPayloadType::reference ref_protectedPayloadType ();
    protectedPayloadType::reference set_protectedPayloadType ();
    protectedPayloadType::reference set_protectedPayloadType (protectedPayloadType::value_type::int_type value);
    class fecScheme {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fecScheme
    fecScheme::const_reference get_fecScheme () const;
    fecScheme::reference ref_fecScheme ();
    fecScheme::reference set_fecScheme ();
    fecScheme::reference set_fecScheme (fecScheme::const_reference value);
    void omit_fecScheme ();
    bool fecScheme_isPresent () const;
    class pktMode {
      public:
        typedef FECData_rfc2733_pktMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pktMode
    pktMode::const_reference get_pktMode () const;
    pktMode::reference ref_pktMode ();
    pktMode::reference set_pktMode ();
    pktMode::reference set_pktMode (pktMode::const_reference value);
    void swap(FECData_rfc2733& other);
    FECData_rfc2733 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H223ModeParameters_adaptationLayerType
//

class H223ModeParameters_adaptationLayerType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223ModeParameters_adaptationLayerType(const void* info) : Inherited(info) {}
  public:
    H223ModeParameters_adaptationLayerType() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class al1Framed {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al1Framed

    al1Framed::reference select_al1Framed (); 
    bool al1Framed_isSelected() const;

    class al1NotFramed {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al1NotFramed

    al1NotFramed::reference select_al1NotFramed (); 
    bool al1NotFramed_isSelected() const;

    class al2WithoutSequenceNumbers {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al2WithoutSequenceNumbers

    al2WithoutSequenceNumbers::reference select_al2WithoutSequenceNumbers (); 
    bool al2WithoutSequenceNumbers_isSelected() const;

    class al2WithSequenceNumbers {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al2WithSequenceNumbers

    al2WithSequenceNumbers::reference select_al2WithSequenceNumbers (); 
    bool al2WithSequenceNumbers_isSelected() const;

    class al3 {
      public:
        enum Id { id_ = 5 };
        typedef H223ModeParameters_adaptationLayerType_al3 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al3

    al3::const_reference get_al3 () const;
    al3::reference ref_al3 (); 
    al3::reference select_al3 (); 
    al3::reference select_al3 (al3::const_reference value); 
    bool al3_isSelected() const;

    class al1M {
      public:
        enum Id { id_ = 6 };
        typedef H223AL1MParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al1M

    al1M::const_reference get_al1M () const;
    al1M::reference ref_al1M (); 
    al1M::reference select_al1M (); 
    al1M::reference select_al1M (al1M::const_reference value); 
    bool al1M_isSelected() const;

    class al2M {
      public:
        enum Id { id_ = 7 };
        typedef H223AL2MParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al2M

    al2M::const_reference get_al2M () const;
    al2M::reference ref_al2M (); 
    al2M::reference select_al2M (); 
    al2M::reference select_al2M (al2M::const_reference value); 
    bool al2M_isSelected() const;

    class al3M {
      public:
        enum Id { id_ = 8 };
        typedef H223AL3MParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class al3M

    al3M::const_reference get_al3M () const;
    al3M::reference ref_al3M (); 
    al3M::reference select_al3M (); 
    al3M::reference select_al3M (al3M::const_reference value); 
    bool al3M_isSelected() const;

    H223ModeParameters_adaptationLayerType(nonStandard::Id id, nonStandard::const_reference value);
    H223ModeParameters_adaptationLayerType(al1Framed::Id id, al1Framed::const_reference value);
    H223ModeParameters_adaptationLayerType(al1NotFramed::Id id, al1NotFramed::const_reference value);
    H223ModeParameters_adaptationLayerType(al2WithoutSequenceNumbers::Id id, al2WithoutSequenceNumbers::const_reference value);
    H223ModeParameters_adaptationLayerType(al2WithSequenceNumbers::Id id, al2WithSequenceNumbers::const_reference value);
    H223ModeParameters_adaptationLayerType(al3::Id id, al3::const_reference value);
    H223ModeParameters_adaptationLayerType(al1M::Id id, al1M::const_reference value);
    H223ModeParameters_adaptationLayerType(al2M::Id id, al2M::const_reference value);
    H223ModeParameters_adaptationLayerType(al3M::Id id, al3M::const_reference value);
    void swap(H223ModeParameters_adaptationLayerType & other);
    H223ModeParameters_adaptationLayerType(const H223ModeParameters_adaptationLayerType & other)
    : Inherited(other) {} 

    H223ModeParameters_adaptationLayerType & operator = (const H223ModeParameters_adaptationLayerType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H223ModeParameters_adaptationLayerType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[9];
    static const char* selectionNames[9];
};

//
// MultilinkResponse_addConnection
//

class MultilinkResponse_addConnection : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse_addConnection(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse_addConnection() : Inherited(&theInfo) {}
    MultilinkResponse_addConnection(const MultilinkResponse_addConnection & other) : Inherited(other)
    {}
    MultilinkResponse_addConnection& operator = (const MultilinkResponse_addConnection& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class responseCode {
      public:
        typedef MultilinkResponse_addConnection_responseCode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class responseCode
    responseCode::const_reference get_responseCode () const;
    responseCode::reference ref_responseCode ();
    responseCode::reference set_responseCode ();
    responseCode::reference set_responseCode (responseCode::const_reference value);
    void swap(MultilinkResponse_addConnection& other);
    MultilinkResponse_addConnection * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// EncryptionCommand_encryptionAlgorithmID
//

class EncryptionCommand_encryptionAlgorithmID : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionCommand_encryptionAlgorithmID(const void* info) : Inherited(info) {}
  public:
    EncryptionCommand_encryptionAlgorithmID() : Inherited(&theInfo) {}
    EncryptionCommand_encryptionAlgorithmID(const EncryptionCommand_encryptionAlgorithmID & other) : Inherited(other)
    {}
    EncryptionCommand_encryptionAlgorithmID& operator = (const EncryptionCommand_encryptionAlgorithmID& other)
    { Inherited::operator = (other); return *this; } 
    class h233AlgorithmIdentifier {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h233AlgorithmIdentifier
    h233AlgorithmIdentifier::const_reference get_h233AlgorithmIdentifier () const;
    h233AlgorithmIdentifier::reference ref_h233AlgorithmIdentifier ();
    h233AlgorithmIdentifier::reference set_h233AlgorithmIdentifier ();
    h233AlgorithmIdentifier::reference set_h233AlgorithmIdentifier (h233AlgorithmIdentifier::value_type::int_type value);
    class associatedAlgorithm {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class associatedAlgorithm
    associatedAlgorithm::const_reference get_associatedAlgorithm () const;
    associatedAlgorithm::reference ref_associatedAlgorithm ();
    associatedAlgorithm::reference set_associatedAlgorithm ();
    associatedAlgorithm::reference set_associatedAlgorithm (associatedAlgorithm::const_reference value);
    void swap(EncryptionCommand_encryptionAlgorithmID& other);
    EncryptionCommand_encryptionAlgorithmID * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// NewATMVCCommand_aal
//

class NewATMVCCommand_aal : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand_aal(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand_aal() : Inherited(&theInfo) {}
    class aal1 {
      public:
        enum Id { id_ = 0 };
        typedef NewATMVCCommand_aal_aal1 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal1

    aal1::const_reference get_aal1 () const;
    aal1::reference ref_aal1 (); 
    aal1::reference select_aal1 (); 
    aal1::reference select_aal1 (aal1::const_reference value); 
    bool aal1_isSelected() const;

    class aal5 {
      public:
        enum Id { id_ = 1 };
        typedef NewATMVCCommand_aal_aal5 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal5

    aal5::const_reference get_aal5 () const;
    aal5::reference ref_aal5 (); 
    aal5::reference select_aal5 (); 
    aal5::reference select_aal5 (aal5::const_reference value); 
    bool aal5_isSelected() const;

    NewATMVCCommand_aal(aal1::Id id, aal1::const_reference value);
    NewATMVCCommand_aal(aal5::Id id, aal5::const_reference value);
    void swap(NewATMVCCommand_aal & other);
    NewATMVCCommand_aal(const NewATMVCCommand_aal & other)
    : Inherited(other) {} 

    NewATMVCCommand_aal & operator = (const NewATMVCCommand_aal & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCCommand_aal * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// MiscellaneousIndication_type
//

class MiscellaneousIndication_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousIndication_type(const void* info) : Inherited(info) {}
  public:
    MiscellaneousIndication_type() : Inherited(&theInfo) {}
    class logicalChannelActive {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelActive

    logicalChannelActive::reference select_logicalChannelActive (); 
    bool logicalChannelActive_isSelected() const;

    class logicalChannelInactive {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelInactive

    logicalChannelInactive::reference select_logicalChannelInactive (); 
    bool logicalChannelInactive_isSelected() const;

    class multipointConference {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multipointConference

    multipointConference::reference select_multipointConference (); 
    bool multipointConference_isSelected() const;

    class cancelMultipointConference {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelMultipointConference

    cancelMultipointConference::reference select_cancelMultipointConference (); 
    bool cancelMultipointConference_isSelected() const;

    class multipointZeroComm {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multipointZeroComm

    multipointZeroComm::reference select_multipointZeroComm (); 
    bool multipointZeroComm_isSelected() const;

    class cancelMultipointZeroComm {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelMultipointZeroComm

    cancelMultipointZeroComm::reference select_cancelMultipointZeroComm (); 
    bool cancelMultipointZeroComm_isSelected() const;

    class multipointSecondaryStatus {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multipointSecondaryStatus

    multipointSecondaryStatus::reference select_multipointSecondaryStatus (); 
    bool multipointSecondaryStatus_isSelected() const;

    class cancelMultipointSecondaryStatus {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelMultipointSecondaryStatus

    cancelMultipointSecondaryStatus::reference select_cancelMultipointSecondaryStatus (); 
    bool cancelMultipointSecondaryStatus_isSelected() const;

    class videoIndicateReadyToActivate {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoIndicateReadyToActivate

    videoIndicateReadyToActivate::reference select_videoIndicateReadyToActivate (); 
    bool videoIndicateReadyToActivate_isSelected() const;

    class videoTemporalSpatialTradeOff {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 31>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoTemporalSpatialTradeOff

    videoTemporalSpatialTradeOff::const_reference get_videoTemporalSpatialTradeOff () const;
    videoTemporalSpatialTradeOff::reference ref_videoTemporalSpatialTradeOff (); 
    videoTemporalSpatialTradeOff::reference select_videoTemporalSpatialTradeOff (); 
    videoTemporalSpatialTradeOff::reference select_videoTemporalSpatialTradeOff (videoTemporalSpatialTradeOff::value_type::int_type value); 
    bool videoTemporalSpatialTradeOff_isSelected() const;

    class videoNotDecodedMBs {
      public:
        enum Id { id_ = 10 };
        typedef MiscellaneousIndication_type_videoNotDecodedMBs value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoNotDecodedMBs

    videoNotDecodedMBs::const_reference get_videoNotDecodedMBs () const;
    videoNotDecodedMBs::reference ref_videoNotDecodedMBs (); 
    videoNotDecodedMBs::reference select_videoNotDecodedMBs (); 
    videoNotDecodedMBs::reference select_videoNotDecodedMBs (videoNotDecodedMBs::const_reference value); 
    bool videoNotDecodedMBs_isSelected() const;

    class transportCapability {
      public:
        enum Id { id_ = 11 };
        typedef TransportCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportCapability

    transportCapability::const_reference get_transportCapability () const;
    transportCapability::reference ref_transportCapability (); 
    transportCapability::reference select_transportCapability (); 
    transportCapability::reference select_transportCapability (transportCapability::const_reference value); 
    bool transportCapability_isSelected() const;

    MiscellaneousIndication_type(logicalChannelActive::Id id, logicalChannelActive::const_reference value);
    MiscellaneousIndication_type(logicalChannelInactive::Id id, logicalChannelInactive::const_reference value);
    MiscellaneousIndication_type(multipointConference::Id id, multipointConference::const_reference value);
    MiscellaneousIndication_type(cancelMultipointConference::Id id, cancelMultipointConference::const_reference value);
    MiscellaneousIndication_type(multipointZeroComm::Id id, multipointZeroComm::const_reference value);
    MiscellaneousIndication_type(cancelMultipointZeroComm::Id id, cancelMultipointZeroComm::const_reference value);
    MiscellaneousIndication_type(multipointSecondaryStatus::Id id, multipointSecondaryStatus::const_reference value);
    MiscellaneousIndication_type(cancelMultipointSecondaryStatus::Id id, cancelMultipointSecondaryStatus::const_reference value);
    MiscellaneousIndication_type(videoIndicateReadyToActivate::Id id, videoIndicateReadyToActivate::const_reference value);
    MiscellaneousIndication_type(videoTemporalSpatialTradeOff::Id id, videoTemporalSpatialTradeOff::value_type::int_type value);
    MiscellaneousIndication_type(videoNotDecodedMBs::Id id, videoNotDecodedMBs::const_reference value);
    MiscellaneousIndication_type(transportCapability::Id id, transportCapability::const_reference value);
    void swap(MiscellaneousIndication_type & other);
    MiscellaneousIndication_type(const MiscellaneousIndication_type & other)
    : Inherited(other) {} 

    MiscellaneousIndication_type & operator = (const MiscellaneousIndication_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MiscellaneousIndication_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[12];
    static const char* selectionNames[12];
};

//
// NewATMVCIndication_aal
//

class NewATMVCIndication_aal : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication_aal(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication_aal() : Inherited(&theInfo) {}
    class aal1 {
      public:
        enum Id { id_ = 0 };
        typedef NewATMVCIndication_aal_aal1 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal1

    aal1::const_reference get_aal1 () const;
    aal1::reference ref_aal1 (); 
    aal1::reference select_aal1 (); 
    aal1::reference select_aal1 (aal1::const_reference value); 
    bool aal1_isSelected() const;

    class aal5 {
      public:
        enum Id { id_ = 1 };
        typedef NewATMVCIndication_aal_aal5 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal5

    aal5::const_reference get_aal5 () const;
    aal5::reference ref_aal5 (); 
    aal5::reference select_aal5 (); 
    aal5::reference select_aal5 (aal5::const_reference value); 
    bool aal5_isSelected() const;

    NewATMVCIndication_aal(aal1::Id id, aal1::const_reference value);
    NewATMVCIndication_aal(aal5::Id id, aal5::const_reference value);
    void swap(NewATMVCIndication_aal & other);
    NewATMVCIndication_aal(const NewATMVCIndication_aal & other)
    : Inherited(other) {} 

    NewATMVCIndication_aal & operator = (const NewATMVCIndication_aal & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NewATMVCIndication_aal * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// UserInputIndication_userInputSupportIndication
//

class UserInputIndication_userInputSupportIndication : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication_userInputSupportIndication(const void* info) : Inherited(info) {}
  public:
    UserInputIndication_userInputSupportIndication() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class basicString {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class basicString

    basicString::reference select_basicString (); 
    bool basicString_isSelected() const;

    class iA5String {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iA5String

    iA5String::reference select_iA5String (); 
    bool iA5String_isSelected() const;

    class generalString {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class generalString

    generalString::reference select_generalString (); 
    bool generalString_isSelected() const;

    class encryptedBasicString {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedBasicString

    encryptedBasicString::reference select_encryptedBasicString (); 
    bool encryptedBasicString_isSelected() const;

    class encryptedIA5String {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedIA5String

    encryptedIA5String::reference select_encryptedIA5String (); 
    bool encryptedIA5String_isSelected() const;

    class encryptedGeneralString {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedGeneralString

    encryptedGeneralString::reference select_encryptedGeneralString (); 
    bool encryptedGeneralString_isSelected() const;

    UserInputIndication_userInputSupportIndication(nonStandard::Id id, nonStandard::const_reference value);
    UserInputIndication_userInputSupportIndication(basicString::Id id, basicString::const_reference value);
    UserInputIndication_userInputSupportIndication(iA5String::Id id, iA5String::const_reference value);
    UserInputIndication_userInputSupportIndication(generalString::Id id, generalString::const_reference value);
    UserInputIndication_userInputSupportIndication(encryptedBasicString::Id id, encryptedBasicString::const_reference value);
    UserInputIndication_userInputSupportIndication(encryptedIA5String::Id id, encryptedIA5String::const_reference value);
    UserInputIndication_userInputSupportIndication(encryptedGeneralString::Id id, encryptedGeneralString::const_reference value);
    void swap(UserInputIndication_userInputSupportIndication & other);
    UserInputIndication_userInputSupportIndication(const UserInputIndication_userInputSupportIndication & other)
    : Inherited(other) {} 

    UserInputIndication_userInputSupportIndication & operator = (const UserInputIndication_userInputSupportIndication & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    UserInputIndication_userInputSupportIndication * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[7];
    static const char* selectionNames[7];
};

//
// DataApplicationCapability_application_t84
//

class DataApplicationCapability_application_t84 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataApplicationCapability_application_t84(const void* info) : Inherited(info) {}
  public:
    DataApplicationCapability_application_t84() : Inherited(&theInfo) {}
    DataApplicationCapability_application_t84(const DataApplicationCapability_application_t84 & other) : Inherited(other)
    {}
    DataApplicationCapability_application_t84& operator = (const DataApplicationCapability_application_t84& other)
    { Inherited::operator = (other); return *this; } 
    class t84Protocol {
      public:
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t84Protocol
    t84Protocol::const_reference get_t84Protocol () const;
    t84Protocol::reference ref_t84Protocol ();
    t84Protocol::reference set_t84Protocol ();
    t84Protocol::reference set_t84Protocol (t84Protocol::const_reference value);
    class t84Profile {
      public:
        typedef T84Profile value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t84Profile
    t84Profile::const_reference get_t84Profile () const;
    t84Profile::reference ref_t84Profile ();
    t84Profile::reference set_t84Profile ();
    t84Profile::reference set_t84Profile (t84Profile::const_reference value);
    void swap(DataApplicationCapability_application_t84& other);
    DataApplicationCapability_application_t84 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DataApplicationCapability_application_nlpid
//

class DataApplicationCapability_application_nlpid : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataApplicationCapability_application_nlpid(const void* info) : Inherited(info) {}
  public:
    DataApplicationCapability_application_nlpid() : Inherited(&theInfo) {}
    DataApplicationCapability_application_nlpid(const DataApplicationCapability_application_nlpid & other) : Inherited(other)
    {}
    DataApplicationCapability_application_nlpid& operator = (const DataApplicationCapability_application_nlpid& other)
    { Inherited::operator = (other); return *this; } 
    class nlpidProtocol {
      public:
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nlpidProtocol
    nlpidProtocol::const_reference get_nlpidProtocol () const;
    nlpidProtocol::reference ref_nlpidProtocol ();
    nlpidProtocol::reference set_nlpidProtocol ();
    nlpidProtocol::reference set_nlpidProtocol (nlpidProtocol::const_reference value);
    class nlpidData {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nlpidData
    nlpidData::const_reference get_nlpidData () const;
    nlpidData::reference ref_nlpidData ();
    nlpidData::reference set_nlpidData ();
    nlpidData::reference set_nlpidData (const std::vector<char>& value);
    void swap(DataApplicationCapability_application_nlpid& other);
    DataApplicationCapability_application_nlpid * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DataApplicationCapability_application_t38fax
//

class DataApplicationCapability_application_t38fax : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataApplicationCapability_application_t38fax(const void* info) : Inherited(info) {}
  public:
    DataApplicationCapability_application_t38fax() : Inherited(&theInfo) {}
    DataApplicationCapability_application_t38fax(const DataApplicationCapability_application_t38fax & other) : Inherited(other)
    {}
    DataApplicationCapability_application_t38fax& operator = (const DataApplicationCapability_application_t38fax& other)
    { Inherited::operator = (other); return *this; } 
    class t38FaxProtocol {
      public:
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxProtocol
    t38FaxProtocol::const_reference get_t38FaxProtocol () const;
    t38FaxProtocol::reference ref_t38FaxProtocol ();
    t38FaxProtocol::reference set_t38FaxProtocol ();
    t38FaxProtocol::reference set_t38FaxProtocol (t38FaxProtocol::const_reference value);
    class t38FaxProfile {
      public:
        typedef T38FaxProfile value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxProfile
    t38FaxProfile::const_reference get_t38FaxProfile () const;
    t38FaxProfile::reference ref_t38FaxProfile ();
    t38FaxProfile::reference set_t38FaxProfile ();
    t38FaxProfile::reference set_t38FaxProfile (t38FaxProfile::const_reference value);
    void swap(DataApplicationCapability_application_t38fax& other);
    DataApplicationCapability_application_t38fax * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DepFECData_rfc2733_mode
//

class DepFECData_rfc2733_mode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECData_rfc2733_mode(const void* info) : Inherited(info) {}
  public:
    DepFECData_rfc2733_mode() : Inherited(&theInfo) {}
    class redundancyEncoding {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncoding

    redundancyEncoding::reference select_redundancyEncoding (); 
    bool redundancyEncoding_isSelected() const;

    class separateStream {
      public:
        enum Id { id_ = 1 };
        typedef DepFECData_rfc2733_mode_separateStream value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateStream

    separateStream::const_reference get_separateStream () const;
    separateStream::reference ref_separateStream (); 
    separateStream::reference select_separateStream (); 
    separateStream::reference select_separateStream (separateStream::const_reference value); 
    bool separateStream_isSelected() const;

    DepFECData_rfc2733_mode(redundancyEncoding::Id id, redundancyEncoding::const_reference value);
    DepFECData_rfc2733_mode(separateStream::Id id, separateStream::const_reference value);
    void swap(DepFECData_rfc2733_mode & other);
    DepFECData_rfc2733_mode(const DepFECData_rfc2733_mode & other)
    : Inherited(other) {} 

    DepFECData_rfc2733_mode & operator = (const DepFECData_rfc2733_mode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DepFECData_rfc2733_mode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// DataMode_application_nlpid
//

class DataMode_application_nlpid : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataMode_application_nlpid(const void* info) : Inherited(info) {}
  public:
    DataMode_application_nlpid() : Inherited(&theInfo) {}
    DataMode_application_nlpid(const DataMode_application_nlpid & other) : Inherited(other)
    {}
    DataMode_application_nlpid& operator = (const DataMode_application_nlpid& other)
    { Inherited::operator = (other); return *this; } 
    class nlpidProtocol {
      public:
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nlpidProtocol
    nlpidProtocol::const_reference get_nlpidProtocol () const;
    nlpidProtocol::reference ref_nlpidProtocol ();
    nlpidProtocol::reference set_nlpidProtocol ();
    nlpidProtocol::reference set_nlpidProtocol (nlpidProtocol::const_reference value);
    class nlpidData {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nlpidData
    nlpidData::const_reference get_nlpidData () const;
    nlpidData::reference ref_nlpidData ();
    nlpidData::reference set_nlpidData ();
    nlpidData::reference set_nlpidData (const std::vector<char>& value);
    void swap(DataMode_application_nlpid& other);
    DataMode_application_nlpid * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DataMode_application_t38fax
//

class DataMode_application_t38fax : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataMode_application_t38fax(const void* info) : Inherited(info) {}
  public:
    DataMode_application_t38fax() : Inherited(&theInfo) {}
    DataMode_application_t38fax(const DataMode_application_t38fax & other) : Inherited(other)
    {}
    DataMode_application_t38fax& operator = (const DataMode_application_t38fax& other)
    { Inherited::operator = (other); return *this; } 
    class t38FaxProtocol {
      public:
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxProtocol
    t38FaxProtocol::const_reference get_t38FaxProtocol () const;
    t38FaxProtocol::reference ref_t38FaxProtocol ();
    t38FaxProtocol::reference set_t38FaxProtocol ();
    t38FaxProtocol::reference set_t38FaxProtocol (t38FaxProtocol::const_reference value);
    class t38FaxProfile {
      public:
        typedef T38FaxProfile value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38FaxProfile
    t38FaxProfile::const_reference get_t38FaxProfile () const;
    t38FaxProfile::reference ref_t38FaxProfile ();
    t38FaxProfile::reference set_t38FaxProfile ();
    t38FaxProfile::reference set_t38FaxProfile (t38FaxProfile::const_reference value);
    void swap(DataMode_application_t38fax& other);
    DataMode_application_t38fax * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// NonStandardMessage
//

class NonStandardMessage : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NonStandardMessage(const void* info) : Inherited(info) {}
  public:
    NonStandardMessage() : Inherited(&theInfo) {}
    NonStandardMessage(const NonStandardMessage & other) : Inherited(other)
    {}
    NonStandardMessage& operator = (const NonStandardMessage& other)
    { Inherited::operator = (other); return *this; } 
    class nonStandardData {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandardData
    nonStandardData::const_reference get_nonStandardData () const;
    nonStandardData::reference ref_nonStandardData ();
    nonStandardData::reference set_nonStandardData ();
    nonStandardData::reference set_nonStandardData (nonStandardData::const_reference value);
    void swap(NonStandardMessage& other);
    NonStandardMessage * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// VCCapability
//

class VCCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VCCapability(const void* info) : Inherited(info) {}
  public:
    VCCapability() : Inherited(&theInfo) {}
    VCCapability(const VCCapability & other) : Inherited(other)
    {}
    VCCapability& operator = (const VCCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_aal1,
      e_aal5,
      e_aal1ViaGateway
    };

    class aal1 {
      public:
        typedef VCCapability_aal1 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal1
    aal1::const_reference get_aal1 () const;
    aal1::reference ref_aal1 ();
    aal1::reference set_aal1 ();
    aal1::reference set_aal1 (aal1::const_reference value);
    void omit_aal1 ();
    bool aal1_isPresent () const;
    class aal5 {
      public:
        typedef VCCapability_aal5 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal5
    aal5::const_reference get_aal5 () const;
    aal5::reference ref_aal5 ();
    aal5::reference set_aal5 ();
    aal5::reference set_aal5 (aal5::const_reference value);
    void omit_aal5 ();
    bool aal5_isPresent () const;
    class transportStream {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportStream
    transportStream::const_reference get_transportStream () const;
    transportStream::reference ref_transportStream ();
    transportStream::reference set_transportStream ();
    transportStream::reference set_transportStream (bool value);
    class programStream {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class programStream
    programStream::const_reference get_programStream () const;
    programStream::reference ref_programStream ();
    programStream::reference set_programStream ();
    programStream::reference set_programStream (bool value);
    class availableBitRates {
      public:
        typedef VCCapability_availableBitRates value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class availableBitRates
    availableBitRates::const_reference get_availableBitRates () const;
    availableBitRates::reference ref_availableBitRates ();
    availableBitRates::reference set_availableBitRates ();
    availableBitRates::reference set_availableBitRates (availableBitRates::const_reference value);
    class aal1ViaGateway {
      public:
        typedef VCCapability_aal1ViaGateway value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal1ViaGateway
    aal1ViaGateway::const_reference get_aal1ViaGateway () const;
    aal1ViaGateway::reference ref_aal1ViaGateway ();
    aal1ViaGateway::reference set_aal1ViaGateway ();
    aal1ViaGateway::reference set_aal1ViaGateway (aal1ViaGateway::const_reference value);
    void omit_aal1ViaGateway ();
    bool aal1ViaGateway_isPresent () const;
    void swap(VCCapability& other);
    VCCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// RedundancyEncodingMethod
//

class RedundancyEncodingMethod : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingMethod(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingMethod() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class rtpAudioRedundancyEncoding {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtpAudioRedundancyEncoding

    rtpAudioRedundancyEncoding::reference select_rtpAudioRedundancyEncoding (); 
    bool rtpAudioRedundancyEncoding_isSelected() const;

    class rtpH263VideoRedundancyEncoding {
      public:
        enum Id { id_ = 2 };
        typedef RTPH263VideoRedundancyEncoding value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtpH263VideoRedundancyEncoding

    rtpH263VideoRedundancyEncoding::const_reference get_rtpH263VideoRedundancyEncoding () const;
    rtpH263VideoRedundancyEncoding::reference ref_rtpH263VideoRedundancyEncoding (); 
    rtpH263VideoRedundancyEncoding::reference select_rtpH263VideoRedundancyEncoding (); 
    rtpH263VideoRedundancyEncoding::reference select_rtpH263VideoRedundancyEncoding (rtpH263VideoRedundancyEncoding::const_reference value); 
    bool rtpH263VideoRedundancyEncoding_isSelected() const;

    RedundancyEncodingMethod(nonStandard::Id id, nonStandard::const_reference value);
    RedundancyEncodingMethod(rtpAudioRedundancyEncoding::Id id, rtpAudioRedundancyEncoding::const_reference value);
    RedundancyEncodingMethod(rtpH263VideoRedundancyEncoding::Id id, rtpH263VideoRedundancyEncoding::const_reference value);
    void swap(RedundancyEncodingMethod & other);
    RedundancyEncodingMethod(const RedundancyEncodingMethod & other)
    : Inherited(other) {} 

    RedundancyEncodingMethod & operator = (const RedundancyEncodingMethod & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RedundancyEncodingMethod * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// CustomPictureFormat
//

class CustomPictureFormat : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CustomPictureFormat(const void* info) : Inherited(info) {}
  public:
    CustomPictureFormat() : Inherited(&theInfo) {}
    CustomPictureFormat(const CustomPictureFormat & other) : Inherited(other)
    {}
    CustomPictureFormat& operator = (const CustomPictureFormat& other)
    { Inherited::operator = (other); return *this; } 
    class maxCustomPictureWidth {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxCustomPictureWidth
    maxCustomPictureWidth::const_reference get_maxCustomPictureWidth () const;
    maxCustomPictureWidth::reference ref_maxCustomPictureWidth ();
    maxCustomPictureWidth::reference set_maxCustomPictureWidth ();
    maxCustomPictureWidth::reference set_maxCustomPictureWidth (maxCustomPictureWidth::value_type::int_type value);
    class maxCustomPictureHeight {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxCustomPictureHeight
    maxCustomPictureHeight::const_reference get_maxCustomPictureHeight () const;
    maxCustomPictureHeight::reference ref_maxCustomPictureHeight ();
    maxCustomPictureHeight::reference set_maxCustomPictureHeight ();
    maxCustomPictureHeight::reference set_maxCustomPictureHeight (maxCustomPictureHeight::value_type::int_type value);
    class minCustomPictureWidth {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class minCustomPictureWidth
    minCustomPictureWidth::const_reference get_minCustomPictureWidth () const;
    minCustomPictureWidth::reference ref_minCustomPictureWidth ();
    minCustomPictureWidth::reference set_minCustomPictureWidth ();
    minCustomPictureWidth::reference set_minCustomPictureWidth (minCustomPictureWidth::value_type::int_type value);
    class minCustomPictureHeight {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 2048>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class minCustomPictureHeight
    minCustomPictureHeight::const_reference get_minCustomPictureHeight () const;
    minCustomPictureHeight::reference ref_minCustomPictureHeight ();
    minCustomPictureHeight::reference set_minCustomPictureHeight ();
    minCustomPictureHeight::reference set_minCustomPictureHeight (minCustomPictureHeight::value_type::int_type value);
    class mPI {
      public:
        typedef CustomPictureFormat_mPI value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mPI
    mPI::const_reference get_mPI () const;
    mPI::reference ref_mPI ();
    mPI::reference set_mPI ();
    mPI::reference set_mPI (mPI::const_reference value);
    class pixelAspectInformation {
      public:
        typedef CustomPictureFormat_pixelAspectInformation value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pixelAspectInformation
    pixelAspectInformation::const_reference get_pixelAspectInformation () const;
    pixelAspectInformation::reference ref_pixelAspectInformation ();
    pixelAspectInformation::reference set_pixelAspectInformation ();
    pixelAspectInformation::reference set_pixelAspectInformation (pixelAspectInformation::const_reference value);
    void swap(CustomPictureFormat& other);
    CustomPictureFormat * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

typedef ASN1::SEQUENCE_OF<MediaEncryptionAlgorithm,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  EncryptionCapability;

//
// GenericParameter
//

class ParameterValue;

class GenericParameter : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    GenericParameter(const void* info) : Inherited(info) {}
  public:
    GenericParameter() : Inherited(&theInfo) {}
    GenericParameter(const GenericParameter & other) : Inherited(other)
    {}
    GenericParameter& operator = (const GenericParameter& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_supersedes
    };

    class parameterIdentifier {
      public:
        typedef ParameterIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class parameterIdentifier
    parameterIdentifier::const_reference get_parameterIdentifier () const;
    parameterIdentifier::reference ref_parameterIdentifier ();
    parameterIdentifier::reference set_parameterIdentifier ();
    parameterIdentifier::reference set_parameterIdentifier (parameterIdentifier::const_reference value);
    class parameterValue {
      public:
        typedef ParameterValue value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class parameterValue
    parameterValue::const_reference get_parameterValue () const;
    parameterValue::reference ref_parameterValue ();
    parameterValue::reference set_parameterValue ();
    parameterValue::reference set_parameterValue (parameterValue::const_reference value);
    class supersedes {
      public:
        typedef ASN1::SEQUENCE_OF<ParameterIdentifier>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class supersedes
    supersedes::const_reference get_supersedes () const;
    supersedes::reference ref_supersedes ();
    supersedes::reference set_supersedes ();
    supersedes::reference set_supersedes (supersedes::const_reference value);
    void omit_supersedes ();
    bool supersedes_isPresent () const;
    void swap(GenericParameter& other);
    GenericParameter * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// ParameterValue
//

class ParameterValue : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ParameterValue(const void* info) : Inherited(info) {}
  public:
    ParameterValue() : Inherited(&theInfo) {}
    class logical {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logical

    logical::reference select_logical (); 
    bool logical_isSelected() const;

    class booleanArray {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class booleanArray

    booleanArray::const_reference get_booleanArray () const;
    booleanArray::reference ref_booleanArray (); 
    booleanArray::reference select_booleanArray (); 
    booleanArray::reference select_booleanArray (booleanArray::value_type::int_type value); 
    bool booleanArray_isSelected() const;

    class unsignedMin {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unsignedMin

    unsignedMin::const_reference get_unsignedMin () const;
    unsignedMin::reference ref_unsignedMin (); 
    unsignedMin::reference select_unsignedMin (); 
    unsignedMin::reference select_unsignedMin (unsignedMin::value_type::int_type value); 
    bool unsignedMin_isSelected() const;

    class unsignedMax {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unsignedMax

    unsignedMax::const_reference get_unsignedMax () const;
    unsignedMax::reference ref_unsignedMax (); 
    unsignedMax::reference select_unsignedMax (); 
    unsignedMax::reference select_unsignedMax (unsignedMax::value_type::int_type value); 
    bool unsignedMax_isSelected() const;

    class unsigned32Min {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unsigned32Min

    unsigned32Min::const_reference get_unsigned32Min () const;
    unsigned32Min::reference ref_unsigned32Min (); 
    unsigned32Min::reference select_unsigned32Min (); 
    unsigned32Min::reference select_unsigned32Min (unsigned32Min::value_type::int_type value); 
    bool unsigned32Min_isSelected() const;

    class unsigned32Max {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unsigned32Max

    unsigned32Max::const_reference get_unsigned32Max () const;
    unsigned32Max::reference ref_unsigned32Max (); 
    unsigned32Max::reference select_unsigned32Max (); 
    unsigned32Max::reference select_unsigned32Max (unsigned32Max::value_type::int_type value); 
    bool unsigned32Max_isSelected() const;

    class octetString {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class octetString

    octetString::const_reference get_octetString () const;
    octetString::reference ref_octetString (); 
    octetString::reference select_octetString (); 
    octetString::reference select_octetString (const std::vector<char>& value); 
    bool octetString_isSelected() const;

    class genericParameter {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::SEQUENCE_OF<GenericParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericParameter

    genericParameter::const_reference get_genericParameter () const;
    genericParameter::reference ref_genericParameter (); 
    genericParameter::reference select_genericParameter (); 
    genericParameter::reference select_genericParameter (genericParameter::const_reference value); 
    bool genericParameter_isSelected() const;

    ParameterValue(logical::Id id, logical::const_reference value);
    ParameterValue(booleanArray::Id id, booleanArray::value_type::int_type value);
    ParameterValue(unsignedMin::Id id, unsignedMin::value_type::int_type value);
    ParameterValue(unsignedMax::Id id, unsignedMax::value_type::int_type value);
    ParameterValue(unsigned32Min::Id id, unsigned32Min::value_type::int_type value);
    ParameterValue(unsigned32Max::Id id, unsigned32Max::value_type::int_type value);
    ParameterValue(octetString::Id id, const std::vector<char>& value);
    ParameterValue(genericParameter::Id id, genericParameter::const_reference value);
    void swap(ParameterValue & other);
    ParameterValue(const ParameterValue & other)
    : Inherited(other) {} 

    ParameterValue & operator = (const ParameterValue & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ParameterValue * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[8];
    static const char* selectionNames[8];
};

//
// H223LogicalChannelParameters
//

class H223LogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223LogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    H223LogicalChannelParameters() : Inherited(&theInfo) {}
    H223LogicalChannelParameters(const H223LogicalChannelParameters & other) : Inherited(other)
    {}
    H223LogicalChannelParameters& operator = (const H223LogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    class adaptationLayerType {
      public:
        typedef H223LogicalChannelParameters_adaptationLayerType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class adaptationLayerType
    adaptationLayerType::const_reference get_adaptationLayerType () const;
    adaptationLayerType::reference ref_adaptationLayerType ();
    adaptationLayerType::reference set_adaptationLayerType ();
    adaptationLayerType::reference set_adaptationLayerType (adaptationLayerType::const_reference value);
    class segmentableFlag {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class segmentableFlag
    segmentableFlag::const_reference get_segmentableFlag () const;
    segmentableFlag::reference ref_segmentableFlag ();
    segmentableFlag::reference set_segmentableFlag ();
    segmentableFlag::reference set_segmentableFlag (bool value);
    void swap(H223LogicalChannelParameters& other);
    H223LogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// V76LogicalChannelParameters
//

class V76LogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    V76LogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    V76LogicalChannelParameters() : Inherited(&theInfo) {}
    V76LogicalChannelParameters(const V76LogicalChannelParameters & other) : Inherited(other)
    {}
    V76LogicalChannelParameters& operator = (const V76LogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    class hdlcParameters {
      public:
        typedef V76HDLCParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hdlcParameters
    hdlcParameters::const_reference get_hdlcParameters () const;
    hdlcParameters::reference ref_hdlcParameters ();
    hdlcParameters::reference set_hdlcParameters ();
    hdlcParameters::reference set_hdlcParameters (hdlcParameters::const_reference value);
    class suspendResume {
      public:
        typedef V76LogicalChannelParameters_suspendResume value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class suspendResume
    suspendResume::const_reference get_suspendResume () const;
    suspendResume::reference ref_suspendResume ();
    suspendResume::reference set_suspendResume ();
    suspendResume::reference set_suspendResume (suspendResume::const_reference value);
    class uIH {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class uIH
    uIH::const_reference get_uIH () const;
    uIH::reference ref_uIH ();
    uIH::reference set_uIH ();
    uIH::reference set_uIH (bool value);
    class mode {
      public:
        typedef V76LogicalChannelParameters_mode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mode
    mode::const_reference get_mode () const;
    mode::reference ref_mode ();
    mode::reference set_mode ();
    mode::reference set_mode (mode::const_reference value);
    class v75Parameters {
      public:
        typedef V75Parameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v75Parameters
    v75Parameters::const_reference get_v75Parameters () const;
    v75Parameters::reference ref_v75Parameters ();
    v75Parameters::reference set_v75Parameters ();
    v75Parameters::reference set_v75Parameters (v75Parameters::const_reference value);
    void swap(V76LogicalChannelParameters& other);
    V76LogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// RTPPayloadType
//

class RTPPayloadType : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RTPPayloadType(const void* info) : Inherited(info) {}
  public:
    RTPPayloadType() : Inherited(&theInfo) {}
    RTPPayloadType(const RTPPayloadType & other) : Inherited(other)
    {}
    RTPPayloadType& operator = (const RTPPayloadType& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_payloadType
    };

    class payloadDescriptor {
      public:
        typedef RTPPayloadType_payloadDescriptor value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class payloadDescriptor
    payloadDescriptor::const_reference get_payloadDescriptor () const;
    payloadDescriptor::reference ref_payloadDescriptor ();
    payloadDescriptor::reference set_payloadDescriptor ();
    payloadDescriptor::reference set_payloadDescriptor (payloadDescriptor::const_reference value);
    class payloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class payloadType
    payloadType::const_reference get_payloadType () const;
    payloadType::reference ref_payloadType ();
    payloadType::reference set_payloadType ();
    payloadType::reference set_payloadType (payloadType::value_type::int_type value);
    void omit_payloadType ();
    bool payloadType_isPresent () const;
    void swap(RTPPayloadType& other);
    RTPPayloadType * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RedundancyEncoding
//

class DataType;

class RedundancyEncoding : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncoding(const void* info) : Inherited(info) {}
  public:
    RedundancyEncoding() : Inherited(&theInfo) {}
    RedundancyEncoding(const RedundancyEncoding & other) : Inherited(other)
    {}
    RedundancyEncoding& operator = (const RedundancyEncoding& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_secondaryEncoding
    };

    class redundancyEncodingMethod {
      public:
        typedef RedundancyEncodingMethod value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingMethod
    redundancyEncodingMethod::const_reference get_redundancyEncodingMethod () const;
    redundancyEncodingMethod::reference ref_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod (redundancyEncodingMethod::const_reference value);
    class secondaryEncoding {
      public:
        typedef DataType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class secondaryEncoding
    secondaryEncoding::const_reference get_secondaryEncoding () const;
    secondaryEncoding::reference ref_secondaryEncoding ();
    secondaryEncoding::reference set_secondaryEncoding ();
    secondaryEncoding::reference set_secondaryEncoding (secondaryEncoding::const_reference value);
    void omit_secondaryEncoding ();
    bool secondaryEncoding_isPresent () const;
    void swap(RedundancyEncoding& other);
    RedundancyEncoding * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// FECData
//

class FECData : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FECData(const void* info) : Inherited(info) {}
  public:
    FECData() : Inherited(&theInfo) {}
    class rfc2733 {
      public:
        enum Id { id_ = 0 };
        typedef FECData_rfc2733 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733

    rfc2733::const_reference get_rfc2733 () const;
    rfc2733::reference ref_rfc2733 (); 
    rfc2733::reference select_rfc2733 (); 
    rfc2733::reference select_rfc2733 (rfc2733::const_reference value); 
    bool rfc2733_isSelected() const;

    FECData(rfc2733::Id id, rfc2733::const_reference value);
    void swap(FECData & other);
    FECData(const FECData & other)
    : Inherited(other) {} 

    FECData & operator = (const FECData & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FECData * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// TransportAddress
//

class TransportAddress : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TransportAddress(const void* info) : Inherited(info) {}
  public:
    TransportAddress() : Inherited(&theInfo) {}
    class unicastAddress {
      public:
        enum Id { id_ = 0 };
        typedef UnicastAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unicastAddress

    unicastAddress::const_reference get_unicastAddress () const;
    unicastAddress::reference ref_unicastAddress (); 
    unicastAddress::reference select_unicastAddress (); 
    unicastAddress::reference select_unicastAddress (unicastAddress::const_reference value); 
    bool unicastAddress_isSelected() const;

    class multicastAddress {
      public:
        enum Id { id_ = 1 };
        typedef MulticastAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multicastAddress

    multicastAddress::const_reference get_multicastAddress () const;
    multicastAddress::reference ref_multicastAddress (); 
    multicastAddress::reference select_multicastAddress (); 
    multicastAddress::reference select_multicastAddress (multicastAddress::const_reference value); 
    bool multicastAddress_isSelected() const;

    TransportAddress(unicastAddress::Id id, unicastAddress::const_reference value);
    TransportAddress(multicastAddress::Id id, multicastAddress::const_reference value);
    void swap(TransportAddress & other);
    TransportAddress(const TransportAddress & other)
    : Inherited(other) {} 

    TransportAddress & operator = (const TransportAddress & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    TransportAddress * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// EncryptionSync
//

class EncryptionSync : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionSync(const void* info) : Inherited(info) {}
  public:
    EncryptionSync() : Inherited(&theInfo) {}
    EncryptionSync(const EncryptionSync & other) : Inherited(other)
    {}
    EncryptionSync& operator = (const EncryptionSync& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard,
      e_escrowentry,
      e_genericParameter
    };

    class nonStandard {
      public:
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    class synchFlag {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class synchFlag
    synchFlag::const_reference get_synchFlag () const;
    synchFlag::reference ref_synchFlag ();
    synchFlag::reference set_synchFlag ();
    synchFlag::reference set_synchFlag (synchFlag::value_type::int_type value);
    class h235Key {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 65535> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h235Key
    h235Key::const_reference get_h235Key () const;
    h235Key::reference ref_h235Key ();
    h235Key::reference set_h235Key ();
    h235Key::reference set_h235Key (const std::vector<char>& value);
    class escrowentry {
      public:
        typedef ASN1::SEQUENCE_OF<EscrowData,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class escrowentry
    escrowentry::const_reference get_escrowentry () const;
    escrowentry::reference ref_escrowentry ();
    escrowentry::reference set_escrowentry ();
    escrowentry::reference set_escrowentry (escrowentry::const_reference value);
    void omit_escrowentry ();
    bool escrowentry_isPresent () const;
    class genericParameter {
      public:
        typedef GenericParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericParameter
    genericParameter::const_reference get_genericParameter () const;
    genericParameter::reference ref_genericParameter ();
    genericParameter::reference set_genericParameter ();
    genericParameter::reference set_genericParameter (genericParameter::const_reference value);
    void omit_genericParameter ();
    bool genericParameter_isPresent () const;
    void swap(EncryptionSync& other);
    EncryptionSync * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// H2250LogicalChannelAckParameters
//

class H2250LogicalChannelAckParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250LogicalChannelAckParameters(const void* info) : Inherited(info) {}
  public:
    H2250LogicalChannelAckParameters() : Inherited(&theInfo) {}
    H2250LogicalChannelAckParameters(const H2250LogicalChannelAckParameters & other) : Inherited(other)
    {}
    H2250LogicalChannelAckParameters& operator = (const H2250LogicalChannelAckParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard,
      e_sessionID,
      e_mediaChannel,
      e_mediaControlChannel,
      e_dynamicRTPPayloadType,
      e_flowControlToZero,
      e_portNumber
    };

    class nonStandard {
      public:
        typedef ASN1::SEQUENCE_OF<NonStandardParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    class sessionID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sessionID
    sessionID::const_reference get_sessionID () const;
    sessionID::reference ref_sessionID ();
    sessionID::reference set_sessionID ();
    sessionID::reference set_sessionID (sessionID::value_type::int_type value);
    void omit_sessionID ();
    bool sessionID_isPresent () const;
    class mediaChannel {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaChannel
    mediaChannel::const_reference get_mediaChannel () const;
    mediaChannel::reference ref_mediaChannel ();
    mediaChannel::reference set_mediaChannel ();
    mediaChannel::reference set_mediaChannel (mediaChannel::const_reference value);
    void omit_mediaChannel ();
    bool mediaChannel_isPresent () const;
    class mediaControlChannel {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaControlChannel
    mediaControlChannel::const_reference get_mediaControlChannel () const;
    mediaControlChannel::reference ref_mediaControlChannel ();
    mediaControlChannel::reference set_mediaControlChannel ();
    mediaControlChannel::reference set_mediaControlChannel (mediaControlChannel::const_reference value);
    void omit_mediaControlChannel ();
    bool mediaControlChannel_isPresent () const;
    class dynamicRTPPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 96, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicRTPPayloadType
    dynamicRTPPayloadType::const_reference get_dynamicRTPPayloadType () const;
    dynamicRTPPayloadType::reference ref_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType (dynamicRTPPayloadType::value_type::int_type value);
    void omit_dynamicRTPPayloadType ();
    bool dynamicRTPPayloadType_isPresent () const;
    class flowControlToZero {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class flowControlToZero
    flowControlToZero::const_reference get_flowControlToZero () const;
    flowControlToZero::reference ref_flowControlToZero ();
    flowControlToZero::reference set_flowControlToZero ();
    flowControlToZero::reference set_flowControlToZero (bool value);
    void omit_flowControlToZero ();
    bool flowControlToZero_isPresent () const;
    class portNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class portNumber
    portNumber::const_reference get_portNumber () const;
    portNumber::reference ref_portNumber ();
    portNumber::reference set_portNumber ();
    portNumber::reference set_portNumber (portNumber::value_type::int_type value);
    void omit_portNumber ();
    bool portNumber_isPresent () const;
    void swap(H2250LogicalChannelAckParameters& other);
    H2250LogicalChannelAckParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[7];
};

//
// MultiplexEntrySend
//

class MultiplexEntrySend : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexEntrySend(const void* info) : Inherited(info) {}
  public:
    MultiplexEntrySend() : Inherited(&theInfo) {}
    MultiplexEntrySend(const MultiplexEntrySend & other) : Inherited(other)
    {}
    MultiplexEntrySend& operator = (const MultiplexEntrySend& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class multiplexEntryDescriptors {
      public:
        typedef ASN1::SET_OF<MultiplexEntryDescriptor,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 15> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexEntryDescriptors
    multiplexEntryDescriptors::const_reference get_multiplexEntryDescriptors () const;
    multiplexEntryDescriptors::reference ref_multiplexEntryDescriptors ();
    multiplexEntryDescriptors::reference set_multiplexEntryDescriptors ();
    multiplexEntryDescriptors::reference set_multiplexEntryDescriptors (multiplexEntryDescriptors::const_reference value);
    void swap(MultiplexEntrySend& other);
    MultiplexEntrySend * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H223ModeParameters
//

class H223ModeParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H223ModeParameters(const void* info) : Inherited(info) {}
  public:
    H223ModeParameters() : Inherited(&theInfo) {}
    H223ModeParameters(const H223ModeParameters & other) : Inherited(other)
    {}
    H223ModeParameters& operator = (const H223ModeParameters& other)
    { Inherited::operator = (other); return *this; } 
    class adaptationLayerType {
      public:
        typedef H223ModeParameters_adaptationLayerType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class adaptationLayerType
    adaptationLayerType::const_reference get_adaptationLayerType () const;
    adaptationLayerType::reference ref_adaptationLayerType ();
    adaptationLayerType::reference set_adaptationLayerType ();
    adaptationLayerType::reference set_adaptationLayerType (adaptationLayerType::const_reference value);
    class segmentableFlag {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class segmentableFlag
    segmentableFlag::const_reference get_segmentableFlag () const;
    segmentableFlag::reference ref_segmentableFlag ();
    segmentableFlag::reference set_segmentableFlag ();
    segmentableFlag::reference set_segmentableFlag (bool value);
    void swap(H223ModeParameters& other);
    H223ModeParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// ConferenceResponse
//

class ConferenceResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ConferenceResponse(const void* info) : Inherited(info) {}
  public:
    ConferenceResponse() : Inherited(&theInfo) {}
    class mCTerminalIDResponse {
      public:
        enum Id { id_ = 0 };
        typedef ConferenceResponse_mCTerminalIDResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mCTerminalIDResponse

    mCTerminalIDResponse::const_reference get_mCTerminalIDResponse () const;
    mCTerminalIDResponse::reference ref_mCTerminalIDResponse (); 
    mCTerminalIDResponse::reference select_mCTerminalIDResponse (); 
    mCTerminalIDResponse::reference select_mCTerminalIDResponse (mCTerminalIDResponse::const_reference value); 
    bool mCTerminalIDResponse_isSelected() const;

    class terminalIDResponse {
      public:
        enum Id { id_ = 1 };
        typedef ConferenceResponse_terminalIDResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalIDResponse

    terminalIDResponse::const_reference get_terminalIDResponse () const;
    terminalIDResponse::reference ref_terminalIDResponse (); 
    terminalIDResponse::reference select_terminalIDResponse (); 
    terminalIDResponse::reference select_terminalIDResponse (terminalIDResponse::const_reference value); 
    bool terminalIDResponse_isSelected() const;

    class conferenceIDResponse {
      public:
        enum Id { id_ = 2 };
        typedef ConferenceResponse_conferenceIDResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceIDResponse

    conferenceIDResponse::const_reference get_conferenceIDResponse () const;
    conferenceIDResponse::reference ref_conferenceIDResponse (); 
    conferenceIDResponse::reference select_conferenceIDResponse (); 
    conferenceIDResponse::reference select_conferenceIDResponse (conferenceIDResponse::const_reference value); 
    bool conferenceIDResponse_isSelected() const;

    class passwordResponse {
      public:
        enum Id { id_ = 3 };
        typedef ConferenceResponse_passwordResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class passwordResponse

    passwordResponse::const_reference get_passwordResponse () const;
    passwordResponse::reference ref_passwordResponse (); 
    passwordResponse::reference select_passwordResponse (); 
    passwordResponse::reference select_passwordResponse (passwordResponse::const_reference value); 
    bool passwordResponse_isSelected() const;

    class terminalListResponse {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::SET_OF<TerminalLabel,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalListResponse

    terminalListResponse::const_reference get_terminalListResponse () const;
    terminalListResponse::reference ref_terminalListResponse (); 
    terminalListResponse::reference select_terminalListResponse (); 
    terminalListResponse::reference select_terminalListResponse (terminalListResponse::const_reference value); 
    bool terminalListResponse_isSelected() const;

    class videoCommandReject {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoCommandReject

    videoCommandReject::reference select_videoCommandReject (); 
    bool videoCommandReject_isSelected() const;

    class terminalDropReject {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalDropReject

    terminalDropReject::reference select_terminalDropReject (); 
    bool terminalDropReject_isSelected() const;

    class makeMeChairResponse {
      public:
        enum Id { id_ = 7 };
        typedef ConferenceResponse_makeMeChairResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class makeMeChairResponse

    makeMeChairResponse::const_reference get_makeMeChairResponse () const;
    makeMeChairResponse::reference ref_makeMeChairResponse (); 
    makeMeChairResponse::reference select_makeMeChairResponse (); 
    makeMeChairResponse::reference select_makeMeChairResponse (makeMeChairResponse::const_reference value); 
    bool makeMeChairResponse_isSelected() const;

    class extensionAddressResponse {
      public:
        enum Id { id_ = 8 };
        typedef ConferenceResponse_extensionAddressResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class extensionAddressResponse

    extensionAddressResponse::const_reference get_extensionAddressResponse () const;
    extensionAddressResponse::reference ref_extensionAddressResponse (); 
    extensionAddressResponse::reference select_extensionAddressResponse (); 
    extensionAddressResponse::reference select_extensionAddressResponse (extensionAddressResponse::const_reference value); 
    bool extensionAddressResponse_isSelected() const;

    class chairTokenOwnerResponse {
      public:
        enum Id { id_ = 9 };
        typedef ConferenceResponse_chairTokenOwnerResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class chairTokenOwnerResponse

    chairTokenOwnerResponse::const_reference get_chairTokenOwnerResponse () const;
    chairTokenOwnerResponse::reference ref_chairTokenOwnerResponse (); 
    chairTokenOwnerResponse::reference select_chairTokenOwnerResponse (); 
    chairTokenOwnerResponse::reference select_chairTokenOwnerResponse (chairTokenOwnerResponse::const_reference value); 
    bool chairTokenOwnerResponse_isSelected() const;

    class terminalCertificateResponse {
      public:
        enum Id { id_ = 10 };
        typedef ConferenceResponse_terminalCertificateResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalCertificateResponse

    terminalCertificateResponse::const_reference get_terminalCertificateResponse () const;
    terminalCertificateResponse::reference ref_terminalCertificateResponse (); 
    terminalCertificateResponse::reference select_terminalCertificateResponse (); 
    terminalCertificateResponse::reference select_terminalCertificateResponse (terminalCertificateResponse::const_reference value); 
    bool terminalCertificateResponse_isSelected() const;

    class broadcastMyLogicalChannelResponse {
      public:
        enum Id { id_ = 11 };
        typedef ConferenceResponse_broadcastMyLogicalChannelResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class broadcastMyLogicalChannelResponse

    broadcastMyLogicalChannelResponse::const_reference get_broadcastMyLogicalChannelResponse () const;
    broadcastMyLogicalChannelResponse::reference ref_broadcastMyLogicalChannelResponse (); 
    broadcastMyLogicalChannelResponse::reference select_broadcastMyLogicalChannelResponse (); 
    broadcastMyLogicalChannelResponse::reference select_broadcastMyLogicalChannelResponse (broadcastMyLogicalChannelResponse::const_reference value); 
    bool broadcastMyLogicalChannelResponse_isSelected() const;

    class makeTerminalBroadcasterResponse {
      public:
        enum Id { id_ = 12 };
        typedef ConferenceResponse_makeTerminalBroadcasterResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class makeTerminalBroadcasterResponse

    makeTerminalBroadcasterResponse::const_reference get_makeTerminalBroadcasterResponse () const;
    makeTerminalBroadcasterResponse::reference ref_makeTerminalBroadcasterResponse (); 
    makeTerminalBroadcasterResponse::reference select_makeTerminalBroadcasterResponse (); 
    makeTerminalBroadcasterResponse::reference select_makeTerminalBroadcasterResponse (makeTerminalBroadcasterResponse::const_reference value); 
    bool makeTerminalBroadcasterResponse_isSelected() const;

    class sendThisSourceResponse {
      public:
        enum Id { id_ = 13 };
        typedef ConferenceResponse_sendThisSourceResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendThisSourceResponse

    sendThisSourceResponse::const_reference get_sendThisSourceResponse () const;
    sendThisSourceResponse::reference ref_sendThisSourceResponse (); 
    sendThisSourceResponse::reference select_sendThisSourceResponse (); 
    sendThisSourceResponse::reference select_sendThisSourceResponse (sendThisSourceResponse::const_reference value); 
    bool sendThisSourceResponse_isSelected() const;

    class requestAllTerminalIDsResponse {
      public:
        enum Id { id_ = 14 };
        typedef RequestAllTerminalIDsResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestAllTerminalIDsResponse

    requestAllTerminalIDsResponse::const_reference get_requestAllTerminalIDsResponse () const;
    requestAllTerminalIDsResponse::reference ref_requestAllTerminalIDsResponse (); 
    requestAllTerminalIDsResponse::reference select_requestAllTerminalIDsResponse (); 
    requestAllTerminalIDsResponse::reference select_requestAllTerminalIDsResponse (requestAllTerminalIDsResponse::const_reference value); 
    bool requestAllTerminalIDsResponse_isSelected() const;

    class remoteMCResponse {
      public:
        enum Id { id_ = 15 };
        typedef RemoteMCResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class remoteMCResponse

    remoteMCResponse::const_reference get_remoteMCResponse () const;
    remoteMCResponse::reference ref_remoteMCResponse (); 
    remoteMCResponse::reference select_remoteMCResponse (); 
    remoteMCResponse::reference select_remoteMCResponse (remoteMCResponse::const_reference value); 
    bool remoteMCResponse_isSelected() const;

    ConferenceResponse(mCTerminalIDResponse::Id id, mCTerminalIDResponse::const_reference value);
    ConferenceResponse(terminalIDResponse::Id id, terminalIDResponse::const_reference value);
    ConferenceResponse(conferenceIDResponse::Id id, conferenceIDResponse::const_reference value);
    ConferenceResponse(passwordResponse::Id id, passwordResponse::const_reference value);
    ConferenceResponse(terminalListResponse::Id id, terminalListResponse::const_reference value);
    ConferenceResponse(videoCommandReject::Id id, videoCommandReject::const_reference value);
    ConferenceResponse(terminalDropReject::Id id, terminalDropReject::const_reference value);
    ConferenceResponse(makeMeChairResponse::Id id, makeMeChairResponse::const_reference value);
    ConferenceResponse(extensionAddressResponse::Id id, extensionAddressResponse::const_reference value);
    ConferenceResponse(chairTokenOwnerResponse::Id id, chairTokenOwnerResponse::const_reference value);
    ConferenceResponse(terminalCertificateResponse::Id id, terminalCertificateResponse::const_reference value);
    ConferenceResponse(broadcastMyLogicalChannelResponse::Id id, broadcastMyLogicalChannelResponse::const_reference value);
    ConferenceResponse(makeTerminalBroadcasterResponse::Id id, makeTerminalBroadcasterResponse::const_reference value);
    ConferenceResponse(sendThisSourceResponse::Id id, sendThisSourceResponse::const_reference value);
    ConferenceResponse(requestAllTerminalIDsResponse::Id id, requestAllTerminalIDsResponse::const_reference value);
    ConferenceResponse(remoteMCResponse::Id id, remoteMCResponse::const_reference value);
    void swap(ConferenceResponse & other);
    ConferenceResponse(const ConferenceResponse & other)
    : Inherited(other) {} 

    ConferenceResponse & operator = (const ConferenceResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ConferenceResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[16];
    static const char* selectionNames[16];
};

//
// MultilinkIndication
//

class MultilinkIndication : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkIndication(const void* info) : Inherited(info) {}
  public:
    MultilinkIndication() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class crcDesired {
      public:
        enum Id { id_ = 1 };
        typedef MultilinkIndication_crcDesired value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class crcDesired

    crcDesired::const_reference get_crcDesired () const;
    crcDesired::reference ref_crcDesired (); 
    crcDesired::reference select_crcDesired (); 
    crcDesired::reference select_crcDesired (crcDesired::const_reference value); 
    bool crcDesired_isSelected() const;

    class excessiveError {
      public:
        enum Id { id_ = 2 };
        typedef MultilinkIndication_excessiveError value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class excessiveError

    excessiveError::const_reference get_excessiveError () const;
    excessiveError::reference ref_excessiveError (); 
    excessiveError::reference select_excessiveError (); 
    excessiveError::reference select_excessiveError (excessiveError::const_reference value); 
    bool excessiveError_isSelected() const;

    MultilinkIndication(nonStandard::Id id, nonStandard::const_reference value);
    MultilinkIndication(crcDesired::Id id, crcDesired::const_reference value);
    MultilinkIndication(excessiveError::Id id, excessiveError::const_reference value);
    void swap(MultilinkIndication & other);
    MultilinkIndication(const MultilinkIndication & other)
    : Inherited(other) {} 

    MultilinkIndication & operator = (const MultilinkIndication & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultilinkIndication * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// DialingInformationNetworkType
//

class DialingInformationNetworkType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DialingInformationNetworkType(const void* info) : Inherited(info) {}
  public:
    DialingInformationNetworkType() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class n_isdn {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class n_isdn

    n_isdn::reference select_n_isdn (); 
    bool n_isdn_isSelected() const;

    class gstn {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gstn

    gstn::reference select_gstn (); 
    bool gstn_isSelected() const;

    class mobile {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mobile

    mobile::reference select_mobile (); 
    bool mobile_isSelected() const;

    DialingInformationNetworkType(nonStandard::Id id, nonStandard::const_reference value);
    DialingInformationNetworkType(n_isdn::Id id, n_isdn::const_reference value);
    DialingInformationNetworkType(gstn::Id id, gstn::const_reference value);
    DialingInformationNetworkType(mobile::Id id, mobile::const_reference value);
    void swap(DialingInformationNetworkType & other);
    DialingInformationNetworkType(const DialingInformationNetworkType & other)
    : Inherited(other) {} 

    DialingInformationNetworkType & operator = (const DialingInformationNetworkType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DialingInformationNetworkType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// EncryptionCommand
//

class EncryptionCommand : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionCommand(const void* info) : Inherited(info) {}
  public:
    EncryptionCommand() : Inherited(&theInfo) {}
    class encryptionSE {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionSE

    encryptionSE::const_reference get_encryptionSE () const;
    encryptionSE::reference ref_encryptionSE (); 
    encryptionSE::reference select_encryptionSE (); 
    encryptionSE::reference select_encryptionSE (const std::vector<char>& value); 
    bool encryptionSE_isSelected() const;

    class encryptionIVRequest {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionIVRequest

    encryptionIVRequest::reference select_encryptionIVRequest (); 
    bool encryptionIVRequest_isSelected() const;

    class encryptionAlgorithmID {
      public:
        enum Id { id_ = 2 };
        typedef EncryptionCommand_encryptionAlgorithmID value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionAlgorithmID

    encryptionAlgorithmID::const_reference get_encryptionAlgorithmID () const;
    encryptionAlgorithmID::reference ref_encryptionAlgorithmID (); 
    encryptionAlgorithmID::reference select_encryptionAlgorithmID (); 
    encryptionAlgorithmID::reference select_encryptionAlgorithmID (encryptionAlgorithmID::const_reference value); 
    bool encryptionAlgorithmID_isSelected() const;

    EncryptionCommand(encryptionSE::Id id, const std::vector<char>& value);
    EncryptionCommand(encryptionIVRequest::Id id, encryptionIVRequest::const_reference value);
    EncryptionCommand(encryptionAlgorithmID::Id id, encryptionAlgorithmID::const_reference value);
    void swap(EncryptionCommand & other);
    EncryptionCommand(const EncryptionCommand & other)
    : Inherited(other) {} 

    EncryptionCommand & operator = (const EncryptionCommand & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    EncryptionCommand * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// NewATMVCCommand
//

class NewATMVCCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCCommand(const void* info) : Inherited(info) {}
  public:
    NewATMVCCommand() : Inherited(&theInfo) {}
    NewATMVCCommand(const NewATMVCCommand & other) : Inherited(other)
    {}
    NewATMVCCommand& operator = (const NewATMVCCommand& other)
    { Inherited::operator = (other); return *this; } 
    class resourceID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resourceID
    resourceID::const_reference get_resourceID () const;
    resourceID::reference ref_resourceID ();
    resourceID::reference set_resourceID ();
    resourceID::reference set_resourceID (resourceID::value_type::int_type value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    class bitRateLockedToPCRClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToPCRClock
    bitRateLockedToPCRClock::const_reference get_bitRateLockedToPCRClock () const;
    bitRateLockedToPCRClock::reference ref_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock (bool value);
    class bitRateLockedToNetworkClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToNetworkClock
    bitRateLockedToNetworkClock::const_reference get_bitRateLockedToNetworkClock () const;
    bitRateLockedToNetworkClock::reference ref_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock (bool value);
    class aal {
      public:
        typedef NewATMVCCommand_aal value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal
    aal::const_reference get_aal () const;
    aal::reference ref_aal ();
    aal::reference set_aal ();
    aal::reference set_aal (aal::const_reference value);
    class multiplex {
      public:
        typedef NewATMVCCommand_multiplex value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplex
    multiplex::const_reference get_multiplex () const;
    multiplex::reference ref_multiplex ();
    multiplex::reference set_multiplex ();
    multiplex::reference set_multiplex (multiplex::const_reference value);
    class reverseParameters {
      public:
        typedef NewATMVCCommand_reverseParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reverseParameters
    reverseParameters::const_reference get_reverseParameters () const;
    reverseParameters::reference ref_reverseParameters ();
    reverseParameters::reference set_reverseParameters ();
    reverseParameters::reference set_reverseParameters (reverseParameters::const_reference value);
    void swap(NewATMVCCommand& other);
    NewATMVCCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* fieldNames[7];
};

//
// MiscellaneousIndication
//

class MiscellaneousIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousIndication(const void* info) : Inherited(info) {}
  public:
    MiscellaneousIndication() : Inherited(&theInfo) {}
    MiscellaneousIndication(const MiscellaneousIndication & other) : Inherited(other)
    {}
    MiscellaneousIndication& operator = (const MiscellaneousIndication& other)
    { Inherited::operator = (other); return *this; } 
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    class type {
      public:
        typedef MiscellaneousIndication_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(MiscellaneousIndication& other);
    MiscellaneousIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MCLocationIndication
//

class MCLocationIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MCLocationIndication(const void* info) : Inherited(info) {}
  public:
    MCLocationIndication() : Inherited(&theInfo) {}
    MCLocationIndication(const MCLocationIndication & other) : Inherited(other)
    {}
    MCLocationIndication& operator = (const MCLocationIndication& other)
    { Inherited::operator = (other); return *this; } 
    class signalAddress {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class signalAddress
    signalAddress::const_reference get_signalAddress () const;
    signalAddress::reference ref_signalAddress ();
    signalAddress::reference set_signalAddress ();
    signalAddress::reference set_signalAddress (signalAddress::const_reference value);
    void swap(MCLocationIndication& other);
    MCLocationIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// NewATMVCIndication
//

class NewATMVCIndication : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NewATMVCIndication(const void* info) : Inherited(info) {}
  public:
    NewATMVCIndication() : Inherited(&theInfo) {}
    NewATMVCIndication(const NewATMVCIndication & other) : Inherited(other)
    {}
    NewATMVCIndication& operator = (const NewATMVCIndication& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_reverseParameters
    };

    class resourceID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resourceID
    resourceID::const_reference get_resourceID () const;
    resourceID::reference ref_resourceID ();
    resourceID::reference set_resourceID ();
    resourceID::reference set_resourceID (resourceID::value_type::int_type value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    class bitRateLockedToPCRClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToPCRClock
    bitRateLockedToPCRClock::const_reference get_bitRateLockedToPCRClock () const;
    bitRateLockedToPCRClock::reference ref_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock ();
    bitRateLockedToPCRClock::reference set_bitRateLockedToPCRClock (bool value);
    class bitRateLockedToNetworkClock {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRateLockedToNetworkClock
    bitRateLockedToNetworkClock::const_reference get_bitRateLockedToNetworkClock () const;
    bitRateLockedToNetworkClock::reference ref_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock ();
    bitRateLockedToNetworkClock::reference set_bitRateLockedToNetworkClock (bool value);
    class aal {
      public:
        typedef NewATMVCIndication_aal value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class aal
    aal::const_reference get_aal () const;
    aal::reference ref_aal ();
    aal::reference set_aal ();
    aal::reference set_aal (aal::const_reference value);
    class multiplex {
      public:
        typedef NewATMVCIndication_multiplex value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplex
    multiplex::const_reference get_multiplex () const;
    multiplex::reference ref_multiplex ();
    multiplex::reference set_multiplex ();
    multiplex::reference set_multiplex (multiplex::const_reference value);
    class reverseParameters {
      public:
        typedef NewATMVCIndication_reverseParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reverseParameters
    reverseParameters::const_reference get_reverseParameters () const;
    reverseParameters::reference ref_reverseParameters ();
    reverseParameters::reference set_reverseParameters ();
    reverseParameters::reference set_reverseParameters (reverseParameters::const_reference value);
    void omit_reverseParameters ();
    bool reverseParameters_isPresent () const;
    void swap(NewATMVCIndication& other);
    NewATMVCIndication * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[7];
};

//
// NetworkAccessParameters_networkAddress
//

class NetworkAccessParameters_networkAddress : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NetworkAccessParameters_networkAddress(const void* info) : Inherited(info) {}
  public:
    NetworkAccessParameters_networkAddress() : Inherited(&theInfo) {}
    class q2931Address {
      public:
        enum Id { id_ = 0 };
        typedef Q2931Address value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class q2931Address

    q2931Address::const_reference get_q2931Address () const;
    q2931Address::reference ref_q2931Address (); 
    q2931Address::reference select_q2931Address (); 
    q2931Address::reference select_q2931Address (q2931Address::const_reference value); 
    bool q2931Address_isSelected() const;

    class e164Address {
      public:
        enum Id { id_ = 1 };
        class value_type : public ASN1::IA5String
        {
            typedef ASN1::IA5String Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class e164Address

    e164Address::const_reference get_e164Address () const;
    e164Address::reference ref_e164Address (); 
    e164Address::reference select_e164Address (); 
    e164Address::reference select_e164Address (const std::string& value); 
    bool e164Address_isSelected() const;

    class localAreaAddress {
      public:
        enum Id { id_ = 2 };
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class localAreaAddress

    localAreaAddress::const_reference get_localAreaAddress () const;
    localAreaAddress::reference ref_localAreaAddress (); 
    localAreaAddress::reference select_localAreaAddress (); 
    localAreaAddress::reference select_localAreaAddress (localAreaAddress::const_reference value); 
    bool localAreaAddress_isSelected() const;

    NetworkAccessParameters_networkAddress(q2931Address::Id id, q2931Address::const_reference value);
    NetworkAccessParameters_networkAddress(e164Address::Id id, const std::string& value);
    NetworkAccessParameters_networkAddress(localAreaAddress::Id id, localAreaAddress::const_reference value);
    void swap(NetworkAccessParameters_networkAddress & other);
    NetworkAccessParameters_networkAddress(const NetworkAccessParameters_networkAddress & other)
    : Inherited(other) {} 

    NetworkAccessParameters_networkAddress & operator = (const NetworkAccessParameters_networkAddress & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    NetworkAccessParameters_networkAddress * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// H2250LogicalChannelParameters_mediaPacketization
//

class H2250LogicalChannelParameters_mediaPacketization : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250LogicalChannelParameters_mediaPacketization(const void* info) : Inherited(info) {}
  public:
    H2250LogicalChannelParameters_mediaPacketization() : Inherited(&theInfo) {}
    class h261aVideoPacketization {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h261aVideoPacketization

    h261aVideoPacketization::reference select_h261aVideoPacketization (); 
    bool h261aVideoPacketization_isSelected() const;

    class rtpPayloadType {
      public:
        enum Id { id_ = 1 };
        typedef RTPPayloadType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtpPayloadType

    rtpPayloadType::const_reference get_rtpPayloadType () const;
    rtpPayloadType::reference ref_rtpPayloadType (); 
    rtpPayloadType::reference select_rtpPayloadType (); 
    rtpPayloadType::reference select_rtpPayloadType (rtpPayloadType::const_reference value); 
    bool rtpPayloadType_isSelected() const;

    H2250LogicalChannelParameters_mediaPacketization(h261aVideoPacketization::Id id, h261aVideoPacketization::const_reference value);
    H2250LogicalChannelParameters_mediaPacketization(rtpPayloadType::Id id, rtpPayloadType::const_reference value);
    void swap(H2250LogicalChannelParameters_mediaPacketization & other);
    H2250LogicalChannelParameters_mediaPacketization(const H2250LogicalChannelParameters_mediaPacketization & other)
    : Inherited(other) {} 

    H2250LogicalChannelParameters_mediaPacketization & operator = (const H2250LogicalChannelParameters_mediaPacketization & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H2250LogicalChannelParameters_mediaPacketization * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// DepFECData_rfc2733
//

class DepFECData_rfc2733 : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECData_rfc2733(const void* info) : Inherited(info) {}
  public:
    DepFECData_rfc2733() : Inherited(&theInfo) {}
    DepFECData_rfc2733(const DepFECData_rfc2733 & other) : Inherited(other)
    {}
    DepFECData_rfc2733& operator = (const DepFECData_rfc2733& other)
    { Inherited::operator = (other); return *this; } 
    class mode {
      public:
        typedef DepFECData_rfc2733_mode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mode
    mode::const_reference get_mode () const;
    mode::reference ref_mode ();
    mode::reference set_mode ();
    mode::reference set_mode (mode::const_reference value);
    void swap(DepFECData_rfc2733& other);
    DepFECData_rfc2733 * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// OpenLogicalChannelAck_forwardMultiplexAckParameters
//

class OpenLogicalChannelAck_forwardMultiplexAckParameters : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelAck_forwardMultiplexAckParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelAck_forwardMultiplexAckParameters() : Inherited(&theInfo) {}
    class h2250LogicalChannelAckParameters {
      public:
        enum Id { id_ = 0 };
        typedef H2250LogicalChannelAckParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250LogicalChannelAckParameters

    h2250LogicalChannelAckParameters::const_reference get_h2250LogicalChannelAckParameters () const;
    h2250LogicalChannelAckParameters::reference ref_h2250LogicalChannelAckParameters (); 
    h2250LogicalChannelAckParameters::reference select_h2250LogicalChannelAckParameters (); 
    h2250LogicalChannelAckParameters::reference select_h2250LogicalChannelAckParameters (h2250LogicalChannelAckParameters::const_reference value); 
    bool h2250LogicalChannelAckParameters_isSelected() const;

    OpenLogicalChannelAck_forwardMultiplexAckParameters(h2250LogicalChannelAckParameters::Id id, h2250LogicalChannelAckParameters::const_reference value);
    void swap(OpenLogicalChannelAck_forwardMultiplexAckParameters & other);
    OpenLogicalChannelAck_forwardMultiplexAckParameters(const OpenLogicalChannelAck_forwardMultiplexAckParameters & other)
    : Inherited(other) {} 

    OpenLogicalChannelAck_forwardMultiplexAckParameters & operator = (const OpenLogicalChannelAck_forwardMultiplexAckParameters & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    OpenLogicalChannelAck_forwardMultiplexAckParameters * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// MiscellaneousCommand_type_encryptionUpdateCommand
//

class MiscellaneousCommand_type_encryptionUpdateCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type_encryptionUpdateCommand(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type_encryptionUpdateCommand() : Inherited(&theInfo) {}
    MiscellaneousCommand_type_encryptionUpdateCommand(const MiscellaneousCommand_type_encryptionUpdateCommand & other) : Inherited(other)
    {}
    MiscellaneousCommand_type_encryptionUpdateCommand& operator = (const MiscellaneousCommand_type_encryptionUpdateCommand& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_multiplePayloadStream
    };

    class encryptionSync {
      public:
        typedef EncryptionSync value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionSync
    encryptionSync::const_reference get_encryptionSync () const;
    encryptionSync::reference ref_encryptionSync ();
    encryptionSync::reference set_encryptionSync ();
    encryptionSync::reference set_encryptionSync (encryptionSync::const_reference value);
    class multiplePayloadStream {
      public:
        typedef MultiplePayloadStream value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplePayloadStream
    multiplePayloadStream::const_reference get_multiplePayloadStream () const;
    multiplePayloadStream::reference ref_multiplePayloadStream ();
    multiplePayloadStream::reference set_multiplePayloadStream ();
    multiplePayloadStream::reference set_multiplePayloadStream (multiplePayloadStream::const_reference value);
    void omit_multiplePayloadStream ();
    bool multiplePayloadStream_isPresent () const;
    void swap(MiscellaneousCommand_type_encryptionUpdateCommand& other);
    MiscellaneousCommand_type_encryptionUpdateCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// GenericMessage
//

class GenericMessage : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    GenericMessage(const void* info) : Inherited(info) {}
  public:
    GenericMessage() : Inherited(&theInfo) {}
    GenericMessage(const GenericMessage & other) : Inherited(other)
    {}
    GenericMessage& operator = (const GenericMessage& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_subMessageIdentifier,
      e_messageContent
    };

    class messageIdentifier {
      public:
        typedef CapabilityIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class messageIdentifier
    messageIdentifier::const_reference get_messageIdentifier () const;
    messageIdentifier::reference ref_messageIdentifier ();
    messageIdentifier::reference set_messageIdentifier ();
    messageIdentifier::reference set_messageIdentifier (messageIdentifier::const_reference value);
    class subMessageIdentifier {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subMessageIdentifier
    subMessageIdentifier::const_reference get_subMessageIdentifier () const;
    subMessageIdentifier::reference ref_subMessageIdentifier ();
    subMessageIdentifier::reference set_subMessageIdentifier ();
    subMessageIdentifier::reference set_subMessageIdentifier (subMessageIdentifier::value_type::int_type value);
    void omit_subMessageIdentifier ();
    bool subMessageIdentifier_isPresent () const;
    class messageContent {
      public:
        typedef ASN1::SEQUENCE_OF<GenericParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class messageContent
    messageContent::const_reference get_messageContent () const;
    messageContent::reference ref_messageContent ();
    messageContent::reference set_messageContent ();
    messageContent::reference set_messageContent (messageContent::const_reference value);
    void omit_messageContent ();
    bool messageContent_isPresent () const;
    void swap(GenericMessage& other);
    GenericMessage * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

typedef GenericMessage GenericInformation;
//
// TerminalCapabilitySetAck
//

class TerminalCapabilitySetAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalCapabilitySetAck(const void* info) : Inherited(info) {}
  public:
    TerminalCapabilitySetAck() : Inherited(&theInfo) {}
    TerminalCapabilitySetAck(const TerminalCapabilitySetAck & other) : Inherited(other)
    {}
    TerminalCapabilitySetAck& operator = (const TerminalCapabilitySetAck& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_genericInformation
    };

    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(TerminalCapabilitySetAck& other);
    TerminalCapabilitySetAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// TerminalCapabilitySetReject
//

class TerminalCapabilitySetReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalCapabilitySetReject(const void* info) : Inherited(info) {}
  public:
    TerminalCapabilitySetReject() : Inherited(&theInfo) {}
    TerminalCapabilitySetReject(const TerminalCapabilitySetReject & other) : Inherited(other)
    {}
    TerminalCapabilitySetReject& operator = (const TerminalCapabilitySetReject& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_genericInformation
    };

    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class cause {
      public:
        typedef TerminalCapabilitySetReject_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(TerminalCapabilitySetReject& other);
    TerminalCapabilitySetReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H222Capability
//

class H222Capability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H222Capability(const void* info) : Inherited(info) {}
  public:
    H222Capability() : Inherited(&theInfo) {}
    H222Capability(const H222Capability & other) : Inherited(other)
    {}
    H222Capability& operator = (const H222Capability& other)
    { Inherited::operator = (other); return *this; } 
    class numberOfVCs {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfVCs
    numberOfVCs::const_reference get_numberOfVCs () const;
    numberOfVCs::reference ref_numberOfVCs ();
    numberOfVCs::reference set_numberOfVCs ();
    numberOfVCs::reference set_numberOfVCs (numberOfVCs::value_type::int_type value);
    class vcCapability {
      public:
        typedef ASN1::SET_OF<VCCapability>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vcCapability
    vcCapability::const_reference get_vcCapability () const;
    vcCapability::reference ref_vcCapability ();
    vcCapability::reference set_vcCapability ();
    vcCapability::reference set_vcCapability (vcCapability::const_reference value);
    void swap(H222Capability& other);
    H222Capability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MediaPacketizationCapability
//

class MediaPacketizationCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MediaPacketizationCapability(const void* info) : Inherited(info) {}
  public:
    MediaPacketizationCapability() : Inherited(&theInfo) {}
    MediaPacketizationCapability(const MediaPacketizationCapability & other) : Inherited(other)
    {}
    MediaPacketizationCapability& operator = (const MediaPacketizationCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_rtpPayloadType
    };

    class h261aVideoPacketization {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h261aVideoPacketization
    h261aVideoPacketization::const_reference get_h261aVideoPacketization () const;
    h261aVideoPacketization::reference ref_h261aVideoPacketization ();
    h261aVideoPacketization::reference set_h261aVideoPacketization ();
    h261aVideoPacketization::reference set_h261aVideoPacketization (bool value);
    class rtpPayloadType {
      public:
        typedef ASN1::SEQUENCE_OF<RTPPayloadType,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtpPayloadType
    rtpPayloadType::const_reference get_rtpPayloadType () const;
    rtpPayloadType::reference ref_rtpPayloadType ();
    rtpPayloadType::reference set_rtpPayloadType ();
    rtpPayloadType::reference set_rtpPayloadType (rtpPayloadType::const_reference value);
    void omit_rtpPayloadType ();
    bool rtpPayloadType_isPresent () const;
    void swap(MediaPacketizationCapability& other);
    MediaPacketizationCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RedundancyEncodingCapability
//

class RedundancyEncodingCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingCapability(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingCapability() : Inherited(&theInfo) {}
    RedundancyEncodingCapability(const RedundancyEncodingCapability & other) : Inherited(other)
    {}
    RedundancyEncodingCapability& operator = (const RedundancyEncodingCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_secondaryEncoding
    };

    class redundancyEncodingMethod {
      public:
        typedef RedundancyEncodingMethod value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingMethod
    redundancyEncodingMethod::const_reference get_redundancyEncodingMethod () const;
    redundancyEncodingMethod::reference ref_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod (redundancyEncodingMethod::const_reference value);
    class primaryEncoding {
      public:
        typedef CapabilityTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class primaryEncoding
    primaryEncoding::const_reference get_primaryEncoding () const;
    primaryEncoding::reference ref_primaryEncoding ();
    primaryEncoding::reference set_primaryEncoding ();
    primaryEncoding::reference set_primaryEncoding (primaryEncoding::value_type::int_type value);
    class secondaryEncoding {
      public:
        typedef ASN1::SEQUENCE_OF<CapabilityTableEntryNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class secondaryEncoding
    secondaryEncoding::const_reference get_secondaryEncoding () const;
    secondaryEncoding::reference ref_secondaryEncoding ();
    secondaryEncoding::reference set_secondaryEncoding ();
    secondaryEncoding::reference set_secondaryEncoding (secondaryEncoding::const_reference value);
    void omit_secondaryEncoding ();
    bool secondaryEncoding_isPresent () const;
    void swap(RedundancyEncodingCapability& other);
    RedundancyEncodingCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H263Options
//

class H263Options : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263Options(const void* info) : Inherited(info) {}
  public:
    H263Options() : Inherited(&theInfo) {}
    H263Options(const H263Options & other) : Inherited(other)
    {}
    H263Options& operator = (const H263Options& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_transparencyParameters,
      e_refPictureSelection,
      e_customPictureClockFrequency,
      e_customPictureFormat,
      e_modeCombos,
      e_videoBadMBsCap,
      e_h263Version3Options
    };

    class advancedIntraCodingMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class advancedIntraCodingMode
    advancedIntraCodingMode::const_reference get_advancedIntraCodingMode () const;
    advancedIntraCodingMode::reference ref_advancedIntraCodingMode ();
    advancedIntraCodingMode::reference set_advancedIntraCodingMode ();
    advancedIntraCodingMode::reference set_advancedIntraCodingMode (bool value);
    class deblockingFilterMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class deblockingFilterMode
    deblockingFilterMode::const_reference get_deblockingFilterMode () const;
    deblockingFilterMode::reference ref_deblockingFilterMode ();
    deblockingFilterMode::reference set_deblockingFilterMode ();
    deblockingFilterMode::reference set_deblockingFilterMode (bool value);
    class improvedPBFramesMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class improvedPBFramesMode
    improvedPBFramesMode::const_reference get_improvedPBFramesMode () const;
    improvedPBFramesMode::reference ref_improvedPBFramesMode ();
    improvedPBFramesMode::reference set_improvedPBFramesMode ();
    improvedPBFramesMode::reference set_improvedPBFramesMode (bool value);
    class unlimitedMotionVectors {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unlimitedMotionVectors
    unlimitedMotionVectors::const_reference get_unlimitedMotionVectors () const;
    unlimitedMotionVectors::reference ref_unlimitedMotionVectors ();
    unlimitedMotionVectors::reference set_unlimitedMotionVectors ();
    unlimitedMotionVectors::reference set_unlimitedMotionVectors (bool value);
    class fullPictureFreeze {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fullPictureFreeze
    fullPictureFreeze::const_reference get_fullPictureFreeze () const;
    fullPictureFreeze::reference ref_fullPictureFreeze ();
    fullPictureFreeze::reference set_fullPictureFreeze ();
    fullPictureFreeze::reference set_fullPictureFreeze (bool value);
    class partialPictureFreezeAndRelease {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class partialPictureFreezeAndRelease
    partialPictureFreezeAndRelease::const_reference get_partialPictureFreezeAndRelease () const;
    partialPictureFreezeAndRelease::reference ref_partialPictureFreezeAndRelease ();
    partialPictureFreezeAndRelease::reference set_partialPictureFreezeAndRelease ();
    partialPictureFreezeAndRelease::reference set_partialPictureFreezeAndRelease (bool value);
    class resizingPartPicFreezeAndRelease {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resizingPartPicFreezeAndRelease
    resizingPartPicFreezeAndRelease::const_reference get_resizingPartPicFreezeAndRelease () const;
    resizingPartPicFreezeAndRelease::reference ref_resizingPartPicFreezeAndRelease ();
    resizingPartPicFreezeAndRelease::reference set_resizingPartPicFreezeAndRelease ();
    resizingPartPicFreezeAndRelease::reference set_resizingPartPicFreezeAndRelease (bool value);
    class fullPictureSnapshot {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fullPictureSnapshot
    fullPictureSnapshot::const_reference get_fullPictureSnapshot () const;
    fullPictureSnapshot::reference ref_fullPictureSnapshot ();
    fullPictureSnapshot::reference set_fullPictureSnapshot ();
    fullPictureSnapshot::reference set_fullPictureSnapshot (bool value);
    class partialPictureSnapshot {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class partialPictureSnapshot
    partialPictureSnapshot::const_reference get_partialPictureSnapshot () const;
    partialPictureSnapshot::reference ref_partialPictureSnapshot ();
    partialPictureSnapshot::reference set_partialPictureSnapshot ();
    partialPictureSnapshot::reference set_partialPictureSnapshot (bool value);
    class videoSegmentTagging {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoSegmentTagging
    videoSegmentTagging::const_reference get_videoSegmentTagging () const;
    videoSegmentTagging::reference ref_videoSegmentTagging ();
    videoSegmentTagging::reference set_videoSegmentTagging ();
    videoSegmentTagging::reference set_videoSegmentTagging (bool value);
    class progressiveRefinement {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class progressiveRefinement
    progressiveRefinement::const_reference get_progressiveRefinement () const;
    progressiveRefinement::reference ref_progressiveRefinement ();
    progressiveRefinement::reference set_progressiveRefinement ();
    progressiveRefinement::reference set_progressiveRefinement (bool value);
    class dynamicPictureResizingByFour {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicPictureResizingByFour
    dynamicPictureResizingByFour::const_reference get_dynamicPictureResizingByFour () const;
    dynamicPictureResizingByFour::reference ref_dynamicPictureResizingByFour ();
    dynamicPictureResizingByFour::reference set_dynamicPictureResizingByFour ();
    dynamicPictureResizingByFour::reference set_dynamicPictureResizingByFour (bool value);
    class dynamicPictureResizingSixteenthPel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicPictureResizingSixteenthPel
    dynamicPictureResizingSixteenthPel::const_reference get_dynamicPictureResizingSixteenthPel () const;
    dynamicPictureResizingSixteenthPel::reference ref_dynamicPictureResizingSixteenthPel ();
    dynamicPictureResizingSixteenthPel::reference set_dynamicPictureResizingSixteenthPel ();
    dynamicPictureResizingSixteenthPel::reference set_dynamicPictureResizingSixteenthPel (bool value);
    class dynamicWarpingHalfPel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicWarpingHalfPel
    dynamicWarpingHalfPel::const_reference get_dynamicWarpingHalfPel () const;
    dynamicWarpingHalfPel::reference ref_dynamicWarpingHalfPel ();
    dynamicWarpingHalfPel::reference set_dynamicWarpingHalfPel ();
    dynamicWarpingHalfPel::reference set_dynamicWarpingHalfPel (bool value);
    class dynamicWarpingSixteenthPel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicWarpingSixteenthPel
    dynamicWarpingSixteenthPel::const_reference get_dynamicWarpingSixteenthPel () const;
    dynamicWarpingSixteenthPel::reference ref_dynamicWarpingSixteenthPel ();
    dynamicWarpingSixteenthPel::reference set_dynamicWarpingSixteenthPel ();
    dynamicWarpingSixteenthPel::reference set_dynamicWarpingSixteenthPel (bool value);
    class independentSegmentDecoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class independentSegmentDecoding
    independentSegmentDecoding::const_reference get_independentSegmentDecoding () const;
    independentSegmentDecoding::reference ref_independentSegmentDecoding ();
    independentSegmentDecoding::reference set_independentSegmentDecoding ();
    independentSegmentDecoding::reference set_independentSegmentDecoding (bool value);
    class slicesInOrder_NonRect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesInOrder_NonRect
    slicesInOrder_NonRect::const_reference get_slicesInOrder_NonRect () const;
    slicesInOrder_NonRect::reference ref_slicesInOrder_NonRect ();
    slicesInOrder_NonRect::reference set_slicesInOrder_NonRect ();
    slicesInOrder_NonRect::reference set_slicesInOrder_NonRect (bool value);
    class slicesInOrder_Rect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesInOrder_Rect
    slicesInOrder_Rect::const_reference get_slicesInOrder_Rect () const;
    slicesInOrder_Rect::reference ref_slicesInOrder_Rect ();
    slicesInOrder_Rect::reference set_slicesInOrder_Rect ();
    slicesInOrder_Rect::reference set_slicesInOrder_Rect (bool value);
    class slicesNoOrder_NonRect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesNoOrder_NonRect
    slicesNoOrder_NonRect::const_reference get_slicesNoOrder_NonRect () const;
    slicesNoOrder_NonRect::reference ref_slicesNoOrder_NonRect ();
    slicesNoOrder_NonRect::reference set_slicesNoOrder_NonRect ();
    slicesNoOrder_NonRect::reference set_slicesNoOrder_NonRect (bool value);
    class slicesNoOrder_Rect {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slicesNoOrder_Rect
    slicesNoOrder_Rect::const_reference get_slicesNoOrder_Rect () const;
    slicesNoOrder_Rect::reference ref_slicesNoOrder_Rect ();
    slicesNoOrder_Rect::reference set_slicesNoOrder_Rect ();
    slicesNoOrder_Rect::reference set_slicesNoOrder_Rect (bool value);
    class alternateInterVLCMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alternateInterVLCMode
    alternateInterVLCMode::const_reference get_alternateInterVLCMode () const;
    alternateInterVLCMode::reference ref_alternateInterVLCMode ();
    alternateInterVLCMode::reference set_alternateInterVLCMode ();
    alternateInterVLCMode::reference set_alternateInterVLCMode (bool value);
    class modifiedQuantizationMode {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class modifiedQuantizationMode
    modifiedQuantizationMode::const_reference get_modifiedQuantizationMode () const;
    modifiedQuantizationMode::reference ref_modifiedQuantizationMode ();
    modifiedQuantizationMode::reference set_modifiedQuantizationMode ();
    modifiedQuantizationMode::reference set_modifiedQuantizationMode (bool value);
    class reducedResolutionUpdate {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reducedResolutionUpdate
    reducedResolutionUpdate::const_reference get_reducedResolutionUpdate () const;
    reducedResolutionUpdate::reference ref_reducedResolutionUpdate ();
    reducedResolutionUpdate::reference set_reducedResolutionUpdate ();
    reducedResolutionUpdate::reference set_reducedResolutionUpdate (bool value);
    class transparencyParameters {
      public:
        typedef TransparencyParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transparencyParameters
    transparencyParameters::const_reference get_transparencyParameters () const;
    transparencyParameters::reference ref_transparencyParameters ();
    transparencyParameters::reference set_transparencyParameters ();
    transparencyParameters::reference set_transparencyParameters (transparencyParameters::const_reference value);
    void omit_transparencyParameters ();
    bool transparencyParameters_isPresent () const;
    class separateVideoBackChannel {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateVideoBackChannel
    separateVideoBackChannel::const_reference get_separateVideoBackChannel () const;
    separateVideoBackChannel::reference ref_separateVideoBackChannel ();
    separateVideoBackChannel::reference set_separateVideoBackChannel ();
    separateVideoBackChannel::reference set_separateVideoBackChannel (bool value);
    class refPictureSelection {
      public:
        typedef RefPictureSelection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class refPictureSelection
    refPictureSelection::const_reference get_refPictureSelection () const;
    refPictureSelection::reference ref_refPictureSelection ();
    refPictureSelection::reference set_refPictureSelection ();
    refPictureSelection::reference set_refPictureSelection (refPictureSelection::const_reference value);
    void omit_refPictureSelection ();
    bool refPictureSelection_isPresent () const;
    class customPictureClockFrequency {
      public:
        typedef ASN1::SET_OF<CustomPictureClockFrequency,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class customPictureClockFrequency
    customPictureClockFrequency::const_reference get_customPictureClockFrequency () const;
    customPictureClockFrequency::reference ref_customPictureClockFrequency ();
    customPictureClockFrequency::reference set_customPictureClockFrequency ();
    customPictureClockFrequency::reference set_customPictureClockFrequency (customPictureClockFrequency::const_reference value);
    void omit_customPictureClockFrequency ();
    bool customPictureClockFrequency_isPresent () const;
    class customPictureFormat {
      public:
        typedef ASN1::SET_OF<CustomPictureFormat,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class customPictureFormat
    customPictureFormat::const_reference get_customPictureFormat () const;
    customPictureFormat::reference ref_customPictureFormat ();
    customPictureFormat::reference set_customPictureFormat ();
    customPictureFormat::reference set_customPictureFormat (customPictureFormat::const_reference value);
    void omit_customPictureFormat ();
    bool customPictureFormat_isPresent () const;
    class modeCombos {
      public:
        typedef ASN1::SET_OF<H263VideoModeCombos,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class modeCombos
    modeCombos::const_reference get_modeCombos () const;
    modeCombos::reference ref_modeCombos ();
    modeCombos::reference set_modeCombos ();
    modeCombos::reference set_modeCombos (modeCombos::const_reference value);
    void omit_modeCombos ();
    bool modeCombos_isPresent () const;
    class videoBadMBsCap {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBadMBsCap
    videoBadMBsCap::const_reference get_videoBadMBsCap () const;
    videoBadMBsCap::reference ref_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap ();
    videoBadMBsCap::reference set_videoBadMBsCap (bool value);
    void omit_videoBadMBsCap ();
    bool videoBadMBsCap_isPresent () const;
    class h263Version3Options {
      public:
        typedef H263Version3Options value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263Version3Options
    h263Version3Options::const_reference get_h263Version3Options () const;
    h263Version3Options::reference ref_h263Version3Options ();
    h263Version3Options::reference set_h263Version3Options ();
    h263Version3Options::reference set_h263Version3Options (h263Version3Options::const_reference value);
    void omit_h263Version3Options ();
    bool h263Version3Options_isPresent () const;
    void swap(H263Options& other);
    H263Options * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[31];
    static int fieldIds[31];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[31];
};

//
// GenericCapability
//

class GenericCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    GenericCapability(const void* info) : Inherited(info) {}
  public:
    GenericCapability() : Inherited(&theInfo) {}
    GenericCapability(const GenericCapability & other) : Inherited(other)
    {}
    GenericCapability& operator = (const GenericCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_maxBitRate,
      e_collapsing,
      e_nonCollapsing,
      e_nonCollapsingRaw,
      e_transport
    };

    class capabilityIdentifier {
      public:
        typedef CapabilityIdentifier value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityIdentifier
    capabilityIdentifier::const_reference get_capabilityIdentifier () const;
    capabilityIdentifier::reference ref_capabilityIdentifier ();
    capabilityIdentifier::reference set_capabilityIdentifier ();
    capabilityIdentifier::reference set_capabilityIdentifier (capabilityIdentifier::const_reference value);
    class maxBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxBitRate
    maxBitRate::const_reference get_maxBitRate () const;
    maxBitRate::reference ref_maxBitRate ();
    maxBitRate::reference set_maxBitRate ();
    maxBitRate::reference set_maxBitRate (maxBitRate::value_type::int_type value);
    void omit_maxBitRate ();
    bool maxBitRate_isPresent () const;
    class collapsing {
      public:
        typedef ASN1::SEQUENCE_OF<GenericParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class collapsing
    collapsing::const_reference get_collapsing () const;
    collapsing::reference ref_collapsing ();
    collapsing::reference set_collapsing ();
    collapsing::reference set_collapsing (collapsing::const_reference value);
    void omit_collapsing ();
    bool collapsing_isPresent () const;
    class nonCollapsing {
      public:
        typedef ASN1::SEQUENCE_OF<GenericParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonCollapsing
    nonCollapsing::const_reference get_nonCollapsing () const;
    nonCollapsing::reference ref_nonCollapsing ();
    nonCollapsing::reference set_nonCollapsing ();
    nonCollapsing::reference set_nonCollapsing (nonCollapsing::const_reference value);
    void omit_nonCollapsing ();
    bool nonCollapsing_isPresent () const;
    class nonCollapsingRaw {
      public:
        typedef ASN1::OCTET_STRING value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonCollapsingRaw
    nonCollapsingRaw::const_reference get_nonCollapsingRaw () const;
    nonCollapsingRaw::reference ref_nonCollapsingRaw ();
    nonCollapsingRaw::reference set_nonCollapsingRaw ();
    nonCollapsingRaw::reference set_nonCollapsingRaw (const std::vector<char>& value);
    void omit_nonCollapsingRaw ();
    bool nonCollapsingRaw_isPresent () const;
    class transport {
      public:
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transport
    transport::const_reference get_transport () const;
    transport::reference ref_transport ();
    transport::reference set_transport ();
    transport::reference set_transport (transport::const_reference value);
    void omit_transport ();
    bool transport_isPresent () const;
    void swap(GenericCapability& other);
    GenericCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// MultiplexFormat
//

class MultiplexFormat : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexFormat(const void* info) : Inherited(info) {}
  public:
    MultiplexFormat() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class h222Capability {
      public:
        enum Id { id_ = 1 };
        typedef H222Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h222Capability

    h222Capability::const_reference get_h222Capability () const;
    h222Capability::reference ref_h222Capability (); 
    h222Capability::reference select_h222Capability (); 
    h222Capability::reference select_h222Capability (h222Capability::const_reference value); 
    bool h222Capability_isSelected() const;

    class h223Capability {
      public:
        enum Id { id_ = 2 };
        typedef H223Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223Capability

    h223Capability::const_reference get_h223Capability () const;
    h223Capability::reference ref_h223Capability (); 
    h223Capability::reference select_h223Capability (); 
    h223Capability::reference select_h223Capability (h223Capability::const_reference value); 
    bool h223Capability_isSelected() const;

    MultiplexFormat(nonStandard::Id id, nonStandard::const_reference value);
    MultiplexFormat(h222Capability::Id id, h222Capability::const_reference value);
    MultiplexFormat(h223Capability::Id id, h223Capability::const_reference value);
    void swap(MultiplexFormat & other);
    MultiplexFormat(const MultiplexFormat & other)
    : Inherited(other) {} 

    MultiplexFormat & operator = (const MultiplexFormat & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultiplexFormat * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// NetworkAccessParameters
//

class NetworkAccessParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    NetworkAccessParameters(const void* info) : Inherited(info) {}
  public:
    NetworkAccessParameters() : Inherited(&theInfo) {}
    NetworkAccessParameters(const NetworkAccessParameters & other) : Inherited(other)
    {}
    NetworkAccessParameters& operator = (const NetworkAccessParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_distribution,
      e_externalReference,
      e_t120SetupProcedure
    };

    class distribution {
      public:
        typedef NetworkAccessParameters_distribution value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class distribution
    distribution::const_reference get_distribution () const;
    distribution::reference ref_distribution ();
    distribution::reference set_distribution ();
    distribution::reference set_distribution (distribution::const_reference value);
    void omit_distribution ();
    bool distribution_isPresent () const;
    class networkAddress {
      public:
        typedef NetworkAccessParameters_networkAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class networkAddress
    networkAddress::const_reference get_networkAddress () const;
    networkAddress::reference ref_networkAddress ();
    networkAddress::reference set_networkAddress ();
    networkAddress::reference set_networkAddress (networkAddress::const_reference value);
    class associateConference {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class associateConference
    associateConference::const_reference get_associateConference () const;
    associateConference::reference ref_associateConference ();
    associateConference::reference set_associateConference ();
    associateConference::reference set_associateConference (bool value);
    class externalReference {
      public:
        typedef ASN1::Constrained_OCTET_STRING< ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 255> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class externalReference
    externalReference::const_reference get_externalReference () const;
    externalReference::reference ref_externalReference ();
    externalReference::reference set_externalReference ();
    externalReference::reference set_externalReference (const std::vector<char>& value);
    void omit_externalReference ();
    bool externalReference_isPresent () const;
    class t120SetupProcedure {
      public:
        typedef NetworkAccessParameters_t120SetupProcedure value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t120SetupProcedure
    t120SetupProcedure::const_reference get_t120SetupProcedure () const;
    t120SetupProcedure::reference ref_t120SetupProcedure ();
    t120SetupProcedure::reference set_t120SetupProcedure ();
    t120SetupProcedure::reference set_t120SetupProcedure (t120SetupProcedure::const_reference value);
    void omit_t120SetupProcedure ();
    bool t120SetupProcedure_isPresent () const;
    void swap(NetworkAccessParameters& other);
    NetworkAccessParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// MultiplexedStreamParameter
//

class MultiplexedStreamParameter : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexedStreamParameter(const void* info) : Inherited(info) {}
  public:
    MultiplexedStreamParameter() : Inherited(&theInfo) {}
    MultiplexedStreamParameter(const MultiplexedStreamParameter & other) : Inherited(other)
    {}
    MultiplexedStreamParameter& operator = (const MultiplexedStreamParameter& other)
    { Inherited::operator = (other); return *this; } 
    class multiplexFormat {
      public:
        typedef MultiplexFormat value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexFormat
    multiplexFormat::const_reference get_multiplexFormat () const;
    multiplexFormat::reference ref_multiplexFormat ();
    multiplexFormat::reference set_multiplexFormat ();
    multiplexFormat::reference set_multiplexFormat (multiplexFormat::const_reference value);
    class controlOnMuxStream {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class controlOnMuxStream
    controlOnMuxStream::const_reference get_controlOnMuxStream () const;
    controlOnMuxStream::reference ref_controlOnMuxStream ();
    controlOnMuxStream::reference set_controlOnMuxStream ();
    controlOnMuxStream::reference set_controlOnMuxStream (bool value);
    void swap(MultiplexedStreamParameter& other);
    MultiplexedStreamParameter * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H2250LogicalChannelParameters
//

class H2250LogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250LogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    H2250LogicalChannelParameters() : Inherited(&theInfo) {}
    H2250LogicalChannelParameters(const H2250LogicalChannelParameters & other) : Inherited(other)
    {}
    H2250LogicalChannelParameters& operator = (const H2250LogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard,
      e_associatedSessionID,
      e_mediaChannel,
      e_mediaGuaranteedDelivery,
      e_mediaControlChannel,
      e_mediaControlGuaranteedDelivery,
      e_silenceSuppression,
      e_destination,
      e_dynamicRTPPayloadType,
      e_mediaPacketization,
      e_transportCapability,
      e_source
    };

    class nonStandard {
      public:
        typedef ASN1::SEQUENCE_OF<NonStandardParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    class sessionID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sessionID
    sessionID::const_reference get_sessionID () const;
    sessionID::reference ref_sessionID ();
    sessionID::reference set_sessionID ();
    sessionID::reference set_sessionID (sessionID::value_type::int_type value);
    class associatedSessionID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class associatedSessionID
    associatedSessionID::const_reference get_associatedSessionID () const;
    associatedSessionID::reference ref_associatedSessionID ();
    associatedSessionID::reference set_associatedSessionID ();
    associatedSessionID::reference set_associatedSessionID (associatedSessionID::value_type::int_type value);
    void omit_associatedSessionID ();
    bool associatedSessionID_isPresent () const;
    class mediaChannel {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaChannel
    mediaChannel::const_reference get_mediaChannel () const;
    mediaChannel::reference ref_mediaChannel ();
    mediaChannel::reference set_mediaChannel ();
    mediaChannel::reference set_mediaChannel (mediaChannel::const_reference value);
    void omit_mediaChannel ();
    bool mediaChannel_isPresent () const;
    class mediaGuaranteedDelivery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaGuaranteedDelivery
    mediaGuaranteedDelivery::const_reference get_mediaGuaranteedDelivery () const;
    mediaGuaranteedDelivery::reference ref_mediaGuaranteedDelivery ();
    mediaGuaranteedDelivery::reference set_mediaGuaranteedDelivery ();
    mediaGuaranteedDelivery::reference set_mediaGuaranteedDelivery (bool value);
    void omit_mediaGuaranteedDelivery ();
    bool mediaGuaranteedDelivery_isPresent () const;
    class mediaControlChannel {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaControlChannel
    mediaControlChannel::const_reference get_mediaControlChannel () const;
    mediaControlChannel::reference ref_mediaControlChannel ();
    mediaControlChannel::reference set_mediaControlChannel ();
    mediaControlChannel::reference set_mediaControlChannel (mediaControlChannel::const_reference value);
    void omit_mediaControlChannel ();
    bool mediaControlChannel_isPresent () const;
    class mediaControlGuaranteedDelivery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaControlGuaranteedDelivery
    mediaControlGuaranteedDelivery::const_reference get_mediaControlGuaranteedDelivery () const;
    mediaControlGuaranteedDelivery::reference ref_mediaControlGuaranteedDelivery ();
    mediaControlGuaranteedDelivery::reference set_mediaControlGuaranteedDelivery ();
    mediaControlGuaranteedDelivery::reference set_mediaControlGuaranteedDelivery (bool value);
    void omit_mediaControlGuaranteedDelivery ();
    bool mediaControlGuaranteedDelivery_isPresent () const;
    class silenceSuppression {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class silenceSuppression
    silenceSuppression::const_reference get_silenceSuppression () const;
    silenceSuppression::reference ref_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression ();
    silenceSuppression::reference set_silenceSuppression (bool value);
    void omit_silenceSuppression ();
    bool silenceSuppression_isPresent () const;
    class destination {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class destination
    destination::const_reference get_destination () const;
    destination::reference ref_destination ();
    destination::reference set_destination ();
    destination::reference set_destination (destination::const_reference value);
    void omit_destination ();
    bool destination_isPresent () const;
    class dynamicRTPPayloadType {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 96, 127>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dynamicRTPPayloadType
    dynamicRTPPayloadType::const_reference get_dynamicRTPPayloadType () const;
    dynamicRTPPayloadType::reference ref_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType ();
    dynamicRTPPayloadType::reference set_dynamicRTPPayloadType (dynamicRTPPayloadType::value_type::int_type value);
    void omit_dynamicRTPPayloadType ();
    bool dynamicRTPPayloadType_isPresent () const;
    class mediaPacketization {
      public:
        typedef H2250LogicalChannelParameters_mediaPacketization value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaPacketization
    mediaPacketization::const_reference get_mediaPacketization () const;
    mediaPacketization::reference ref_mediaPacketization ();
    mediaPacketization::reference set_mediaPacketization ();
    mediaPacketization::reference set_mediaPacketization (mediaPacketization::const_reference value);
    void omit_mediaPacketization ();
    bool mediaPacketization_isPresent () const;
    class transportCapability {
      public:
        typedef TransportCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportCapability
    transportCapability::const_reference get_transportCapability () const;
    transportCapability::reference ref_transportCapability ();
    transportCapability::reference set_transportCapability ();
    transportCapability::reference set_transportCapability (transportCapability::const_reference value);
    void omit_transportCapability ();
    bool transportCapability_isPresent () const;
    class source {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class source
    source::const_reference get_source () const;
    source::reference ref_source ();
    source::reference set_source ();
    source::reference set_source (source::const_reference value);
    void omit_source ();
    bool source_isPresent () const;
    void swap(H2250LogicalChannelParameters& other);
    H2250LogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[13];
    static int fieldIds[13];
    static const char* fieldNames[13];
};

//
// DepFECData
//

class DepFECData : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DepFECData(const void* info) : Inherited(info) {}
  public:
    DepFECData() : Inherited(&theInfo) {}
    class rfc2733 {
      public:
        enum Id { id_ = 0 };
        typedef DepFECData_rfc2733 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rfc2733

    rfc2733::const_reference get_rfc2733 () const;
    rfc2733::reference ref_rfc2733 (); 
    rfc2733::reference select_rfc2733 (); 
    rfc2733::reference select_rfc2733 (rfc2733::const_reference value); 
    bool rfc2733_isSelected() const;

    DepFECData(rfc2733::Id id, rfc2733::const_reference value);
    void swap(DepFECData & other);
    DepFECData(const DepFECData & other)
    : Inherited(other) {} 

    DepFECData & operator = (const DepFECData & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DepFECData * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// OpenLogicalChannelReject
//

class OpenLogicalChannelReject : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelReject(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelReject() : Inherited(&theInfo) {}
    OpenLogicalChannelReject(const OpenLogicalChannelReject & other) : Inherited(other)
    {}
    OpenLogicalChannelReject& operator = (const OpenLogicalChannelReject& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_genericInformation
    };

    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class cause {
      public:
        typedef OpenLogicalChannelReject_cause value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cause
    cause::const_reference get_cause () const;
    cause::reference ref_cause ();
    cause::reference set_cause ();
    cause::reference set_cause (cause::const_reference value);
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(OpenLogicalChannelReject& other);
    OpenLogicalChannelReject * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// OpenLogicalChannelConfirm
//

class OpenLogicalChannelConfirm : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelConfirm(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelConfirm() : Inherited(&theInfo) {}
    OpenLogicalChannelConfirm(const OpenLogicalChannelConfirm & other) : Inherited(other)
    {}
    OpenLogicalChannelConfirm& operator = (const OpenLogicalChannelConfirm& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_genericInformation
    };

    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(OpenLogicalChannelConfirm& other);
    OpenLogicalChannelConfirm * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// AudioMode
//

class AudioMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AudioMode(const void* info) : Inherited(info) {}
  public:
    AudioMode() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class g711Alaw64k {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Alaw64k

    g711Alaw64k::reference select_g711Alaw64k (); 
    bool g711Alaw64k_isSelected() const;

    class g711Alaw56k {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Alaw56k

    g711Alaw56k::reference select_g711Alaw56k (); 
    bool g711Alaw56k_isSelected() const;

    class g711Ulaw64k {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Ulaw64k

    g711Ulaw64k::reference select_g711Ulaw64k (); 
    bool g711Ulaw64k_isSelected() const;

    class g711Ulaw56k {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Ulaw56k

    g711Ulaw56k::reference select_g711Ulaw56k (); 
    bool g711Ulaw56k_isSelected() const;

    class g722_64k {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g722_64k

    g722_64k::reference select_g722_64k (); 
    bool g722_64k_isSelected() const;

    class g722_56k {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g722_56k

    g722_56k::reference select_g722_56k (); 
    bool g722_56k_isSelected() const;

    class g722_48k {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g722_48k

    g722_48k::reference select_g722_48k (); 
    bool g722_48k_isSelected() const;

    class g728 {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g728

    g728::reference select_g728 (); 
    bool g728_isSelected() const;

    class g729 {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729

    g729::reference select_g729 (); 
    bool g729_isSelected() const;

    class g729AnnexA {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729AnnexA

    g729AnnexA::reference select_g729AnnexA (); 
    bool g729AnnexA_isSelected() const;

    class g7231 {
      public:
        enum Id { id_ = 11 };
        typedef AudioMode_g7231 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g7231

    g7231::const_reference get_g7231 () const;
    g7231::reference ref_g7231 (); 
    g7231::reference select_g7231 (); 
    g7231::reference select_g7231 (g7231::const_reference value); 
    bool g7231_isSelected() const;

    class is11172AudioMode {
      public:
        enum Id { id_ = 12 };
        typedef IS11172AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class is11172AudioMode

    is11172AudioMode::const_reference get_is11172AudioMode () const;
    is11172AudioMode::reference ref_is11172AudioMode (); 
    is11172AudioMode::reference select_is11172AudioMode (); 
    is11172AudioMode::reference select_is11172AudioMode (is11172AudioMode::const_reference value); 
    bool is11172AudioMode_isSelected() const;

    class is13818AudioMode {
      public:
        enum Id { id_ = 13 };
        typedef IS13818AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class is13818AudioMode

    is13818AudioMode::const_reference get_is13818AudioMode () const;
    is13818AudioMode::reference ref_is13818AudioMode (); 
    is13818AudioMode::reference select_is13818AudioMode (); 
    is13818AudioMode::reference select_is13818AudioMode (is13818AudioMode::const_reference value); 
    bool is13818AudioMode_isSelected() const;

    class g729wAnnexB {
      public:
        enum Id { id_ = 14 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729wAnnexB

    g729wAnnexB::const_reference get_g729wAnnexB () const;
    g729wAnnexB::reference ref_g729wAnnexB (); 
    g729wAnnexB::reference select_g729wAnnexB (); 
    g729wAnnexB::reference select_g729wAnnexB (g729wAnnexB::value_type::int_type value); 
    bool g729wAnnexB_isSelected() const;

    class g729AnnexAwAnnexB {
      public:
        enum Id { id_ = 15 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729AnnexAwAnnexB

    g729AnnexAwAnnexB::const_reference get_g729AnnexAwAnnexB () const;
    g729AnnexAwAnnexB::reference ref_g729AnnexAwAnnexB (); 
    g729AnnexAwAnnexB::reference select_g729AnnexAwAnnexB (); 
    g729AnnexAwAnnexB::reference select_g729AnnexAwAnnexB (g729AnnexAwAnnexB::value_type::int_type value); 
    bool g729AnnexAwAnnexB_isSelected() const;

    class g7231AnnexCMode {
      public:
        enum Id { id_ = 16 };
        typedef G7231AnnexCMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g7231AnnexCMode

    g7231AnnexCMode::const_reference get_g7231AnnexCMode () const;
    g7231AnnexCMode::reference ref_g7231AnnexCMode (); 
    g7231AnnexCMode::reference select_g7231AnnexCMode (); 
    g7231AnnexCMode::reference select_g7231AnnexCMode (g7231AnnexCMode::const_reference value); 
    bool g7231AnnexCMode_isSelected() const;

    class gsmFullRate {
      public:
        enum Id { id_ = 17 };
        typedef GSMAudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gsmFullRate

    gsmFullRate::const_reference get_gsmFullRate () const;
    gsmFullRate::reference ref_gsmFullRate (); 
    gsmFullRate::reference select_gsmFullRate (); 
    gsmFullRate::reference select_gsmFullRate (gsmFullRate::const_reference value); 
    bool gsmFullRate_isSelected() const;

    class gsmHalfRate {
      public:
        enum Id { id_ = 18 };
        typedef GSMAudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gsmHalfRate

    gsmHalfRate::const_reference get_gsmHalfRate () const;
    gsmHalfRate::reference ref_gsmHalfRate (); 
    gsmHalfRate::reference select_gsmHalfRate (); 
    gsmHalfRate::reference select_gsmHalfRate (gsmHalfRate::const_reference value); 
    bool gsmHalfRate_isSelected() const;

    class gsmEnhancedFullRate {
      public:
        enum Id { id_ = 19 };
        typedef GSMAudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gsmEnhancedFullRate

    gsmEnhancedFullRate::const_reference get_gsmEnhancedFullRate () const;
    gsmEnhancedFullRate::reference ref_gsmEnhancedFullRate (); 
    gsmEnhancedFullRate::reference select_gsmEnhancedFullRate (); 
    gsmEnhancedFullRate::reference select_gsmEnhancedFullRate (gsmEnhancedFullRate::const_reference value); 
    bool gsmEnhancedFullRate_isSelected() const;

    class genericAudioMode {
      public:
        enum Id { id_ = 20 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericAudioMode

    genericAudioMode::const_reference get_genericAudioMode () const;
    genericAudioMode::reference ref_genericAudioMode (); 
    genericAudioMode::reference select_genericAudioMode (); 
    genericAudioMode::reference select_genericAudioMode (genericAudioMode::const_reference value); 
    bool genericAudioMode_isSelected() const;

    class g729Extensions {
      public:
        enum Id { id_ = 21 };
        typedef G729Extensions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729Extensions

    g729Extensions::const_reference get_g729Extensions () const;
    g729Extensions::reference ref_g729Extensions (); 
    g729Extensions::reference select_g729Extensions (); 
    g729Extensions::reference select_g729Extensions (g729Extensions::const_reference value); 
    bool g729Extensions_isSelected() const;

    class vbd {
      public:
        enum Id { id_ = 22 };
        typedef VBDMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vbd

    vbd::const_reference get_vbd () const;
    vbd::reference ref_vbd (); 
    vbd::reference select_vbd (); 
    vbd::reference select_vbd (vbd::const_reference value); 
    bool vbd_isSelected() const;

    AudioMode(nonStandard::Id id, nonStandard::const_reference value);
    AudioMode(g711Alaw64k::Id id, g711Alaw64k::const_reference value);
    AudioMode(g711Alaw56k::Id id, g711Alaw56k::const_reference value);
    AudioMode(g711Ulaw64k::Id id, g711Ulaw64k::const_reference value);
    AudioMode(g711Ulaw56k::Id id, g711Ulaw56k::const_reference value);
    AudioMode(g722_64k::Id id, g722_64k::const_reference value);
    AudioMode(g722_56k::Id id, g722_56k::const_reference value);
    AudioMode(g722_48k::Id id, g722_48k::const_reference value);
    AudioMode(g728::Id id, g728::const_reference value);
    AudioMode(g729::Id id, g729::const_reference value);
    AudioMode(g729AnnexA::Id id, g729AnnexA::const_reference value);
    AudioMode(g7231::Id id, g7231::const_reference value);
    AudioMode(is11172AudioMode::Id id, is11172AudioMode::const_reference value);
    AudioMode(is13818AudioMode::Id id, is13818AudioMode::const_reference value);
    AudioMode(g729wAnnexB::Id id, g729wAnnexB::value_type::int_type value);
    AudioMode(g729AnnexAwAnnexB::Id id, g729AnnexAwAnnexB::value_type::int_type value);
    AudioMode(g7231AnnexCMode::Id id, g7231AnnexCMode::const_reference value);
    AudioMode(gsmFullRate::Id id, gsmFullRate::const_reference value);
    AudioMode(gsmHalfRate::Id id, gsmHalfRate::const_reference value);
    AudioMode(gsmEnhancedFullRate::Id id, gsmEnhancedFullRate::const_reference value);
    AudioMode(genericAudioMode::Id id, genericAudioMode::const_reference value);
    AudioMode(g729Extensions::Id id, g729Extensions::const_reference value);
    AudioMode(vbd::Id id, vbd::const_reference value);
    void swap(AudioMode & other);
    AudioMode(const AudioMode & other)
    : Inherited(other) {} 

    AudioMode & operator = (const AudioMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    AudioMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[23];
    static const char* selectionNames[23];
};

//
// DialingInformationNumber
//

class DialingInformationNumber : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DialingInformationNumber(const void* info) : Inherited(info) {}
  public:
    DialingInformationNumber() : Inherited(&theInfo) {}
    DialingInformationNumber(const DialingInformationNumber & other) : Inherited(other)
    {}
    DialingInformationNumber& operator = (const DialingInformationNumber& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_subAddress
    };

    class networkAddress {
      public:
        class value_type : public ASN1::NumericString
        {
            typedef ASN1::NumericString Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class networkAddress
    networkAddress::const_reference get_networkAddress () const;
    networkAddress::reference ref_networkAddress ();
    networkAddress::reference set_networkAddress ();
    networkAddress::reference set_networkAddress (const std::string& value);
    class subAddress {
      public:
        class value_type : public ASN1::IA5String
        {
            typedef ASN1::IA5String Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const char* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::string& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const char* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class subAddress
    subAddress::const_reference get_subAddress () const;
    subAddress::reference ref_subAddress ();
    subAddress::reference set_subAddress ();
    subAddress::reference set_subAddress (const std::string& value);
    void omit_subAddress ();
    bool subAddress_isPresent () const;
    class networkType {
      public:
        typedef ASN1::SET_OF<DialingInformationNetworkType,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 255> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class networkType
    networkType::const_reference get_networkType () const;
    networkType::reference ref_networkType ();
    networkType::reference set_networkType ();
    networkType::reference set_networkType (networkType::const_reference value);
    void swap(DialingInformationNumber& other);
    DialingInformationNumber * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// EndSessionCommand
//

class EndSessionCommand : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EndSessionCommand(const void* info) : Inherited(info) {}
  public:
    EndSessionCommand() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class disconnect {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class disconnect

    disconnect::reference select_disconnect (); 
    bool disconnect_isSelected() const;

    class gstnOptions {
      public:
        enum Id { id_ = 2 };
        typedef EndSessionCommand_gstnOptions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gstnOptions

    gstnOptions::const_reference get_gstnOptions () const;
    gstnOptions::reference ref_gstnOptions (); 
    gstnOptions::reference select_gstnOptions (); 
    gstnOptions::reference select_gstnOptions (gstnOptions::const_reference value); 
    bool gstnOptions_isSelected() const;

    class isdnOptions {
      public:
        enum Id { id_ = 3 };
        typedef EndSessionCommand_isdnOptions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class isdnOptions

    isdnOptions::const_reference get_isdnOptions () const;
    isdnOptions::reference ref_isdnOptions (); 
    isdnOptions::reference select_isdnOptions (); 
    isdnOptions::reference select_isdnOptions (isdnOptions::const_reference value); 
    bool isdnOptions_isSelected() const;

    class genericInformation {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation

    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation (); 
    genericInformation::reference select_genericInformation (); 
    genericInformation::reference select_genericInformation (genericInformation::const_reference value); 
    bool genericInformation_isSelected() const;

    EndSessionCommand(nonStandard::Id id, nonStandard::const_reference value);
    EndSessionCommand(disconnect::Id id, disconnect::const_reference value);
    EndSessionCommand(gstnOptions::Id id, gstnOptions::const_reference value);
    EndSessionCommand(isdnOptions::Id id, isdnOptions::const_reference value);
    EndSessionCommand(genericInformation::Id id, genericInformation::const_reference value);
    void swap(EndSessionCommand & other);
    EndSessionCommand(const EndSessionCommand & other)
    : Inherited(other) {} 

    EndSessionCommand & operator = (const EndSessionCommand & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    EndSessionCommand * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// UserInputIndication
//

class UserInputIndication : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputIndication(const void* info) : Inherited(info) {}
  public:
    UserInputIndication() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class alphanumeric {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::GeneralString value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class alphanumeric

    alphanumeric::const_reference get_alphanumeric () const;
    alphanumeric::reference ref_alphanumeric (); 
    alphanumeric::reference select_alphanumeric (); 
    alphanumeric::reference select_alphanumeric (const std::string& value); 
    bool alphanumeric_isSelected() const;

    class userInputSupportIndication {
      public:
        enum Id { id_ = 2 };
        typedef UserInputIndication_userInputSupportIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class userInputSupportIndication

    userInputSupportIndication::const_reference get_userInputSupportIndication () const;
    userInputSupportIndication::reference ref_userInputSupportIndication (); 
    userInputSupportIndication::reference select_userInputSupportIndication (); 
    userInputSupportIndication::reference select_userInputSupportIndication (userInputSupportIndication::const_reference value); 
    bool userInputSupportIndication_isSelected() const;

    class signal {
      public:
        enum Id { id_ = 3 };
        typedef UserInputIndication_signal value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class signal

    signal::const_reference get_signal () const;
    signal::reference ref_signal (); 
    signal::reference select_signal (); 
    signal::reference select_signal (signal::const_reference value); 
    bool signal_isSelected() const;

    class signalUpdate {
      public:
        enum Id { id_ = 4 };
        typedef UserInputIndication_signalUpdate value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class signalUpdate

    signalUpdate::const_reference get_signalUpdate () const;
    signalUpdate::reference ref_signalUpdate (); 
    signalUpdate::reference select_signalUpdate (); 
    signalUpdate::reference select_signalUpdate (signalUpdate::const_reference value); 
    bool signalUpdate_isSelected() const;

    class extendedAlphanumeric {
      public:
        enum Id { id_ = 5 };
        typedef UserInputIndication_extendedAlphanumeric value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class extendedAlphanumeric

    extendedAlphanumeric::const_reference get_extendedAlphanumeric () const;
    extendedAlphanumeric::reference ref_extendedAlphanumeric (); 
    extendedAlphanumeric::reference select_extendedAlphanumeric (); 
    extendedAlphanumeric::reference select_extendedAlphanumeric (extendedAlphanumeric::const_reference value); 
    bool extendedAlphanumeric_isSelected() const;

    class encryptedAlphanumeric {
      public:
        enum Id { id_ = 6 };
        typedef UserInputIndication_encryptedAlphanumeric value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedAlphanumeric

    encryptedAlphanumeric::const_reference get_encryptedAlphanumeric () const;
    encryptedAlphanumeric::reference ref_encryptedAlphanumeric (); 
    encryptedAlphanumeric::reference select_encryptedAlphanumeric (); 
    encryptedAlphanumeric::reference select_encryptedAlphanumeric (encryptedAlphanumeric::const_reference value); 
    bool encryptedAlphanumeric_isSelected() const;

    class genericInformation {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation

    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation (); 
    genericInformation::reference select_genericInformation (); 
    genericInformation::reference select_genericInformation (genericInformation::const_reference value); 
    bool genericInformation_isSelected() const;

    UserInputIndication(nonStandard::Id id, nonStandard::const_reference value);
    UserInputIndication(alphanumeric::Id id, const std::string& value);
    UserInputIndication(userInputSupportIndication::Id id, userInputSupportIndication::const_reference value);
    UserInputIndication(signal::Id id, signal::const_reference value);
    UserInputIndication(signalUpdate::Id id, signalUpdate::const_reference value);
    UserInputIndication(extendedAlphanumeric::Id id, extendedAlphanumeric::const_reference value);
    UserInputIndication(encryptedAlphanumeric::Id id, encryptedAlphanumeric::const_reference value);
    UserInputIndication(genericInformation::Id id, genericInformation::const_reference value);
    void swap(UserInputIndication & other);
    UserInputIndication(const UserInputIndication & other)
    : Inherited(other) {} 

    UserInputIndication & operator = (const UserInputIndication & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    UserInputIndication * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[8];
    static const char* selectionNames[8];
};

//
// DataApplicationCapability_application
//

class DataApplicationCapability_application : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataApplicationCapability_application(const void* info) : Inherited(info) {}
  public:
    DataApplicationCapability_application() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class t120 {
      public:
        enum Id { id_ = 1 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t120

    t120::const_reference get_t120 () const;
    t120::reference ref_t120 (); 
    t120::reference select_t120 (); 
    t120::reference select_t120 (t120::const_reference value); 
    bool t120_isSelected() const;

    class dsm_cc {
      public:
        enum Id { id_ = 2 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dsm_cc

    dsm_cc::const_reference get_dsm_cc () const;
    dsm_cc::reference ref_dsm_cc (); 
    dsm_cc::reference select_dsm_cc (); 
    dsm_cc::reference select_dsm_cc (dsm_cc::const_reference value); 
    bool dsm_cc_isSelected() const;

    class userData {
      public:
        enum Id { id_ = 3 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class userData

    userData::const_reference get_userData () const;
    userData::reference ref_userData (); 
    userData::reference select_userData (); 
    userData::reference select_userData (userData::const_reference value); 
    bool userData_isSelected() const;

    class t84 {
      public:
        enum Id { id_ = 4 };
        typedef DataApplicationCapability_application_t84 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t84

    t84::const_reference get_t84 () const;
    t84::reference ref_t84 (); 
    t84::reference select_t84 (); 
    t84::reference select_t84 (t84::const_reference value); 
    bool t84_isSelected() const;

    class t434 {
      public:
        enum Id { id_ = 5 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t434

    t434::const_reference get_t434 () const;
    t434::reference ref_t434 (); 
    t434::reference select_t434 (); 
    t434::reference select_t434 (t434::const_reference value); 
    bool t434_isSelected() const;

    class h224 {
      public:
        enum Id { id_ = 6 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h224

    h224::const_reference get_h224 () const;
    h224::reference ref_h224 (); 
    h224::reference select_h224 (); 
    h224::reference select_h224 (h224::const_reference value); 
    bool h224_isSelected() const;

    class nlpid {
      public:
        enum Id { id_ = 7 };
        typedef DataApplicationCapability_application_nlpid value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nlpid

    nlpid::const_reference get_nlpid () const;
    nlpid::reference ref_nlpid (); 
    nlpid::reference select_nlpid (); 
    nlpid::reference select_nlpid (nlpid::const_reference value); 
    bool nlpid_isSelected() const;

    class dsvdControl {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dsvdControl

    dsvdControl::reference select_dsvdControl (); 
    bool dsvdControl_isSelected() const;

    class h222DataPartitioning {
      public:
        enum Id { id_ = 9 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h222DataPartitioning

    h222DataPartitioning::const_reference get_h222DataPartitioning () const;
    h222DataPartitioning::reference ref_h222DataPartitioning (); 
    h222DataPartitioning::reference select_h222DataPartitioning (); 
    h222DataPartitioning::reference select_h222DataPartitioning (h222DataPartitioning::const_reference value); 
    bool h222DataPartitioning_isSelected() const;

    class t30fax {
      public:
        enum Id { id_ = 10 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t30fax

    t30fax::const_reference get_t30fax () const;
    t30fax::reference ref_t30fax (); 
    t30fax::reference select_t30fax (); 
    t30fax::reference select_t30fax (t30fax::const_reference value); 
    bool t30fax_isSelected() const;

    class t140 {
      public:
        enum Id { id_ = 11 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t140

    t140::const_reference get_t140 () const;
    t140::reference ref_t140 (); 
    t140::reference select_t140 (); 
    t140::reference select_t140 (t140::const_reference value); 
    bool t140_isSelected() const;

    class t38fax {
      public:
        enum Id { id_ = 12 };
        typedef DataApplicationCapability_application_t38fax value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38fax

    t38fax::const_reference get_t38fax () const;
    t38fax::reference ref_t38fax (); 
    t38fax::reference select_t38fax (); 
    t38fax::reference select_t38fax (t38fax::const_reference value); 
    bool t38fax_isSelected() const;

    class genericDataCapability {
      public:
        enum Id { id_ = 13 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericDataCapability

    genericDataCapability::const_reference get_genericDataCapability () const;
    genericDataCapability::reference ref_genericDataCapability (); 
    genericDataCapability::reference select_genericDataCapability (); 
    genericDataCapability::reference select_genericDataCapability (genericDataCapability::const_reference value); 
    bool genericDataCapability_isSelected() const;

    DataApplicationCapability_application(nonStandard::Id id, nonStandard::const_reference value);
    DataApplicationCapability_application(t120::Id id, t120::const_reference value);
    DataApplicationCapability_application(dsm_cc::Id id, dsm_cc::const_reference value);
    DataApplicationCapability_application(userData::Id id, userData::const_reference value);
    DataApplicationCapability_application(t84::Id id, t84::const_reference value);
    DataApplicationCapability_application(t434::Id id, t434::const_reference value);
    DataApplicationCapability_application(h224::Id id, h224::const_reference value);
    DataApplicationCapability_application(nlpid::Id id, nlpid::const_reference value);
    DataApplicationCapability_application(dsvdControl::Id id, dsvdControl::const_reference value);
    DataApplicationCapability_application(h222DataPartitioning::Id id, h222DataPartitioning::const_reference value);
    DataApplicationCapability_application(t30fax::Id id, t30fax::const_reference value);
    DataApplicationCapability_application(t140::Id id, t140::const_reference value);
    DataApplicationCapability_application(t38fax::Id id, t38fax::const_reference value);
    DataApplicationCapability_application(genericDataCapability::Id id, genericDataCapability::const_reference value);
    void swap(DataApplicationCapability_application & other);
    DataApplicationCapability_application(const DataApplicationCapability_application & other)
    : Inherited(other) {} 

    DataApplicationCapability_application & operator = (const DataApplicationCapability_application & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DataApplicationCapability_application * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[14];
    static const char* selectionNames[14];
};

//
// RedundancyEncodingMode_secondaryEncoding
//

class RedundancyEncodingMode_secondaryEncoding : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingMode_secondaryEncoding(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingMode_secondaryEncoding() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class audioData {
      public:
        enum Id { id_ = 1 };
        typedef AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioData

    audioData::const_reference get_audioData () const;
    audioData::reference ref_audioData (); 
    audioData::reference select_audioData (); 
    audioData::reference select_audioData (audioData::const_reference value); 
    bool audioData_isSelected() const;

    RedundancyEncodingMode_secondaryEncoding(nonStandard::Id id, nonStandard::const_reference value);
    RedundancyEncodingMode_secondaryEncoding(audioData::Id id, audioData::const_reference value);
    void swap(RedundancyEncodingMode_secondaryEncoding & other);
    RedundancyEncodingMode_secondaryEncoding(const RedundancyEncodingMode_secondaryEncoding & other)
    : Inherited(other) {} 

    RedundancyEncodingMode_secondaryEncoding & operator = (const RedundancyEncodingMode_secondaryEncoding & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RedundancyEncodingMode_secondaryEncoding * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// DataMode_application
//

class DataMode_application : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataMode_application(const void* info) : Inherited(info) {}
  public:
    DataMode_application() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class t120 {
      public:
        enum Id { id_ = 1 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t120

    t120::const_reference get_t120 () const;
    t120::reference ref_t120 (); 
    t120::reference select_t120 (); 
    t120::reference select_t120 (t120::const_reference value); 
    bool t120_isSelected() const;

    class dsm_cc {
      public:
        enum Id { id_ = 2 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dsm_cc

    dsm_cc::const_reference get_dsm_cc () const;
    dsm_cc::reference ref_dsm_cc (); 
    dsm_cc::reference select_dsm_cc (); 
    dsm_cc::reference select_dsm_cc (dsm_cc::const_reference value); 
    bool dsm_cc_isSelected() const;

    class userData {
      public:
        enum Id { id_ = 3 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class userData

    userData::const_reference get_userData () const;
    userData::reference ref_userData (); 
    userData::reference select_userData (); 
    userData::reference select_userData (userData::const_reference value); 
    bool userData_isSelected() const;

    class t84 {
      public:
        enum Id { id_ = 4 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t84

    t84::const_reference get_t84 () const;
    t84::reference ref_t84 (); 
    t84::reference select_t84 (); 
    t84::reference select_t84 (t84::const_reference value); 
    bool t84_isSelected() const;

    class t434 {
      public:
        enum Id { id_ = 5 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t434

    t434::const_reference get_t434 () const;
    t434::reference ref_t434 (); 
    t434::reference select_t434 (); 
    t434::reference select_t434 (t434::const_reference value); 
    bool t434_isSelected() const;

    class h224 {
      public:
        enum Id { id_ = 6 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h224

    h224::const_reference get_h224 () const;
    h224::reference ref_h224 (); 
    h224::reference select_h224 (); 
    h224::reference select_h224 (h224::const_reference value); 
    bool h224_isSelected() const;

    class nlpid {
      public:
        enum Id { id_ = 7 };
        typedef DataMode_application_nlpid value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nlpid

    nlpid::const_reference get_nlpid () const;
    nlpid::reference ref_nlpid (); 
    nlpid::reference select_nlpid (); 
    nlpid::reference select_nlpid (nlpid::const_reference value); 
    bool nlpid_isSelected() const;

    class dsvdControl {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dsvdControl

    dsvdControl::reference select_dsvdControl (); 
    bool dsvdControl_isSelected() const;

    class h222DataPartitioning {
      public:
        enum Id { id_ = 9 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h222DataPartitioning

    h222DataPartitioning::const_reference get_h222DataPartitioning () const;
    h222DataPartitioning::reference ref_h222DataPartitioning (); 
    h222DataPartitioning::reference select_h222DataPartitioning (); 
    h222DataPartitioning::reference select_h222DataPartitioning (h222DataPartitioning::const_reference value); 
    bool h222DataPartitioning_isSelected() const;

    class t30fax {
      public:
        enum Id { id_ = 10 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t30fax

    t30fax::const_reference get_t30fax () const;
    t30fax::reference ref_t30fax (); 
    t30fax::reference select_t30fax (); 
    t30fax::reference select_t30fax (t30fax::const_reference value); 
    bool t30fax_isSelected() const;

    class t140 {
      public:
        enum Id { id_ = 11 };
        typedef DataProtocolCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t140

    t140::const_reference get_t140 () const;
    t140::reference ref_t140 (); 
    t140::reference select_t140 (); 
    t140::reference select_t140 (t140::const_reference value); 
    bool t140_isSelected() const;

    class t38fax {
      public:
        enum Id { id_ = 12 };
        typedef DataMode_application_t38fax value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t38fax

    t38fax::const_reference get_t38fax () const;
    t38fax::reference ref_t38fax (); 
    t38fax::reference select_t38fax (); 
    t38fax::reference select_t38fax (t38fax::const_reference value); 
    bool t38fax_isSelected() const;

    class genericDataMode {
      public:
        enum Id { id_ = 13 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericDataMode

    genericDataMode::const_reference get_genericDataMode () const;
    genericDataMode::reference ref_genericDataMode (); 
    genericDataMode::reference select_genericDataMode (); 
    genericDataMode::reference select_genericDataMode (genericDataMode::const_reference value); 
    bool genericDataMode_isSelected() const;

    DataMode_application(nonStandard::Id id, nonStandard::const_reference value);
    DataMode_application(t120::Id id, t120::const_reference value);
    DataMode_application(dsm_cc::Id id, dsm_cc::const_reference value);
    DataMode_application(userData::Id id, userData::const_reference value);
    DataMode_application(t84::Id id, t84::const_reference value);
    DataMode_application(t434::Id id, t434::const_reference value);
    DataMode_application(h224::Id id, h224::const_reference value);
    DataMode_application(nlpid::Id id, nlpid::const_reference value);
    DataMode_application(dsvdControl::Id id, dsvdControl::const_reference value);
    DataMode_application(h222DataPartitioning::Id id, h222DataPartitioning::const_reference value);
    DataMode_application(t30fax::Id id, t30fax::const_reference value);
    DataMode_application(t140::Id id, t140::const_reference value);
    DataMode_application(t38fax::Id id, t38fax::const_reference value);
    DataMode_application(genericDataMode::Id id, genericDataMode::const_reference value);
    void swap(DataMode_application & other);
    DataMode_application(const DataMode_application & other)
    : Inherited(other) {} 

    DataMode_application & operator = (const DataMode_application & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DataMode_application * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[14];
    static const char* selectionNames[14];
};

//
// MiscellaneousCommand_type
//

class MiscellaneousCommand_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand_type(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand_type() : Inherited(&theInfo) {}
    class equaliseDelay {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class equaliseDelay

    equaliseDelay::reference select_equaliseDelay (); 
    bool equaliseDelay_isSelected() const;

    class zeroDelay {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class zeroDelay

    zeroDelay::reference select_zeroDelay (); 
    bool zeroDelay_isSelected() const;

    class multipointModeCommand {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multipointModeCommand

    multipointModeCommand::reference select_multipointModeCommand (); 
    bool multipointModeCommand_isSelected() const;

    class cancelMultipointModeCommand {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cancelMultipointModeCommand

    cancelMultipointModeCommand::reference select_cancelMultipointModeCommand (); 
    bool cancelMultipointModeCommand_isSelected() const;

    class videoFreezePicture {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoFreezePicture

    videoFreezePicture::reference select_videoFreezePicture (); 
    bool videoFreezePicture_isSelected() const;

    class videoFastUpdatePicture {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoFastUpdatePicture

    videoFastUpdatePicture::reference select_videoFastUpdatePicture (); 
    bool videoFastUpdatePicture_isSelected() const;

    class videoFastUpdateGOB {
      public:
        enum Id { id_ = 6 };
        typedef MiscellaneousCommand_type_videoFastUpdateGOB value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoFastUpdateGOB

    videoFastUpdateGOB::const_reference get_videoFastUpdateGOB () const;
    videoFastUpdateGOB::reference ref_videoFastUpdateGOB (); 
    videoFastUpdateGOB::reference select_videoFastUpdateGOB (); 
    videoFastUpdateGOB::reference select_videoFastUpdateGOB (videoFastUpdateGOB::const_reference value); 
    bool videoFastUpdateGOB_isSelected() const;

    class videoTemporalSpatialTradeOff {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 31>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoTemporalSpatialTradeOff

    videoTemporalSpatialTradeOff::const_reference get_videoTemporalSpatialTradeOff () const;
    videoTemporalSpatialTradeOff::reference ref_videoTemporalSpatialTradeOff (); 
    videoTemporalSpatialTradeOff::reference select_videoTemporalSpatialTradeOff (); 
    videoTemporalSpatialTradeOff::reference select_videoTemporalSpatialTradeOff (videoTemporalSpatialTradeOff::value_type::int_type value); 
    bool videoTemporalSpatialTradeOff_isSelected() const;

    class videoSendSyncEveryGOB {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoSendSyncEveryGOB

    videoSendSyncEveryGOB::reference select_videoSendSyncEveryGOB (); 
    bool videoSendSyncEveryGOB_isSelected() const;

    class videoSendSyncEveryGOBCancel {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoSendSyncEveryGOBCancel

    videoSendSyncEveryGOBCancel::reference select_videoSendSyncEveryGOBCancel (); 
    bool videoSendSyncEveryGOBCancel_isSelected() const;

    class videoFastUpdateMB {
      public:
        enum Id { id_ = 10 };
        typedef MiscellaneousCommand_type_videoFastUpdateMB value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoFastUpdateMB

    videoFastUpdateMB::const_reference get_videoFastUpdateMB () const;
    videoFastUpdateMB::reference ref_videoFastUpdateMB (); 
    videoFastUpdateMB::reference select_videoFastUpdateMB (); 
    videoFastUpdateMB::reference select_videoFastUpdateMB (videoFastUpdateMB::const_reference value); 
    bool videoFastUpdateMB_isSelected() const;

    class maxH223MUXPDUsize {
      public:
        enum Id { id_ = 11 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxH223MUXPDUsize

    maxH223MUXPDUsize::const_reference get_maxH223MUXPDUsize () const;
    maxH223MUXPDUsize::reference ref_maxH223MUXPDUsize (); 
    maxH223MUXPDUsize::reference select_maxH223MUXPDUsize (); 
    maxH223MUXPDUsize::reference select_maxH223MUXPDUsize (maxH223MUXPDUsize::value_type::int_type value); 
    bool maxH223MUXPDUsize_isSelected() const;

    class encryptionUpdate {
      public:
        enum Id { id_ = 12 };
        typedef EncryptionSync value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionUpdate

    encryptionUpdate::const_reference get_encryptionUpdate () const;
    encryptionUpdate::reference ref_encryptionUpdate (); 
    encryptionUpdate::reference select_encryptionUpdate (); 
    encryptionUpdate::reference select_encryptionUpdate (encryptionUpdate::const_reference value); 
    bool encryptionUpdate_isSelected() const;

    class encryptionUpdateRequest {
      public:
        enum Id { id_ = 13 };
        typedef EncryptionUpdateRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionUpdateRequest

    encryptionUpdateRequest::const_reference get_encryptionUpdateRequest () const;
    encryptionUpdateRequest::reference ref_encryptionUpdateRequest (); 
    encryptionUpdateRequest::reference select_encryptionUpdateRequest (); 
    encryptionUpdateRequest::reference select_encryptionUpdateRequest (encryptionUpdateRequest::const_reference value); 
    bool encryptionUpdateRequest_isSelected() const;

    class switchReceiveMediaOff {
      public:
        enum Id { id_ = 14 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class switchReceiveMediaOff

    switchReceiveMediaOff::reference select_switchReceiveMediaOff (); 
    bool switchReceiveMediaOff_isSelected() const;

    class switchReceiveMediaOn {
      public:
        enum Id { id_ = 15 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class switchReceiveMediaOn

    switchReceiveMediaOn::reference select_switchReceiveMediaOn (); 
    bool switchReceiveMediaOn_isSelected() const;

    class progressiveRefinementStart {
      public:
        enum Id { id_ = 16 };
        typedef MiscellaneousCommand_type_progressiveRefinementStart value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class progressiveRefinementStart

    progressiveRefinementStart::const_reference get_progressiveRefinementStart () const;
    progressiveRefinementStart::reference ref_progressiveRefinementStart (); 
    progressiveRefinementStart::reference select_progressiveRefinementStart (); 
    progressiveRefinementStart::reference select_progressiveRefinementStart (progressiveRefinementStart::const_reference value); 
    bool progressiveRefinementStart_isSelected() const;

    class progressiveRefinementAbortOne {
      public:
        enum Id { id_ = 17 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class progressiveRefinementAbortOne

    progressiveRefinementAbortOne::reference select_progressiveRefinementAbortOne (); 
    bool progressiveRefinementAbortOne_isSelected() const;

    class progressiveRefinementAbortContinuous {
      public:
        enum Id { id_ = 18 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class progressiveRefinementAbortContinuous

    progressiveRefinementAbortContinuous::reference select_progressiveRefinementAbortContinuous (); 
    bool progressiveRefinementAbortContinuous_isSelected() const;

    class videoBadMBs {
      public:
        enum Id { id_ = 19 };
        typedef MiscellaneousCommand_type_videoBadMBs value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoBadMBs

    videoBadMBs::const_reference get_videoBadMBs () const;
    videoBadMBs::reference ref_videoBadMBs (); 
    videoBadMBs::reference select_videoBadMBs (); 
    videoBadMBs::reference select_videoBadMBs (videoBadMBs::const_reference value); 
    bool videoBadMBs_isSelected() const;

    class lostPicture {
      public:
        enum Id { id_ = 20 };
        typedef ASN1::SEQUENCE_OF<PictureReference>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lostPicture

    lostPicture::const_reference get_lostPicture () const;
    lostPicture::reference ref_lostPicture (); 
    lostPicture::reference select_lostPicture (); 
    lostPicture::reference select_lostPicture (lostPicture::const_reference value); 
    bool lostPicture_isSelected() const;

    class lostPartialPicture {
      public:
        enum Id { id_ = 21 };
        typedef MiscellaneousCommand_type_lostPartialPicture value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class lostPartialPicture

    lostPartialPicture::const_reference get_lostPartialPicture () const;
    lostPartialPicture::reference ref_lostPartialPicture (); 
    lostPartialPicture::reference select_lostPartialPicture (); 
    lostPartialPicture::reference select_lostPartialPicture (lostPartialPicture::const_reference value); 
    bool lostPartialPicture_isSelected() const;

    class recoveryReferencePicture {
      public:
        enum Id { id_ = 22 };
        typedef ASN1::SEQUENCE_OF<PictureReference>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class recoveryReferencePicture

    recoveryReferencePicture::const_reference get_recoveryReferencePicture () const;
    recoveryReferencePicture::reference ref_recoveryReferencePicture (); 
    recoveryReferencePicture::reference select_recoveryReferencePicture (); 
    recoveryReferencePicture::reference select_recoveryReferencePicture (recoveryReferencePicture::const_reference value); 
    bool recoveryReferencePicture_isSelected() const;

    class encryptionUpdateCommand {
      public:
        enum Id { id_ = 23 };
        typedef MiscellaneousCommand_type_encryptionUpdateCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionUpdateCommand

    encryptionUpdateCommand::const_reference get_encryptionUpdateCommand () const;
    encryptionUpdateCommand::reference ref_encryptionUpdateCommand (); 
    encryptionUpdateCommand::reference select_encryptionUpdateCommand (); 
    encryptionUpdateCommand::reference select_encryptionUpdateCommand (encryptionUpdateCommand::const_reference value); 
    bool encryptionUpdateCommand_isSelected() const;

    class encryptionUpdateAck {
      public:
        enum Id { id_ = 24 };
        typedef MiscellaneousCommand_type_encryptionUpdateAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionUpdateAck

    encryptionUpdateAck::const_reference get_encryptionUpdateAck () const;
    encryptionUpdateAck::reference ref_encryptionUpdateAck (); 
    encryptionUpdateAck::reference select_encryptionUpdateAck (); 
    encryptionUpdateAck::reference select_encryptionUpdateAck (encryptionUpdateAck::const_reference value); 
    bool encryptionUpdateAck_isSelected() const;

    MiscellaneousCommand_type(equaliseDelay::Id id, equaliseDelay::const_reference value);
    MiscellaneousCommand_type(zeroDelay::Id id, zeroDelay::const_reference value);
    MiscellaneousCommand_type(multipointModeCommand::Id id, multipointModeCommand::const_reference value);
    MiscellaneousCommand_type(cancelMultipointModeCommand::Id id, cancelMultipointModeCommand::const_reference value);
    MiscellaneousCommand_type(videoFreezePicture::Id id, videoFreezePicture::const_reference value);
    MiscellaneousCommand_type(videoFastUpdatePicture::Id id, videoFastUpdatePicture::const_reference value);
    MiscellaneousCommand_type(videoFastUpdateGOB::Id id, videoFastUpdateGOB::const_reference value);
    MiscellaneousCommand_type(videoTemporalSpatialTradeOff::Id id, videoTemporalSpatialTradeOff::value_type::int_type value);
    MiscellaneousCommand_type(videoSendSyncEveryGOB::Id id, videoSendSyncEveryGOB::const_reference value);
    MiscellaneousCommand_type(videoSendSyncEveryGOBCancel::Id id, videoSendSyncEveryGOBCancel::const_reference value);
    MiscellaneousCommand_type(videoFastUpdateMB::Id id, videoFastUpdateMB::const_reference value);
    MiscellaneousCommand_type(maxH223MUXPDUsize::Id id, maxH223MUXPDUsize::value_type::int_type value);
    MiscellaneousCommand_type(encryptionUpdate::Id id, encryptionUpdate::const_reference value);
    MiscellaneousCommand_type(encryptionUpdateRequest::Id id, encryptionUpdateRequest::const_reference value);
    MiscellaneousCommand_type(switchReceiveMediaOff::Id id, switchReceiveMediaOff::const_reference value);
    MiscellaneousCommand_type(switchReceiveMediaOn::Id id, switchReceiveMediaOn::const_reference value);
    MiscellaneousCommand_type(progressiveRefinementStart::Id id, progressiveRefinementStart::const_reference value);
    MiscellaneousCommand_type(progressiveRefinementAbortOne::Id id, progressiveRefinementAbortOne::const_reference value);
    MiscellaneousCommand_type(progressiveRefinementAbortContinuous::Id id, progressiveRefinementAbortContinuous::const_reference value);
    MiscellaneousCommand_type(videoBadMBs::Id id, videoBadMBs::const_reference value);
    MiscellaneousCommand_type(lostPicture::Id id, lostPicture::const_reference value);
    MiscellaneousCommand_type(lostPartialPicture::Id id, lostPartialPicture::const_reference value);
    MiscellaneousCommand_type(recoveryReferencePicture::Id id, recoveryReferencePicture::const_reference value);
    MiscellaneousCommand_type(encryptionUpdateCommand::Id id, encryptionUpdateCommand::const_reference value);
    MiscellaneousCommand_type(encryptionUpdateAck::Id id, encryptionUpdateAck::const_reference value);
    void swap(MiscellaneousCommand_type & other);
    MiscellaneousCommand_type(const MiscellaneousCommand_type & other)
    : Inherited(other) {} 

    MiscellaneousCommand_type & operator = (const MiscellaneousCommand_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MiscellaneousCommand_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[25];
    static const char* selectionNames[25];
};

//
// OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters
//

class OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters() : Inherited(&theInfo) {}
    class h222LogicalChannelParameters {
      public:
        enum Id { id_ = 0 };
        typedef H222LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h222LogicalChannelParameters

    h222LogicalChannelParameters::const_reference get_h222LogicalChannelParameters () const;
    h222LogicalChannelParameters::reference ref_h222LogicalChannelParameters (); 
    h222LogicalChannelParameters::reference select_h222LogicalChannelParameters (); 
    h222LogicalChannelParameters::reference select_h222LogicalChannelParameters (h222LogicalChannelParameters::const_reference value); 
    bool h222LogicalChannelParameters_isSelected() const;

    class h223LogicalChannelParameters {
      public:
        enum Id { id_ = 1 };
        typedef H223LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223LogicalChannelParameters

    h223LogicalChannelParameters::const_reference get_h223LogicalChannelParameters () const;
    h223LogicalChannelParameters::reference ref_h223LogicalChannelParameters (); 
    h223LogicalChannelParameters::reference select_h223LogicalChannelParameters (); 
    h223LogicalChannelParameters::reference select_h223LogicalChannelParameters (h223LogicalChannelParameters::const_reference value); 
    bool h223LogicalChannelParameters_isSelected() const;

    class v76LogicalChannelParameters {
      public:
        enum Id { id_ = 2 };
        typedef V76LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v76LogicalChannelParameters

    v76LogicalChannelParameters::const_reference get_v76LogicalChannelParameters () const;
    v76LogicalChannelParameters::reference ref_v76LogicalChannelParameters (); 
    v76LogicalChannelParameters::reference select_v76LogicalChannelParameters (); 
    v76LogicalChannelParameters::reference select_v76LogicalChannelParameters (v76LogicalChannelParameters::const_reference value); 
    bool v76LogicalChannelParameters_isSelected() const;

    class h2250LogicalChannelParameters {
      public:
        enum Id { id_ = 3 };
        typedef H2250LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250LogicalChannelParameters

    h2250LogicalChannelParameters::const_reference get_h2250LogicalChannelParameters () const;
    h2250LogicalChannelParameters::reference ref_h2250LogicalChannelParameters (); 
    h2250LogicalChannelParameters::reference select_h2250LogicalChannelParameters (); 
    h2250LogicalChannelParameters::reference select_h2250LogicalChannelParameters (h2250LogicalChannelParameters::const_reference value); 
    bool h2250LogicalChannelParameters_isSelected() const;

    class none {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class none

    none::reference select_none (); 
    bool none_isSelected() const;

    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(h222LogicalChannelParameters::Id id, h222LogicalChannelParameters::const_reference value);
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(h223LogicalChannelParameters::Id id, h223LogicalChannelParameters::const_reference value);
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(v76LogicalChannelParameters::Id id, v76LogicalChannelParameters::const_reference value);
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(h2250LogicalChannelParameters::Id id, h2250LogicalChannelParameters::const_reference value);
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(none::Id id, none::const_reference value);
    void swap(OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters & other);
    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters(const OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters & other)
    : Inherited(other) {} 

    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters & operator = (const OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters
//

class OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters() : Inherited(&theInfo) {}
    class h223LogicalChannelParameters {
      public:
        enum Id { id_ = 0 };
        typedef H223LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223LogicalChannelParameters

    h223LogicalChannelParameters::const_reference get_h223LogicalChannelParameters () const;
    h223LogicalChannelParameters::reference ref_h223LogicalChannelParameters (); 
    h223LogicalChannelParameters::reference select_h223LogicalChannelParameters (); 
    h223LogicalChannelParameters::reference select_h223LogicalChannelParameters (h223LogicalChannelParameters::const_reference value); 
    bool h223LogicalChannelParameters_isSelected() const;

    class v76LogicalChannelParameters {
      public:
        enum Id { id_ = 1 };
        typedef V76LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v76LogicalChannelParameters

    v76LogicalChannelParameters::const_reference get_v76LogicalChannelParameters () const;
    v76LogicalChannelParameters::reference ref_v76LogicalChannelParameters (); 
    v76LogicalChannelParameters::reference select_v76LogicalChannelParameters (); 
    v76LogicalChannelParameters::reference select_v76LogicalChannelParameters (v76LogicalChannelParameters::const_reference value); 
    bool v76LogicalChannelParameters_isSelected() const;

    class h2250LogicalChannelParameters {
      public:
        enum Id { id_ = 2 };
        typedef H2250LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250LogicalChannelParameters

    h2250LogicalChannelParameters::const_reference get_h2250LogicalChannelParameters () const;
    h2250LogicalChannelParameters::reference ref_h2250LogicalChannelParameters (); 
    h2250LogicalChannelParameters::reference select_h2250LogicalChannelParameters (); 
    h2250LogicalChannelParameters::reference select_h2250LogicalChannelParameters (h2250LogicalChannelParameters::const_reference value); 
    bool h2250LogicalChannelParameters_isSelected() const;

    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(h223LogicalChannelParameters::Id id, h223LogicalChannelParameters::const_reference value);
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(v76LogicalChannelParameters::Id id, v76LogicalChannelParameters::const_reference value);
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(h2250LogicalChannelParameters::Id id, h2250LogicalChannelParameters::const_reference value);
    void swap(OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters & other);
    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters(const OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters & other)
    : Inherited(other) {} 

    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters & operator = (const OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters
//

class OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters() : Inherited(&theInfo) {}
    class h222LogicalChannelParameters {
      public:
        enum Id { id_ = 0 };
        typedef H222LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h222LogicalChannelParameters

    h222LogicalChannelParameters::const_reference get_h222LogicalChannelParameters () const;
    h222LogicalChannelParameters::reference ref_h222LogicalChannelParameters (); 
    h222LogicalChannelParameters::reference select_h222LogicalChannelParameters (); 
    h222LogicalChannelParameters::reference select_h222LogicalChannelParameters (h222LogicalChannelParameters::const_reference value); 
    bool h222LogicalChannelParameters_isSelected() const;

    class h2250LogicalChannelParameters {
      public:
        enum Id { id_ = 1 };
        typedef H2250LogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250LogicalChannelParameters

    h2250LogicalChannelParameters::const_reference get_h2250LogicalChannelParameters () const;
    h2250LogicalChannelParameters::reference ref_h2250LogicalChannelParameters (); 
    h2250LogicalChannelParameters::reference select_h2250LogicalChannelParameters (); 
    h2250LogicalChannelParameters::reference select_h2250LogicalChannelParameters (h2250LogicalChannelParameters::const_reference value); 
    bool h2250LogicalChannelParameters_isSelected() const;

    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(h222LogicalChannelParameters::Id id, h222LogicalChannelParameters::const_reference value);
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(h2250LogicalChannelParameters::Id id, h2250LogicalChannelParameters::const_reference value);
    void swap(OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters & other);
    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters(const OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters & other)
    : Inherited(other) {} 

    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters & operator = (const OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[2];
    static const char* selectionNames[2];
};

//
// EnhancementOptions
//

class EnhancementOptions : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EnhancementOptions(const void* info) : Inherited(info) {}
  public:
    EnhancementOptions() : Inherited(&theInfo) {}
    EnhancementOptions(const EnhancementOptions & other) : Inherited(other)
    {}
    EnhancementOptions& operator = (const EnhancementOptions& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_sqcifMPI,
      e_qcifMPI,
      e_cifMPI,
      e_cif4MPI,
      e_cif16MPI,
      e_slowSqcifMPI,
      e_slowQcifMPI,
      e_slowCifMPI,
      e_slowCif4MPI,
      e_slowCif16MPI,
      e_h263Options
    };

    class sqcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sqcifMPI
    sqcifMPI::const_reference get_sqcifMPI () const;
    sqcifMPI::reference ref_sqcifMPI ();
    sqcifMPI::reference set_sqcifMPI ();
    sqcifMPI::reference set_sqcifMPI (sqcifMPI::value_type::int_type value);
    void omit_sqcifMPI ();
    bool sqcifMPI_isPresent () const;
    class qcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcifMPI
    qcifMPI::const_reference get_qcifMPI () const;
    qcifMPI::reference ref_qcifMPI ();
    qcifMPI::reference set_qcifMPI ();
    qcifMPI::reference set_qcifMPI (qcifMPI::value_type::int_type value);
    void omit_qcifMPI ();
    bool qcifMPI_isPresent () const;
    class cifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cifMPI
    cifMPI::const_reference get_cifMPI () const;
    cifMPI::reference ref_cifMPI ();
    cifMPI::reference set_cifMPI ();
    cifMPI::reference set_cifMPI (cifMPI::value_type::int_type value);
    void omit_cifMPI ();
    bool cifMPI_isPresent () const;
    class cif4MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif4MPI
    cif4MPI::const_reference get_cif4MPI () const;
    cif4MPI::reference ref_cif4MPI ();
    cif4MPI::reference set_cif4MPI ();
    cif4MPI::reference set_cif4MPI (cif4MPI::value_type::int_type value);
    void omit_cif4MPI ();
    bool cif4MPI_isPresent () const;
    class cif16MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif16MPI
    cif16MPI::const_reference get_cif16MPI () const;
    cif16MPI::reference ref_cif16MPI ();
    cif16MPI::reference set_cif16MPI ();
    cif16MPI::reference set_cif16MPI (cif16MPI::value_type::int_type value);
    void omit_cif16MPI ();
    bool cif16MPI_isPresent () const;
    class maxBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 192400>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxBitRate
    maxBitRate::const_reference get_maxBitRate () const;
    maxBitRate::reference ref_maxBitRate ();
    maxBitRate::reference set_maxBitRate ();
    maxBitRate::reference set_maxBitRate (maxBitRate::value_type::int_type value);
    class unrestrictedVector {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unrestrictedVector
    unrestrictedVector::const_reference get_unrestrictedVector () const;
    unrestrictedVector::reference ref_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector (bool value);
    class arithmeticCoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class arithmeticCoding
    arithmeticCoding::const_reference get_arithmeticCoding () const;
    arithmeticCoding::reference ref_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding (bool value);
    class temporalSpatialTradeOffCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class temporalSpatialTradeOffCapability
    temporalSpatialTradeOffCapability::const_reference get_temporalSpatialTradeOffCapability () const;
    temporalSpatialTradeOffCapability::reference ref_temporalSpatialTradeOffCapability ();
    temporalSpatialTradeOffCapability::reference set_temporalSpatialTradeOffCapability ();
    temporalSpatialTradeOffCapability::reference set_temporalSpatialTradeOffCapability (bool value);
    class slowSqcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowSqcifMPI
    slowSqcifMPI::const_reference get_slowSqcifMPI () const;
    slowSqcifMPI::reference ref_slowSqcifMPI ();
    slowSqcifMPI::reference set_slowSqcifMPI ();
    slowSqcifMPI::reference set_slowSqcifMPI (slowSqcifMPI::value_type::int_type value);
    void omit_slowSqcifMPI ();
    bool slowSqcifMPI_isPresent () const;
    class slowQcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowQcifMPI
    slowQcifMPI::const_reference get_slowQcifMPI () const;
    slowQcifMPI::reference ref_slowQcifMPI ();
    slowQcifMPI::reference set_slowQcifMPI ();
    slowQcifMPI::reference set_slowQcifMPI (slowQcifMPI::value_type::int_type value);
    void omit_slowQcifMPI ();
    bool slowQcifMPI_isPresent () const;
    class slowCifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowCifMPI
    slowCifMPI::const_reference get_slowCifMPI () const;
    slowCifMPI::reference ref_slowCifMPI ();
    slowCifMPI::reference set_slowCifMPI ();
    slowCifMPI::reference set_slowCifMPI (slowCifMPI::value_type::int_type value);
    void omit_slowCifMPI ();
    bool slowCifMPI_isPresent () const;
    class slowCif4MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowCif4MPI
    slowCif4MPI::const_reference get_slowCif4MPI () const;
    slowCif4MPI::reference ref_slowCif4MPI ();
    slowCif4MPI::reference set_slowCif4MPI ();
    slowCif4MPI::reference set_slowCif4MPI (slowCif4MPI::value_type::int_type value);
    void omit_slowCif4MPI ();
    bool slowCif4MPI_isPresent () const;
    class slowCif16MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowCif16MPI
    slowCif16MPI::const_reference get_slowCif16MPI () const;
    slowCif16MPI::reference ref_slowCif16MPI ();
    slowCif16MPI::reference set_slowCif16MPI ();
    slowCif16MPI::reference set_slowCif16MPI (slowCif16MPI::value_type::int_type value);
    void omit_slowCif16MPI ();
    bool slowCif16MPI_isPresent () const;
    class errorCompensation {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCompensation
    errorCompensation::const_reference get_errorCompensation () const;
    errorCompensation::reference ref_errorCompensation ();
    errorCompensation::reference set_errorCompensation ();
    errorCompensation::reference set_errorCompensation (bool value);
    class h263Options {
      public:
        typedef H263Options value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263Options
    h263Options::const_reference get_h263Options () const;
    h263Options::reference ref_h263Options ();
    h263Options::reference set_h263Options ();
    h263Options::reference set_h263Options (h263Options::const_reference value);
    void omit_h263Options ();
    bool h263Options_isPresent () const;
    void swap(EnhancementOptions& other);
    EnhancementOptions * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[16];
    static int fieldIds[16];
    static const char* fieldNames[16];
};

//
// AudioCapability
//

class AudioCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    AudioCapability(const void* info) : Inherited(info) {}
  public:
    AudioCapability() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class g711Alaw64k {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Alaw64k

    g711Alaw64k::const_reference get_g711Alaw64k () const;
    g711Alaw64k::reference ref_g711Alaw64k (); 
    g711Alaw64k::reference select_g711Alaw64k (); 
    g711Alaw64k::reference select_g711Alaw64k (g711Alaw64k::value_type::int_type value); 
    bool g711Alaw64k_isSelected() const;

    class g711Alaw56k {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Alaw56k

    g711Alaw56k::const_reference get_g711Alaw56k () const;
    g711Alaw56k::reference ref_g711Alaw56k (); 
    g711Alaw56k::reference select_g711Alaw56k (); 
    g711Alaw56k::reference select_g711Alaw56k (g711Alaw56k::value_type::int_type value); 
    bool g711Alaw56k_isSelected() const;

    class g711Ulaw64k {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Ulaw64k

    g711Ulaw64k::const_reference get_g711Ulaw64k () const;
    g711Ulaw64k::reference ref_g711Ulaw64k (); 
    g711Ulaw64k::reference select_g711Ulaw64k (); 
    g711Ulaw64k::reference select_g711Ulaw64k (g711Ulaw64k::value_type::int_type value); 
    bool g711Ulaw64k_isSelected() const;

    class g711Ulaw56k {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g711Ulaw56k

    g711Ulaw56k::const_reference get_g711Ulaw56k () const;
    g711Ulaw56k::reference ref_g711Ulaw56k (); 
    g711Ulaw56k::reference select_g711Ulaw56k (); 
    g711Ulaw56k::reference select_g711Ulaw56k (g711Ulaw56k::value_type::int_type value); 
    bool g711Ulaw56k_isSelected() const;

    class g722_64k {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g722_64k

    g722_64k::const_reference get_g722_64k () const;
    g722_64k::reference ref_g722_64k (); 
    g722_64k::reference select_g722_64k (); 
    g722_64k::reference select_g722_64k (g722_64k::value_type::int_type value); 
    bool g722_64k_isSelected() const;

    class g722_56k {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g722_56k

    g722_56k::const_reference get_g722_56k () const;
    g722_56k::reference ref_g722_56k (); 
    g722_56k::reference select_g722_56k (); 
    g722_56k::reference select_g722_56k (g722_56k::value_type::int_type value); 
    bool g722_56k_isSelected() const;

    class g722_48k {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g722_48k

    g722_48k::const_reference get_g722_48k () const;
    g722_48k::reference ref_g722_48k (); 
    g722_48k::reference select_g722_48k (); 
    g722_48k::reference select_g722_48k (g722_48k::value_type::int_type value); 
    bool g722_48k_isSelected() const;

    class g7231 {
      public:
        enum Id { id_ = 8 };
        typedef AudioCapability_g7231 value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g7231

    g7231::const_reference get_g7231 () const;
    g7231::reference ref_g7231 (); 
    g7231::reference select_g7231 (); 
    g7231::reference select_g7231 (g7231::const_reference value); 
    bool g7231_isSelected() const;

    class g728 {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g728

    g728::const_reference get_g728 () const;
    g728::reference ref_g728 (); 
    g728::reference select_g728 (); 
    g728::reference select_g728 (g728::value_type::int_type value); 
    bool g728_isSelected() const;

    class g729 {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729

    g729::const_reference get_g729 () const;
    g729::reference ref_g729 (); 
    g729::reference select_g729 (); 
    g729::reference select_g729 (g729::value_type::int_type value); 
    bool g729_isSelected() const;

    class g729AnnexA {
      public:
        enum Id { id_ = 11 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729AnnexA

    g729AnnexA::const_reference get_g729AnnexA () const;
    g729AnnexA::reference ref_g729AnnexA (); 
    g729AnnexA::reference select_g729AnnexA (); 
    g729AnnexA::reference select_g729AnnexA (g729AnnexA::value_type::int_type value); 
    bool g729AnnexA_isSelected() const;

    class is11172AudioCapability {
      public:
        enum Id { id_ = 12 };
        typedef IS11172AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class is11172AudioCapability

    is11172AudioCapability::const_reference get_is11172AudioCapability () const;
    is11172AudioCapability::reference ref_is11172AudioCapability (); 
    is11172AudioCapability::reference select_is11172AudioCapability (); 
    is11172AudioCapability::reference select_is11172AudioCapability (is11172AudioCapability::const_reference value); 
    bool is11172AudioCapability_isSelected() const;

    class is13818AudioCapability {
      public:
        enum Id { id_ = 13 };
        typedef IS13818AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class is13818AudioCapability

    is13818AudioCapability::const_reference get_is13818AudioCapability () const;
    is13818AudioCapability::reference ref_is13818AudioCapability (); 
    is13818AudioCapability::reference select_is13818AudioCapability (); 
    is13818AudioCapability::reference select_is13818AudioCapability (is13818AudioCapability::const_reference value); 
    bool is13818AudioCapability_isSelected() const;

    class g729wAnnexB {
      public:
        enum Id { id_ = 14 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729wAnnexB

    g729wAnnexB::const_reference get_g729wAnnexB () const;
    g729wAnnexB::reference ref_g729wAnnexB (); 
    g729wAnnexB::reference select_g729wAnnexB (); 
    g729wAnnexB::reference select_g729wAnnexB (g729wAnnexB::value_type::int_type value); 
    bool g729wAnnexB_isSelected() const;

    class g729AnnexAwAnnexB {
      public:
        enum Id { id_ = 15 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 256>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729AnnexAwAnnexB

    g729AnnexAwAnnexB::const_reference get_g729AnnexAwAnnexB () const;
    g729AnnexAwAnnexB::reference ref_g729AnnexAwAnnexB (); 
    g729AnnexAwAnnexB::reference select_g729AnnexAwAnnexB (); 
    g729AnnexAwAnnexB::reference select_g729AnnexAwAnnexB (g729AnnexAwAnnexB::value_type::int_type value); 
    bool g729AnnexAwAnnexB_isSelected() const;

    class g7231AnnexCCapability {
      public:
        enum Id { id_ = 16 };
        typedef G7231AnnexCCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g7231AnnexCCapability

    g7231AnnexCCapability::const_reference get_g7231AnnexCCapability () const;
    g7231AnnexCCapability::reference ref_g7231AnnexCCapability (); 
    g7231AnnexCCapability::reference select_g7231AnnexCCapability (); 
    g7231AnnexCCapability::reference select_g7231AnnexCCapability (g7231AnnexCCapability::const_reference value); 
    bool g7231AnnexCCapability_isSelected() const;

    class gsmFullRate {
      public:
        enum Id { id_ = 17 };
        typedef GSMAudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gsmFullRate

    gsmFullRate::const_reference get_gsmFullRate () const;
    gsmFullRate::reference ref_gsmFullRate (); 
    gsmFullRate::reference select_gsmFullRate (); 
    gsmFullRate::reference select_gsmFullRate (gsmFullRate::const_reference value); 
    bool gsmFullRate_isSelected() const;

    class gsmHalfRate {
      public:
        enum Id { id_ = 18 };
        typedef GSMAudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gsmHalfRate

    gsmHalfRate::const_reference get_gsmHalfRate () const;
    gsmHalfRate::reference ref_gsmHalfRate (); 
    gsmHalfRate::reference select_gsmHalfRate (); 
    gsmHalfRate::reference select_gsmHalfRate (gsmHalfRate::const_reference value); 
    bool gsmHalfRate_isSelected() const;

    class gsmEnhancedFullRate {
      public:
        enum Id { id_ = 19 };
        typedef GSMAudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class gsmEnhancedFullRate

    gsmEnhancedFullRate::const_reference get_gsmEnhancedFullRate () const;
    gsmEnhancedFullRate::reference ref_gsmEnhancedFullRate (); 
    gsmEnhancedFullRate::reference select_gsmEnhancedFullRate (); 
    gsmEnhancedFullRate::reference select_gsmEnhancedFullRate (gsmEnhancedFullRate::const_reference value); 
    bool gsmEnhancedFullRate_isSelected() const;

    class genericAudioCapability {
      public:
        enum Id { id_ = 20 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericAudioCapability

    genericAudioCapability::const_reference get_genericAudioCapability () const;
    genericAudioCapability::reference ref_genericAudioCapability (); 
    genericAudioCapability::reference select_genericAudioCapability (); 
    genericAudioCapability::reference select_genericAudioCapability (genericAudioCapability::const_reference value); 
    bool genericAudioCapability_isSelected() const;

    class g729Extensions {
      public:
        enum Id { id_ = 21 };
        typedef G729Extensions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class g729Extensions

    g729Extensions::const_reference get_g729Extensions () const;
    g729Extensions::reference ref_g729Extensions (); 
    g729Extensions::reference select_g729Extensions (); 
    g729Extensions::reference select_g729Extensions (g729Extensions::const_reference value); 
    bool g729Extensions_isSelected() const;

    class vbd {
      public:
        enum Id { id_ = 22 };
        typedef VBDCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vbd

    vbd::const_reference get_vbd () const;
    vbd::reference ref_vbd (); 
    vbd::reference select_vbd (); 
    vbd::reference select_vbd (vbd::const_reference value); 
    bool vbd_isSelected() const;

    class audioTelephonyEvent {
      public:
        enum Id { id_ = 23 };
        typedef NoPTAudioTelephonyEventCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioTelephonyEvent

    audioTelephonyEvent::const_reference get_audioTelephonyEvent () const;
    audioTelephonyEvent::reference ref_audioTelephonyEvent (); 
    audioTelephonyEvent::reference select_audioTelephonyEvent (); 
    audioTelephonyEvent::reference select_audioTelephonyEvent (audioTelephonyEvent::const_reference value); 
    bool audioTelephonyEvent_isSelected() const;

    class audioTone {
      public:
        enum Id { id_ = 24 };
        typedef NoPTAudioToneCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioTone

    audioTone::const_reference get_audioTone () const;
    audioTone::reference ref_audioTone (); 
    audioTone::reference select_audioTone (); 
    audioTone::reference select_audioTone (audioTone::const_reference value); 
    bool audioTone_isSelected() const;

    AudioCapability(nonStandard::Id id, nonStandard::const_reference value);
    AudioCapability(g711Alaw64k::Id id, g711Alaw64k::value_type::int_type value);
    AudioCapability(g711Alaw56k::Id id, g711Alaw56k::value_type::int_type value);
    AudioCapability(g711Ulaw64k::Id id, g711Ulaw64k::value_type::int_type value);
    AudioCapability(g711Ulaw56k::Id id, g711Ulaw56k::value_type::int_type value);
    AudioCapability(g722_64k::Id id, g722_64k::value_type::int_type value);
    AudioCapability(g722_56k::Id id, g722_56k::value_type::int_type value);
    AudioCapability(g722_48k::Id id, g722_48k::value_type::int_type value);
    AudioCapability(g7231::Id id, g7231::const_reference value);
    AudioCapability(g728::Id id, g728::value_type::int_type value);
    AudioCapability(g729::Id id, g729::value_type::int_type value);
    AudioCapability(g729AnnexA::Id id, g729AnnexA::value_type::int_type value);
    AudioCapability(is11172AudioCapability::Id id, is11172AudioCapability::const_reference value);
    AudioCapability(is13818AudioCapability::Id id, is13818AudioCapability::const_reference value);
    AudioCapability(g729wAnnexB::Id id, g729wAnnexB::value_type::int_type value);
    AudioCapability(g729AnnexAwAnnexB::Id id, g729AnnexAwAnnexB::value_type::int_type value);
    AudioCapability(g7231AnnexCCapability::Id id, g7231AnnexCCapability::const_reference value);
    AudioCapability(gsmFullRate::Id id, gsmFullRate::const_reference value);
    AudioCapability(gsmHalfRate::Id id, gsmHalfRate::const_reference value);
    AudioCapability(gsmEnhancedFullRate::Id id, gsmEnhancedFullRate::const_reference value);
    AudioCapability(genericAudioCapability::Id id, genericAudioCapability::const_reference value);
    AudioCapability(g729Extensions::Id id, g729Extensions::const_reference value);
    AudioCapability(vbd::Id id, vbd::const_reference value);
    AudioCapability(audioTelephonyEvent::Id id, audioTelephonyEvent::const_reference value);
    AudioCapability(audioTone::Id id, audioTone::const_reference value);
    void swap(AudioCapability & other);
    AudioCapability(const AudioCapability & other)
    : Inherited(other) {} 

    AudioCapability & operator = (const AudioCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    AudioCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[25];
    static const char* selectionNames[25];
};

//
// DataApplicationCapability
//

class DataApplicationCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataApplicationCapability(const void* info) : Inherited(info) {}
  public:
    DataApplicationCapability() : Inherited(&theInfo) {}
    DataApplicationCapability(const DataApplicationCapability & other) : Inherited(other)
    {}
    DataApplicationCapability& operator = (const DataApplicationCapability& other)
    { Inherited::operator = (other); return *this; } 
    class application {
      public:
        typedef DataApplicationCapability_application value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class application
    application::const_reference get_application () const;
    application::reference ref_application ();
    application::reference set_application ();
    application::reference set_application (application::const_reference value);
    class maxBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxBitRate
    maxBitRate::const_reference get_maxBitRate () const;
    maxBitRate::reference ref_maxBitRate ();
    maxBitRate::reference set_maxBitRate ();
    maxBitRate::reference set_maxBitRate (maxBitRate::value_type::int_type value);
    void swap(DataApplicationCapability& other);
    DataApplicationCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// EncryptionAuthenticationAndIntegrity
//

class EncryptionAuthenticationAndIntegrity : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EncryptionAuthenticationAndIntegrity(const void* info) : Inherited(info) {}
  public:
    EncryptionAuthenticationAndIntegrity() : Inherited(&theInfo) {}
    EncryptionAuthenticationAndIntegrity(const EncryptionAuthenticationAndIntegrity & other) : Inherited(other)
    {}
    EncryptionAuthenticationAndIntegrity& operator = (const EncryptionAuthenticationAndIntegrity& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_encryptionCapability,
      e_authenticationCapability,
      e_integrityCapability,
      e_genericH235SecurityCapability
    };

    class encryptionCapability {
      public:
        typedef EncryptionCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionCapability
    encryptionCapability::const_reference get_encryptionCapability () const;
    encryptionCapability::reference ref_encryptionCapability ();
    encryptionCapability::reference set_encryptionCapability ();
    encryptionCapability::reference set_encryptionCapability (encryptionCapability::const_reference value);
    void omit_encryptionCapability ();
    bool encryptionCapability_isPresent () const;
    class authenticationCapability {
      public:
        typedef AuthenticationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class authenticationCapability
    authenticationCapability::const_reference get_authenticationCapability () const;
    authenticationCapability::reference ref_authenticationCapability ();
    authenticationCapability::reference set_authenticationCapability ();
    authenticationCapability::reference set_authenticationCapability (authenticationCapability::const_reference value);
    void omit_authenticationCapability ();
    bool authenticationCapability_isPresent () const;
    class integrityCapability {
      public:
        typedef IntegrityCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class integrityCapability
    integrityCapability::const_reference get_integrityCapability () const;
    integrityCapability::reference ref_integrityCapability ();
    integrityCapability::reference set_integrityCapability ();
    integrityCapability::reference set_integrityCapability (integrityCapability::const_reference value);
    void omit_integrityCapability ();
    bool integrityCapability_isPresent () const;
    class genericH235SecurityCapability {
      public:
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericH235SecurityCapability
    genericH235SecurityCapability::const_reference get_genericH235SecurityCapability () const;
    genericH235SecurityCapability::reference ref_genericH235SecurityCapability ();
    genericH235SecurityCapability::reference set_genericH235SecurityCapability ();
    genericH235SecurityCapability::reference set_genericH235SecurityCapability (genericH235SecurityCapability::const_reference value);
    void omit_genericH235SecurityCapability ();
    bool genericH235SecurityCapability_isPresent () const;
    void swap(EncryptionAuthenticationAndIntegrity& other);
    EncryptionAuthenticationAndIntegrity * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// UserInputCapability
//

class UserInputCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    UserInputCapability(const void* info) : Inherited(info) {}
  public:
    UserInputCapability() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::SEQUENCE_OF<NonStandardParameter,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 16> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class basicString {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class basicString

    basicString::reference select_basicString (); 
    bool basicString_isSelected() const;

    class iA5String {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class iA5String

    iA5String::reference select_iA5String (); 
    bool iA5String_isSelected() const;

    class generalString {
      public:
        enum Id { id_ = 3 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class generalString

    generalString::reference select_generalString (); 
    bool generalString_isSelected() const;

    class dtmf {
      public:
        enum Id { id_ = 4 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dtmf

    dtmf::reference select_dtmf (); 
    bool dtmf_isSelected() const;

    class hookflash {
      public:
        enum Id { id_ = 5 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hookflash

    hookflash::reference select_hookflash (); 
    bool hookflash_isSelected() const;

    class extendedAlphanumeric {
      public:
        enum Id { id_ = 6 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class extendedAlphanumeric

    extendedAlphanumeric::reference select_extendedAlphanumeric (); 
    bool extendedAlphanumeric_isSelected() const;

    class encryptedBasicString {
      public:
        enum Id { id_ = 7 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedBasicString

    encryptedBasicString::reference select_encryptedBasicString (); 
    bool encryptedBasicString_isSelected() const;

    class encryptedIA5String {
      public:
        enum Id { id_ = 8 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedIA5String

    encryptedIA5String::reference select_encryptedIA5String (); 
    bool encryptedIA5String_isSelected() const;

    class encryptedGeneralString {
      public:
        enum Id { id_ = 9 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptedGeneralString

    encryptedGeneralString::reference select_encryptedGeneralString (); 
    bool encryptedGeneralString_isSelected() const;

    class secureDTMF {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class secureDTMF

    secureDTMF::reference select_secureDTMF (); 
    bool secureDTMF_isSelected() const;

    class genericUserInputCapability {
      public:
        enum Id { id_ = 11 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericUserInputCapability

    genericUserInputCapability::const_reference get_genericUserInputCapability () const;
    genericUserInputCapability::reference ref_genericUserInputCapability (); 
    genericUserInputCapability::reference select_genericUserInputCapability (); 
    genericUserInputCapability::reference select_genericUserInputCapability (genericUserInputCapability::const_reference value); 
    bool genericUserInputCapability_isSelected() const;

    UserInputCapability(nonStandard::Id id, nonStandard::const_reference value);
    UserInputCapability(basicString::Id id, basicString::const_reference value);
    UserInputCapability(iA5String::Id id, iA5String::const_reference value);
    UserInputCapability(generalString::Id id, generalString::const_reference value);
    UserInputCapability(dtmf::Id id, dtmf::const_reference value);
    UserInputCapability(hookflash::Id id, hookflash::const_reference value);
    UserInputCapability(extendedAlphanumeric::Id id, extendedAlphanumeric::const_reference value);
    UserInputCapability(encryptedBasicString::Id id, encryptedBasicString::const_reference value);
    UserInputCapability(encryptedIA5String::Id id, encryptedIA5String::const_reference value);
    UserInputCapability(encryptedGeneralString::Id id, encryptedGeneralString::const_reference value);
    UserInputCapability(secureDTMF::Id id, secureDTMF::const_reference value);
    UserInputCapability(genericUserInputCapability::Id id, genericUserInputCapability::const_reference value);
    void swap(UserInputCapability & other);
    UserInputCapability(const UserInputCapability & other)
    : Inherited(other) {} 

    UserInputCapability & operator = (const UserInputCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    UserInputCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[12];
    static const char* selectionNames[12];
};

//
// MultiplexedStreamCapability
//

class MultiplexedStreamCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexedStreamCapability(const void* info) : Inherited(info) {}
  public:
    MultiplexedStreamCapability() : Inherited(&theInfo) {}
    MultiplexedStreamCapability(const MultiplexedStreamCapability & other) : Inherited(other)
    {}
    MultiplexedStreamCapability& operator = (const MultiplexedStreamCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_capabilityOnMuxStream
    };

    class multiplexFormat {
      public:
        typedef MultiplexFormat value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexFormat
    multiplexFormat::const_reference get_multiplexFormat () const;
    multiplexFormat::reference ref_multiplexFormat ();
    multiplexFormat::reference set_multiplexFormat ();
    multiplexFormat::reference set_multiplexFormat (multiplexFormat::const_reference value);
    class controlOnMuxStream {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class controlOnMuxStream
    controlOnMuxStream::const_reference get_controlOnMuxStream () const;
    controlOnMuxStream::reference ref_controlOnMuxStream ();
    controlOnMuxStream::reference set_controlOnMuxStream ();
    controlOnMuxStream::reference set_controlOnMuxStream (bool value);
    class capabilityOnMuxStream {
      public:
        typedef ASN1::SET_OF<AlternativeCapabilitySet,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityOnMuxStream
    capabilityOnMuxStream::const_reference get_capabilityOnMuxStream () const;
    capabilityOnMuxStream::reference ref_capabilityOnMuxStream ();
    capabilityOnMuxStream::reference set_capabilityOnMuxStream ();
    capabilityOnMuxStream::reference set_capabilityOnMuxStream (capabilityOnMuxStream::const_reference value);
    void omit_capabilityOnMuxStream ();
    bool capabilityOnMuxStream_isPresent () const;
    void swap(MultiplexedStreamCapability& other);
    MultiplexedStreamCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// H235Media
//

class H235Media : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H235Media(const void* info) : Inherited(info) {}
  public:
    H235Media() : Inherited(&theInfo) {}
    H235Media(const H235Media & other) : Inherited(other)
    {}
    H235Media& operator = (const H235Media& other)
    { Inherited::operator = (other); return *this; } 
    class encryptionAuthenticationAndIntegrity {
      public:
        typedef EncryptionAuthenticationAndIntegrity value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionAuthenticationAndIntegrity
    encryptionAuthenticationAndIntegrity::const_reference get_encryptionAuthenticationAndIntegrity () const;
    encryptionAuthenticationAndIntegrity::reference ref_encryptionAuthenticationAndIntegrity ();
    encryptionAuthenticationAndIntegrity::reference set_encryptionAuthenticationAndIntegrity ();
    encryptionAuthenticationAndIntegrity::reference set_encryptionAuthenticationAndIntegrity (encryptionAuthenticationAndIntegrity::const_reference value);
    void swap(H235Media& other);
    H235Media * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RedundancyEncodingMode
//

class RedundancyEncodingMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingMode(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingMode() : Inherited(&theInfo) {}
    RedundancyEncodingMode(const RedundancyEncodingMode & other) : Inherited(other)
    {}
    RedundancyEncodingMode& operator = (const RedundancyEncodingMode& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_secondaryEncoding
    };

    class redundancyEncodingMethod {
      public:
        typedef RedundancyEncodingMethod value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingMethod
    redundancyEncodingMethod::const_reference get_redundancyEncodingMethod () const;
    redundancyEncodingMethod::reference ref_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod (redundancyEncodingMethod::const_reference value);
    class secondaryEncoding {
      public:
        typedef RedundancyEncodingMode_secondaryEncoding value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class secondaryEncoding
    secondaryEncoding::const_reference get_secondaryEncoding () const;
    secondaryEncoding::reference ref_secondaryEncoding ();
    secondaryEncoding::reference set_secondaryEncoding ();
    secondaryEncoding::reference set_secondaryEncoding (secondaryEncoding::const_reference value);
    void omit_secondaryEncoding ();
    bool secondaryEncoding_isPresent () const;
    void swap(RedundancyEncodingMode& other);
    RedundancyEncodingMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DataMode
//

class DataMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataMode(const void* info) : Inherited(info) {}
  public:
    DataMode() : Inherited(&theInfo) {}
    DataMode(const DataMode & other) : Inherited(other)
    {}
    DataMode& operator = (const DataMode& other)
    { Inherited::operator = (other); return *this; } 
    class application {
      public:
        typedef DataMode_application value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class application
    application::const_reference get_application () const;
    application::reference ref_application ();
    application::reference set_application ();
    application::reference set_application (application::const_reference value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    void swap(DataMode& other);
    DataMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DialingInformation
//

class DialingInformation : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DialingInformation(const void* info) : Inherited(info) {}
  public:
    DialingInformation() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class differential {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::SET_OF<DialingInformationNumber,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 65535> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class differential

    differential::const_reference get_differential () const;
    differential::reference ref_differential (); 
    differential::reference select_differential (); 
    differential::reference select_differential (differential::const_reference value); 
    bool differential_isSelected() const;

    class infoNotAvailable {
      public:
        enum Id { id_ = 2 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class infoNotAvailable

    infoNotAvailable::const_reference get_infoNotAvailable () const;
    infoNotAvailable::reference ref_infoNotAvailable (); 
    infoNotAvailable::reference select_infoNotAvailable (); 
    infoNotAvailable::reference select_infoNotAvailable (infoNotAvailable::value_type::int_type value); 
    bool infoNotAvailable_isSelected() const;

    DialingInformation(nonStandard::Id id, nonStandard::const_reference value);
    DialingInformation(differential::Id id, differential::const_reference value);
    DialingInformation(infoNotAvailable::Id id, infoNotAvailable::value_type::int_type value);
    void swap(DialingInformation & other);
    DialingInformation(const DialingInformation & other)
    : Inherited(other) {} 

    DialingInformation & operator = (const DialingInformation & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DialingInformation * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// MiscellaneousCommand
//

class MiscellaneousCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MiscellaneousCommand(const void* info) : Inherited(info) {}
  public:
    MiscellaneousCommand() : Inherited(&theInfo) {}
    MiscellaneousCommand(const MiscellaneousCommand & other) : Inherited(other)
    {}
    MiscellaneousCommand& operator = (const MiscellaneousCommand& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_direction
    };

    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    class type {
      public:
        typedef MiscellaneousCommand_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    class direction {
      public:
        typedef EncryptionUpdateDirection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class direction
    direction::const_reference get_direction () const;
    direction::reference ref_direction ();
    direction::reference set_direction ();
    direction::reference set_direction (direction::const_reference value);
    void omit_direction ();
    bool direction_isPresent () const;
    void swap(MiscellaneousCommand& other);
    MiscellaneousCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// OpenLogicalChannelAck_reverseLogicalChannelParameters
//

class OpenLogicalChannelAck_reverseLogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelAck_reverseLogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelAck_reverseLogicalChannelParameters() : Inherited(&theInfo) {}
    OpenLogicalChannelAck_reverseLogicalChannelParameters(const OpenLogicalChannelAck_reverseLogicalChannelParameters & other) : Inherited(other)
    {}
    OpenLogicalChannelAck_reverseLogicalChannelParameters& operator = (const OpenLogicalChannelAck_reverseLogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_portNumber,
      e_multiplexParameters,
      e_replacementFor
    };

    class reverseLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reverseLogicalChannelNumber
    reverseLogicalChannelNumber::const_reference get_reverseLogicalChannelNumber () const;
    reverseLogicalChannelNumber::reference ref_reverseLogicalChannelNumber ();
    reverseLogicalChannelNumber::reference set_reverseLogicalChannelNumber ();
    reverseLogicalChannelNumber::reference set_reverseLogicalChannelNumber (reverseLogicalChannelNumber::value_type::int_type value);
    class portNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class portNumber
    portNumber::const_reference get_portNumber () const;
    portNumber::reference ref_portNumber ();
    portNumber::reference set_portNumber ();
    portNumber::reference set_portNumber (portNumber::value_type::int_type value);
    void omit_portNumber ();
    bool portNumber_isPresent () const;
    class multiplexParameters {
      public:
        typedef OpenLogicalChannelAck_reverseLogicalChannelParameters_multiplexParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexParameters
    multiplexParameters::const_reference get_multiplexParameters () const;
    multiplexParameters::reference ref_multiplexParameters ();
    multiplexParameters::reference set_multiplexParameters ();
    multiplexParameters::reference set_multiplexParameters (multiplexParameters::const_reference value);
    void omit_multiplexParameters ();
    bool multiplexParameters_isPresent () const;
    class replacementFor {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class replacementFor
    replacementFor::const_reference get_replacementFor () const;
    replacementFor::reference ref_replacementFor ();
    replacementFor::reference set_replacementFor ();
    replacementFor::reference set_replacementFor (replacementFor::value_type::int_type value);
    void omit_replacementFor ();
    bool replacementFor_isPresent () const;
    void swap(OpenLogicalChannelAck_reverseLogicalChannelParameters& other);
    OpenLogicalChannelAck_reverseLogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// MultilinkRequest_addConnection
//

class MultilinkRequest_addConnection : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkRequest_addConnection(const void* info) : Inherited(info) {}
  public:
    MultilinkRequest_addConnection() : Inherited(&theInfo) {}
    MultilinkRequest_addConnection(const MultilinkRequest_addConnection & other) : Inherited(other)
    {}
    MultilinkRequest_addConnection& operator = (const MultilinkRequest_addConnection& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class dialingInformation {
      public:
        typedef DialingInformation value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dialingInformation
    dialingInformation::const_reference get_dialingInformation () const;
    dialingInformation::reference ref_dialingInformation ();
    dialingInformation::reference set_dialingInformation ();
    dialingInformation::reference set_dialingInformation (dialingInformation::const_reference value);
    void swap(MultilinkRequest_addConnection& other);
    MultilinkRequest_addConnection * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MultilinkResponse_callInformation
//

class MultilinkResponse_callInformation : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse_callInformation(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse_callInformation() : Inherited(&theInfo) {}
    MultilinkResponse_callInformation(const MultilinkResponse_callInformation & other) : Inherited(other)
    {}
    MultilinkResponse_callInformation& operator = (const MultilinkResponse_callInformation& other)
    { Inherited::operator = (other); return *this; } 
    class dialingInformation {
      public:
        typedef DialingInformation value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dialingInformation
    dialingInformation::const_reference get_dialingInformation () const;
    dialingInformation::reference ref_dialingInformation ();
    dialingInformation::reference set_dialingInformation ();
    dialingInformation::reference set_dialingInformation (dialingInformation::const_reference value);
    class callAssociationNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 4294967295U>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class callAssociationNumber
    callAssociationNumber::const_reference get_callAssociationNumber () const;
    callAssociationNumber::reference ref_callAssociationNumber ();
    callAssociationNumber::reference set_callAssociationNumber ();
    callAssociationNumber::reference set_callAssociationNumber (callAssociationNumber::value_type::int_type value);
    void swap(MultilinkResponse_callInformation& other);
    MultilinkResponse_callInformation * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// H235SecurityCapability
//

class H235SecurityCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H235SecurityCapability(const void* info) : Inherited(info) {}
  public:
    H235SecurityCapability() : Inherited(&theInfo) {}
    H235SecurityCapability(const H235SecurityCapability & other) : Inherited(other)
    {}
    H235SecurityCapability& operator = (const H235SecurityCapability& other)
    { Inherited::operator = (other); return *this; } 
    class encryptionAuthenticationAndIntegrity {
      public:
        typedef EncryptionAuthenticationAndIntegrity value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionAuthenticationAndIntegrity
    encryptionAuthenticationAndIntegrity::const_reference get_encryptionAuthenticationAndIntegrity () const;
    encryptionAuthenticationAndIntegrity::reference ref_encryptionAuthenticationAndIntegrity ();
    encryptionAuthenticationAndIntegrity::reference set_encryptionAuthenticationAndIntegrity ();
    encryptionAuthenticationAndIntegrity::reference set_encryptionAuthenticationAndIntegrity (encryptionAuthenticationAndIntegrity::const_reference value);
    class mediaCapability {
      public:
        typedef CapabilityTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaCapability
    mediaCapability::const_reference get_mediaCapability () const;
    mediaCapability::reference ref_mediaCapability ();
    mediaCapability::reference set_mediaCapability ();
    mediaCapability::reference set_mediaCapability (mediaCapability::value_type::int_type value);
    void swap(H235SecurityCapability& other);
    H235SecurityCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// MediaDistributionCapability
//

class MediaDistributionCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MediaDistributionCapability(const void* info) : Inherited(info) {}
  public:
    MediaDistributionCapability() : Inherited(&theInfo) {}
    MediaDistributionCapability(const MediaDistributionCapability & other) : Inherited(other)
    {}
    MediaDistributionCapability& operator = (const MediaDistributionCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_centralizedData,
      e_distributedData
    };

    class centralizedControl {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class centralizedControl
    centralizedControl::const_reference get_centralizedControl () const;
    centralizedControl::reference ref_centralizedControl ();
    centralizedControl::reference set_centralizedControl ();
    centralizedControl::reference set_centralizedControl (bool value);
    class distributedControl {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class distributedControl
    distributedControl::const_reference get_distributedControl () const;
    distributedControl::reference ref_distributedControl ();
    distributedControl::reference set_distributedControl ();
    distributedControl::reference set_distributedControl (bool value);
    class centralizedAudio {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class centralizedAudio
    centralizedAudio::const_reference get_centralizedAudio () const;
    centralizedAudio::reference ref_centralizedAudio ();
    centralizedAudio::reference set_centralizedAudio ();
    centralizedAudio::reference set_centralizedAudio (bool value);
    class distributedAudio {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class distributedAudio
    distributedAudio::const_reference get_distributedAudio () const;
    distributedAudio::reference ref_distributedAudio ();
    distributedAudio::reference set_distributedAudio ();
    distributedAudio::reference set_distributedAudio (bool value);
    class centralizedVideo {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class centralizedVideo
    centralizedVideo::const_reference get_centralizedVideo () const;
    centralizedVideo::reference ref_centralizedVideo ();
    centralizedVideo::reference set_centralizedVideo ();
    centralizedVideo::reference set_centralizedVideo (bool value);
    class distributedVideo {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class distributedVideo
    distributedVideo::const_reference get_distributedVideo () const;
    distributedVideo::reference ref_distributedVideo ();
    distributedVideo::reference set_distributedVideo ();
    distributedVideo::reference set_distributedVideo (bool value);
    class centralizedData {
      public:
        typedef ASN1::SEQUENCE_OF<DataApplicationCapability>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class centralizedData
    centralizedData::const_reference get_centralizedData () const;
    centralizedData::reference ref_centralizedData ();
    centralizedData::reference set_centralizedData ();
    centralizedData::reference set_centralizedData (centralizedData::const_reference value);
    void omit_centralizedData ();
    bool centralizedData_isPresent () const;
    class distributedData {
      public:
        typedef ASN1::SEQUENCE_OF<DataApplicationCapability>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class distributedData
    distributedData::const_reference get_distributedData () const;
    distributedData::reference ref_distributedData ();
    distributedData::reference set_distributedData ();
    distributedData::reference set_distributedData (distributedData::const_reference value);
    void omit_distributedData ();
    bool distributedData_isPresent () const;
    void swap(MediaDistributionCapability& other);
    MediaDistributionCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[8];
    static int fieldIds[8];
    static const char* fieldNames[8];
};

//
// BEnhancementParameters
//

class BEnhancementParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    BEnhancementParameters(const void* info) : Inherited(info) {}
  public:
    BEnhancementParameters() : Inherited(&theInfo) {}
    BEnhancementParameters(const BEnhancementParameters & other) : Inherited(other)
    {}
    BEnhancementParameters& operator = (const BEnhancementParameters& other)
    { Inherited::operator = (other); return *this; } 
    class enhancementOptions {
      public:
        typedef EnhancementOptions value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enhancementOptions
    enhancementOptions::const_reference get_enhancementOptions () const;
    enhancementOptions::reference ref_enhancementOptions ();
    enhancementOptions::reference set_enhancementOptions ();
    enhancementOptions::reference set_enhancementOptions (enhancementOptions::const_reference value);
    class numberOfBPictures {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 64>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class numberOfBPictures
    numberOfBPictures::const_reference get_numberOfBPictures () const;
    numberOfBPictures::reference ref_numberOfBPictures ();
    numberOfBPictures::reference set_numberOfBPictures ();
    numberOfBPictures::reference set_numberOfBPictures (numberOfBPictures::value_type::int_type value);
    void swap(BEnhancementParameters& other);
    BEnhancementParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// OpenLogicalChannelAck
//

class OpenLogicalChannelAck : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannelAck(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannelAck() : Inherited(&theInfo) {}
    OpenLogicalChannelAck(const OpenLogicalChannelAck & other) : Inherited(other)
    {}
    OpenLogicalChannelAck& operator = (const OpenLogicalChannelAck& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_reverseLogicalChannelParameters,
      e_separateStack,
      e_forwardMultiplexAckParameters,
      e_encryptionSync,
      e_genericInformation
    };

    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class reverseLogicalChannelParameters {
      public:
        typedef OpenLogicalChannelAck_reverseLogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reverseLogicalChannelParameters
    reverseLogicalChannelParameters::const_reference get_reverseLogicalChannelParameters () const;
    reverseLogicalChannelParameters::reference ref_reverseLogicalChannelParameters ();
    reverseLogicalChannelParameters::reference set_reverseLogicalChannelParameters ();
    reverseLogicalChannelParameters::reference set_reverseLogicalChannelParameters (reverseLogicalChannelParameters::const_reference value);
    void omit_reverseLogicalChannelParameters ();
    bool reverseLogicalChannelParameters_isPresent () const;
    class separateStack {
      public:
        typedef NetworkAccessParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateStack
    separateStack::const_reference get_separateStack () const;
    separateStack::reference ref_separateStack ();
    separateStack::reference set_separateStack ();
    separateStack::reference set_separateStack (separateStack::const_reference value);
    void omit_separateStack ();
    bool separateStack_isPresent () const;
    class forwardMultiplexAckParameters {
      public:
        typedef OpenLogicalChannelAck_forwardMultiplexAckParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardMultiplexAckParameters
    forwardMultiplexAckParameters::const_reference get_forwardMultiplexAckParameters () const;
    forwardMultiplexAckParameters::reference ref_forwardMultiplexAckParameters ();
    forwardMultiplexAckParameters::reference set_forwardMultiplexAckParameters ();
    forwardMultiplexAckParameters::reference set_forwardMultiplexAckParameters (forwardMultiplexAckParameters::const_reference value);
    void omit_forwardMultiplexAckParameters ();
    bool forwardMultiplexAckParameters_isPresent () const;
    class encryptionSync {
      public:
        typedef EncryptionSync value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionSync
    encryptionSync::const_reference get_encryptionSync () const;
    encryptionSync::reference ref_encryptionSync ();
    encryptionSync::reference set_encryptionSync ();
    encryptionSync::reference set_encryptionSync (encryptionSync::const_reference value);
    void omit_encryptionSync ();
    bool encryptionSync_isPresent () const;
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(OpenLogicalChannelAck& other);
    OpenLogicalChannelAck * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// H2250ModeParameters
//

class H2250ModeParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250ModeParameters(const void* info) : Inherited(info) {}
  public:
    H2250ModeParameters() : Inherited(&theInfo) {}
    H2250ModeParameters(const H2250ModeParameters & other) : Inherited(other)
    {}
    H2250ModeParameters& operator = (const H2250ModeParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_redundancyEncodingMode
    };

    class redundancyEncodingMode {
      public:
        typedef RedundancyEncodingMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingMode
    redundancyEncodingMode::const_reference get_redundancyEncodingMode () const;
    redundancyEncodingMode::reference ref_redundancyEncodingMode ();
    redundancyEncodingMode::reference set_redundancyEncodingMode ();
    redundancyEncodingMode::reference set_redundancyEncodingMode (redundancyEncodingMode::const_reference value);
    void omit_redundancyEncodingMode ();
    bool redundancyEncodingMode_isPresent () const;
    void swap(H2250ModeParameters& other);
    H2250ModeParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// MultilinkRequest
//

class MultilinkRequest : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkRequest(const void* info) : Inherited(info) {}
  public:
    MultilinkRequest() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class callInformation {
      public:
        enum Id { id_ = 1 };
        typedef MultilinkRequest_callInformation value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class callInformation

    callInformation::const_reference get_callInformation () const;
    callInformation::reference ref_callInformation (); 
    callInformation::reference select_callInformation (); 
    callInformation::reference select_callInformation (callInformation::const_reference value); 
    bool callInformation_isSelected() const;

    class addConnection {
      public:
        enum Id { id_ = 2 };
        typedef MultilinkRequest_addConnection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class addConnection

    addConnection::const_reference get_addConnection () const;
    addConnection::reference ref_addConnection (); 
    addConnection::reference select_addConnection (); 
    addConnection::reference select_addConnection (addConnection::const_reference value); 
    bool addConnection_isSelected() const;

    class removeConnection {
      public:
        enum Id { id_ = 3 };
        typedef MultilinkRequest_removeConnection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class removeConnection

    removeConnection::const_reference get_removeConnection () const;
    removeConnection::reference ref_removeConnection (); 
    removeConnection::reference select_removeConnection (); 
    removeConnection::reference select_removeConnection (removeConnection::const_reference value); 
    bool removeConnection_isSelected() const;

    class maximumHeaderInterval {
      public:
        enum Id { id_ = 4 };
        typedef MultilinkRequest_maximumHeaderInterval value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumHeaderInterval

    maximumHeaderInterval::const_reference get_maximumHeaderInterval () const;
    maximumHeaderInterval::reference ref_maximumHeaderInterval (); 
    maximumHeaderInterval::reference select_maximumHeaderInterval (); 
    maximumHeaderInterval::reference select_maximumHeaderInterval (maximumHeaderInterval::const_reference value); 
    bool maximumHeaderInterval_isSelected() const;

    MultilinkRequest(nonStandard::Id id, nonStandard::const_reference value);
    MultilinkRequest(callInformation::Id id, callInformation::const_reference value);
    MultilinkRequest(addConnection::Id id, addConnection::const_reference value);
    MultilinkRequest(removeConnection::Id id, removeConnection::const_reference value);
    MultilinkRequest(maximumHeaderInterval::Id id, maximumHeaderInterval::const_reference value);
    void swap(MultilinkRequest & other);
    MultilinkRequest(const MultilinkRequest & other)
    : Inherited(other) {} 

    MultilinkRequest & operator = (const MultilinkRequest & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultilinkRequest * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// MultilinkResponse
//

class MultilinkResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultilinkResponse(const void* info) : Inherited(info) {}
  public:
    MultilinkResponse() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class callInformation {
      public:
        enum Id { id_ = 1 };
        typedef MultilinkResponse_callInformation value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class callInformation

    callInformation::const_reference get_callInformation () const;
    callInformation::reference ref_callInformation (); 
    callInformation::reference select_callInformation (); 
    callInformation::reference select_callInformation (callInformation::const_reference value); 
    bool callInformation_isSelected() const;

    class addConnection {
      public:
        enum Id { id_ = 2 };
        typedef MultilinkResponse_addConnection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class addConnection

    addConnection::const_reference get_addConnection () const;
    addConnection::reference ref_addConnection (); 
    addConnection::reference select_addConnection (); 
    addConnection::reference select_addConnection (addConnection::const_reference value); 
    bool addConnection_isSelected() const;

    class removeConnection {
      public:
        enum Id { id_ = 3 };
        typedef MultilinkResponse_removeConnection value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class removeConnection

    removeConnection::const_reference get_removeConnection () const;
    removeConnection::reference ref_removeConnection (); 
    removeConnection::reference select_removeConnection (); 
    removeConnection::reference select_removeConnection (removeConnection::const_reference value); 
    bool removeConnection_isSelected() const;

    class maximumHeaderInterval {
      public:
        enum Id { id_ = 4 };
        typedef MultilinkResponse_maximumHeaderInterval value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumHeaderInterval

    maximumHeaderInterval::const_reference get_maximumHeaderInterval () const;
    maximumHeaderInterval::reference ref_maximumHeaderInterval (); 
    maximumHeaderInterval::reference select_maximumHeaderInterval (); 
    maximumHeaderInterval::reference select_maximumHeaderInterval (maximumHeaderInterval::const_reference value); 
    bool maximumHeaderInterval_isSelected() const;

    MultilinkResponse(nonStandard::Id id, nonStandard::const_reference value);
    MultilinkResponse(callInformation::Id id, callInformation::const_reference value);
    MultilinkResponse(addConnection::Id id, addConnection::const_reference value);
    MultilinkResponse(removeConnection::Id id, removeConnection::const_reference value);
    MultilinkResponse(maximumHeaderInterval::Id id, maximumHeaderInterval::const_reference value);
    void swap(MultilinkResponse & other);
    MultilinkResponse(const MultilinkResponse & other)
    : Inherited(other) {} 

    MultilinkResponse & operator = (const MultilinkResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultilinkResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[5];
    static const char* selectionNames[5];
};

//
// MultipointCapability
//

class MultipointCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultipointCapability(const void* info) : Inherited(info) {}
  public:
    MultipointCapability() : Inherited(&theInfo) {}
    MultipointCapability(const MultipointCapability & other) : Inherited(other)
    {}
    MultipointCapability& operator = (const MultipointCapability& other)
    { Inherited::operator = (other); return *this; } 
    class multicastCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multicastCapability
    multicastCapability::const_reference get_multicastCapability () const;
    multicastCapability::reference ref_multicastCapability ();
    multicastCapability::reference set_multicastCapability ();
    multicastCapability::reference set_multicastCapability (bool value);
    class multiUniCastConference {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiUniCastConference
    multiUniCastConference::const_reference get_multiUniCastConference () const;
    multiUniCastConference::reference ref_multiUniCastConference ();
    multiUniCastConference::reference set_multiUniCastConference ();
    multiUniCastConference::reference set_multiUniCastConference (bool value);
    class mediaDistributionCapability {
      public:
        typedef ASN1::SEQUENCE_OF<MediaDistributionCapability>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaDistributionCapability
    mediaDistributionCapability::const_reference get_mediaDistributionCapability () const;
    mediaDistributionCapability::reference ref_mediaDistributionCapability ();
    mediaDistributionCapability::reference set_mediaDistributionCapability ();
    mediaDistributionCapability::reference set_mediaDistributionCapability (mediaDistributionCapability::const_reference value);
    void swap(MultipointCapability& other);
    MultipointCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// EnhancementLayerInfo
//

class EnhancementLayerInfo : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    EnhancementLayerInfo(const void* info) : Inherited(info) {}
  public:
    EnhancementLayerInfo() : Inherited(&theInfo) {}
    EnhancementLayerInfo(const EnhancementLayerInfo & other) : Inherited(other)
    {}
    EnhancementLayerInfo& operator = (const EnhancementLayerInfo& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_snrEnhancement,
      e_spatialEnhancement,
      e_bPictureEnhancement
    };

    class baseBitRateConstrained {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class baseBitRateConstrained
    baseBitRateConstrained::const_reference get_baseBitRateConstrained () const;
    baseBitRateConstrained::reference ref_baseBitRateConstrained ();
    baseBitRateConstrained::reference set_baseBitRateConstrained ();
    baseBitRateConstrained::reference set_baseBitRateConstrained (bool value);
    class snrEnhancement {
      public:
        typedef ASN1::SET_OF<EnhancementOptions,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 14> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class snrEnhancement
    snrEnhancement::const_reference get_snrEnhancement () const;
    snrEnhancement::reference ref_snrEnhancement ();
    snrEnhancement::reference set_snrEnhancement ();
    snrEnhancement::reference set_snrEnhancement (snrEnhancement::const_reference value);
    void omit_snrEnhancement ();
    bool snrEnhancement_isPresent () const;
    class spatialEnhancement {
      public:
        typedef ASN1::SET_OF<EnhancementOptions,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 14> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class spatialEnhancement
    spatialEnhancement::const_reference get_spatialEnhancement () const;
    spatialEnhancement::reference ref_spatialEnhancement ();
    spatialEnhancement::reference set_spatialEnhancement ();
    spatialEnhancement::reference set_spatialEnhancement (spatialEnhancement::const_reference value);
    void omit_spatialEnhancement ();
    bool spatialEnhancement_isPresent () const;
    class bPictureEnhancement {
      public:
        typedef ASN1::SET_OF<BEnhancementParameters,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 14> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bPictureEnhancement
    bPictureEnhancement::const_reference get_bPictureEnhancement () const;
    bPictureEnhancement::reference ref_bPictureEnhancement ();
    bPictureEnhancement::reference set_bPictureEnhancement ();
    bPictureEnhancement::reference set_bPictureEnhancement (bPictureEnhancement::const_reference value);
    void omit_bPictureEnhancement ();
    bool bPictureEnhancement_isPresent () const;
    void swap(EnhancementLayerInfo& other);
    EnhancementLayerInfo * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// H263VideoMode
//

class H263VideoMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263VideoMode(const void* info) : Inherited(info) {}
  public:
    H263VideoMode() : Inherited(&theInfo) {}
    H263VideoMode(const H263VideoMode & other) : Inherited(other)
    {}
    H263VideoMode& operator = (const H263VideoMode& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_errorCompensation,
      e_enhancementLayerInfo,
      e_h263Options
    };

    class resolution {
      public:
        typedef H263VideoMode_resolution value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class resolution
    resolution::const_reference get_resolution () const;
    resolution::reference ref_resolution ();
    resolution::reference set_resolution ();
    resolution::reference set_resolution (resolution::const_reference value);
    class bitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 19200>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bitRate
    bitRate::const_reference get_bitRate () const;
    bitRate::reference ref_bitRate ();
    bitRate::reference set_bitRate ();
    bitRate::reference set_bitRate (bitRate::value_type::int_type value);
    class unrestrictedVector {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unrestrictedVector
    unrestrictedVector::const_reference get_unrestrictedVector () const;
    unrestrictedVector::reference ref_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector (bool value);
    class arithmeticCoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class arithmeticCoding
    arithmeticCoding::const_reference get_arithmeticCoding () const;
    arithmeticCoding::reference ref_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding (bool value);
    class advancedPrediction {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class advancedPrediction
    advancedPrediction::const_reference get_advancedPrediction () const;
    advancedPrediction::reference ref_advancedPrediction ();
    advancedPrediction::reference set_advancedPrediction ();
    advancedPrediction::reference set_advancedPrediction (bool value);
    class pbFrames {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pbFrames
    pbFrames::const_reference get_pbFrames () const;
    pbFrames::reference ref_pbFrames ();
    pbFrames::reference set_pbFrames ();
    pbFrames::reference set_pbFrames (bool value);
    class errorCompensation {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCompensation
    errorCompensation::const_reference get_errorCompensation () const;
    errorCompensation::reference ref_errorCompensation ();
    errorCompensation::reference set_errorCompensation ();
    errorCompensation::reference set_errorCompensation (bool value);
    void omit_errorCompensation ();
    bool errorCompensation_isPresent () const;
    class enhancementLayerInfo {
      public:
        typedef EnhancementLayerInfo value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enhancementLayerInfo
    enhancementLayerInfo::const_reference get_enhancementLayerInfo () const;
    enhancementLayerInfo::reference ref_enhancementLayerInfo ();
    enhancementLayerInfo::reference set_enhancementLayerInfo ();
    enhancementLayerInfo::reference set_enhancementLayerInfo (enhancementLayerInfo::const_reference value);
    void omit_enhancementLayerInfo ();
    bool enhancementLayerInfo_isPresent () const;
    class h263Options {
      public:
        typedef H263Options value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263Options
    h263Options::const_reference get_h263Options () const;
    h263Options::reference ref_h263Options ();
    h263Options::reference set_h263Options ();
    h263Options::reference set_h263Options (h263Options::const_reference value);
    void omit_h263Options ();
    bool h263Options_isPresent () const;
    void swap(H263VideoMode& other);
    H263VideoMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[9];
    static int fieldIds[9];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[9];
};

//
// H2250Capability
//

class H2250Capability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H2250Capability(const void* info) : Inherited(info) {}
  public:
    H2250Capability() : Inherited(&theInfo) {}
    H2250Capability(const H2250Capability & other) : Inherited(other)
    {}
    H2250Capability& operator = (const H2250Capability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_transportCapability,
      e_redundancyEncodingCapability,
      e_logicalChannelSwitchingCapability,
      e_t120DynamicPortCapability
    };

    class maximumAudioDelayJitter {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 1023>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maximumAudioDelayJitter
    maximumAudioDelayJitter::const_reference get_maximumAudioDelayJitter () const;
    maximumAudioDelayJitter::reference ref_maximumAudioDelayJitter ();
    maximumAudioDelayJitter::reference set_maximumAudioDelayJitter ();
    maximumAudioDelayJitter::reference set_maximumAudioDelayJitter (maximumAudioDelayJitter::value_type::int_type value);
    class receiveMultipointCapability {
      public:
        typedef MultipointCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveMultipointCapability
    receiveMultipointCapability::const_reference get_receiveMultipointCapability () const;
    receiveMultipointCapability::reference ref_receiveMultipointCapability ();
    receiveMultipointCapability::reference set_receiveMultipointCapability ();
    receiveMultipointCapability::reference set_receiveMultipointCapability (receiveMultipointCapability::const_reference value);
    class transmitMultipointCapability {
      public:
        typedef MultipointCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitMultipointCapability
    transmitMultipointCapability::const_reference get_transmitMultipointCapability () const;
    transmitMultipointCapability::reference ref_transmitMultipointCapability ();
    transmitMultipointCapability::reference set_transmitMultipointCapability ();
    transmitMultipointCapability::reference set_transmitMultipointCapability (transmitMultipointCapability::const_reference value);
    class receiveAndTransmitMultipointCapability {
      public:
        typedef MultipointCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAndTransmitMultipointCapability
    receiveAndTransmitMultipointCapability::const_reference get_receiveAndTransmitMultipointCapability () const;
    receiveAndTransmitMultipointCapability::reference ref_receiveAndTransmitMultipointCapability ();
    receiveAndTransmitMultipointCapability::reference set_receiveAndTransmitMultipointCapability ();
    receiveAndTransmitMultipointCapability::reference set_receiveAndTransmitMultipointCapability (receiveAndTransmitMultipointCapability::const_reference value);
    class mcCapability {
      public:
        typedef H2250Capability_mcCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mcCapability
    mcCapability::const_reference get_mcCapability () const;
    mcCapability::reference ref_mcCapability ();
    mcCapability::reference set_mcCapability ();
    mcCapability::reference set_mcCapability (mcCapability::const_reference value);
    class rtcpVideoControlCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class rtcpVideoControlCapability
    rtcpVideoControlCapability::const_reference get_rtcpVideoControlCapability () const;
    rtcpVideoControlCapability::reference ref_rtcpVideoControlCapability ();
    rtcpVideoControlCapability::reference set_rtcpVideoControlCapability ();
    rtcpVideoControlCapability::reference set_rtcpVideoControlCapability (bool value);
    class mediaPacketizationCapability {
      public:
        typedef MediaPacketizationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaPacketizationCapability
    mediaPacketizationCapability::const_reference get_mediaPacketizationCapability () const;
    mediaPacketizationCapability::reference ref_mediaPacketizationCapability ();
    mediaPacketizationCapability::reference set_mediaPacketizationCapability ();
    mediaPacketizationCapability::reference set_mediaPacketizationCapability (mediaPacketizationCapability::const_reference value);
    class transportCapability {
      public:
        typedef TransportCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transportCapability
    transportCapability::const_reference get_transportCapability () const;
    transportCapability::reference ref_transportCapability ();
    transportCapability::reference set_transportCapability ();
    transportCapability::reference set_transportCapability (transportCapability::const_reference value);
    void omit_transportCapability ();
    bool transportCapability_isPresent () const;
    class redundancyEncodingCapability {
      public:
        typedef ASN1::SEQUENCE_OF<RedundancyEncodingCapability,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingCapability
    redundancyEncodingCapability::const_reference get_redundancyEncodingCapability () const;
    redundancyEncodingCapability::reference ref_redundancyEncodingCapability ();
    redundancyEncodingCapability::reference set_redundancyEncodingCapability ();
    redundancyEncodingCapability::reference set_redundancyEncodingCapability (redundancyEncodingCapability::const_reference value);
    void omit_redundancyEncodingCapability ();
    bool redundancyEncodingCapability_isPresent () const;
    class logicalChannelSwitchingCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelSwitchingCapability
    logicalChannelSwitchingCapability::const_reference get_logicalChannelSwitchingCapability () const;
    logicalChannelSwitchingCapability::reference ref_logicalChannelSwitchingCapability ();
    logicalChannelSwitchingCapability::reference set_logicalChannelSwitchingCapability ();
    logicalChannelSwitchingCapability::reference set_logicalChannelSwitchingCapability (bool value);
    void omit_logicalChannelSwitchingCapability ();
    bool logicalChannelSwitchingCapability_isPresent () const;
    class t120DynamicPortCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class t120DynamicPortCapability
    t120DynamicPortCapability::const_reference get_t120DynamicPortCapability () const;
    t120DynamicPortCapability::reference ref_t120DynamicPortCapability ();
    t120DynamicPortCapability::reference set_t120DynamicPortCapability ();
    t120DynamicPortCapability::reference set_t120DynamicPortCapability (bool value);
    void omit_t120DynamicPortCapability ();
    bool t120DynamicPortCapability_isPresent () const;
    void swap(H2250Capability& other);
    H2250Capability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[11];
    static int fieldIds[11];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[11];
};

//
// H263VideoCapability
//

class H263VideoCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H263VideoCapability(const void* info) : Inherited(info) {}
  public:
    H263VideoCapability() : Inherited(&theInfo) {}
    H263VideoCapability(const H263VideoCapability & other) : Inherited(other)
    {}
    H263VideoCapability& operator = (const H263VideoCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_sqcifMPI,
      e_qcifMPI,
      e_cifMPI,
      e_cif4MPI,
      e_cif16MPI,
      e_hrd_B,
      e_bppMaxKb,
      e_slowSqcifMPI,
      e_slowQcifMPI,
      e_slowCifMPI,
      e_slowCif4MPI,
      e_slowCif16MPI,
      e_errorCompensation,
      e_enhancementLayerInfo,
      e_h263Options
    };

    class sqcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sqcifMPI
    sqcifMPI::const_reference get_sqcifMPI () const;
    sqcifMPI::reference ref_sqcifMPI ();
    sqcifMPI::reference set_sqcifMPI ();
    sqcifMPI::reference set_sqcifMPI (sqcifMPI::value_type::int_type value);
    void omit_sqcifMPI ();
    bool sqcifMPI_isPresent () const;
    class qcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class qcifMPI
    qcifMPI::const_reference get_qcifMPI () const;
    qcifMPI::reference ref_qcifMPI ();
    qcifMPI::reference set_qcifMPI ();
    qcifMPI::reference set_qcifMPI (qcifMPI::value_type::int_type value);
    void omit_qcifMPI ();
    bool qcifMPI_isPresent () const;
    class cifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cifMPI
    cifMPI::const_reference get_cifMPI () const;
    cifMPI::reference ref_cifMPI ();
    cifMPI::reference set_cifMPI ();
    cifMPI::reference set_cifMPI (cifMPI::value_type::int_type value);
    void omit_cifMPI ();
    bool cifMPI_isPresent () const;
    class cif4MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif4MPI
    cif4MPI::const_reference get_cif4MPI () const;
    cif4MPI::reference ref_cif4MPI ();
    cif4MPI::reference set_cif4MPI ();
    cif4MPI::reference set_cif4MPI (cif4MPI::value_type::int_type value);
    void omit_cif4MPI ();
    bool cif4MPI_isPresent () const;
    class cif16MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 32>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class cif16MPI
    cif16MPI::const_reference get_cif16MPI () const;
    cif16MPI::reference ref_cif16MPI ();
    cif16MPI::reference set_cif16MPI ();
    cif16MPI::reference set_cif16MPI (cif16MPI::value_type::int_type value);
    void omit_cif16MPI ();
    bool cif16MPI_isPresent () const;
    class maxBitRate {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 192400>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxBitRate
    maxBitRate::const_reference get_maxBitRate () const;
    maxBitRate::reference ref_maxBitRate ();
    maxBitRate::reference set_maxBitRate ();
    maxBitRate::reference set_maxBitRate (maxBitRate::value_type::int_type value);
    class unrestrictedVector {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class unrestrictedVector
    unrestrictedVector::const_reference get_unrestrictedVector () const;
    unrestrictedVector::reference ref_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector ();
    unrestrictedVector::reference set_unrestrictedVector (bool value);
    class arithmeticCoding {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class arithmeticCoding
    arithmeticCoding::const_reference get_arithmeticCoding () const;
    arithmeticCoding::reference ref_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding ();
    arithmeticCoding::reference set_arithmeticCoding (bool value);
    class advancedPrediction {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class advancedPrediction
    advancedPrediction::const_reference get_advancedPrediction () const;
    advancedPrediction::reference ref_advancedPrediction ();
    advancedPrediction::reference set_advancedPrediction ();
    advancedPrediction::reference set_advancedPrediction (bool value);
    class pbFrames {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class pbFrames
    pbFrames::const_reference get_pbFrames () const;
    pbFrames::reference ref_pbFrames ();
    pbFrames::reference set_pbFrames ();
    pbFrames::reference set_pbFrames (bool value);
    class temporalSpatialTradeOffCapability {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class temporalSpatialTradeOffCapability
    temporalSpatialTradeOffCapability::const_reference get_temporalSpatialTradeOffCapability () const;
    temporalSpatialTradeOffCapability::reference ref_temporalSpatialTradeOffCapability ();
    temporalSpatialTradeOffCapability::reference set_temporalSpatialTradeOffCapability ();
    temporalSpatialTradeOffCapability::reference set_temporalSpatialTradeOffCapability (bool value);
    class hrd_B {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 524287>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class hrd_B
    hrd_B::const_reference get_hrd_B () const;
    hrd_B::reference ref_hrd_B ();
    hrd_B::reference set_hrd_B ();
    hrd_B::reference set_hrd_B (hrd_B::value_type::int_type value);
    void omit_hrd_B ();
    bool hrd_B_isPresent () const;
    class bppMaxKb {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class bppMaxKb
    bppMaxKb::const_reference get_bppMaxKb () const;
    bppMaxKb::reference ref_bppMaxKb ();
    bppMaxKb::reference set_bppMaxKb ();
    bppMaxKb::reference set_bppMaxKb (bppMaxKb::value_type::int_type value);
    void omit_bppMaxKb ();
    bool bppMaxKb_isPresent () const;
    class slowSqcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowSqcifMPI
    slowSqcifMPI::const_reference get_slowSqcifMPI () const;
    slowSqcifMPI::reference ref_slowSqcifMPI ();
    slowSqcifMPI::reference set_slowSqcifMPI ();
    slowSqcifMPI::reference set_slowSqcifMPI (slowSqcifMPI::value_type::int_type value);
    void omit_slowSqcifMPI ();
    bool slowSqcifMPI_isPresent () const;
    class slowQcifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowQcifMPI
    slowQcifMPI::const_reference get_slowQcifMPI () const;
    slowQcifMPI::reference ref_slowQcifMPI ();
    slowQcifMPI::reference set_slowQcifMPI ();
    slowQcifMPI::reference set_slowQcifMPI (slowQcifMPI::value_type::int_type value);
    void omit_slowQcifMPI ();
    bool slowQcifMPI_isPresent () const;
    class slowCifMPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowCifMPI
    slowCifMPI::const_reference get_slowCifMPI () const;
    slowCifMPI::reference ref_slowCifMPI ();
    slowCifMPI::reference set_slowCifMPI ();
    slowCifMPI::reference set_slowCifMPI (slowCifMPI::value_type::int_type value);
    void omit_slowCifMPI ();
    bool slowCifMPI_isPresent () const;
    class slowCif4MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowCif4MPI
    slowCif4MPI::const_reference get_slowCif4MPI () const;
    slowCif4MPI::reference ref_slowCif4MPI ();
    slowCif4MPI::reference set_slowCif4MPI ();
    slowCif4MPI::reference set_slowCif4MPI (slowCif4MPI::value_type::int_type value);
    void omit_slowCif4MPI ();
    bool slowCif4MPI_isPresent () const;
    class slowCif16MPI {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 3600>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class slowCif16MPI
    slowCif16MPI::const_reference get_slowCif16MPI () const;
    slowCif16MPI::reference ref_slowCif16MPI ();
    slowCif16MPI::reference set_slowCif16MPI ();
    slowCif16MPI::reference set_slowCif16MPI (slowCif16MPI::value_type::int_type value);
    void omit_slowCif16MPI ();
    bool slowCif16MPI_isPresent () const;
    class errorCompensation {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class errorCompensation
    errorCompensation::const_reference get_errorCompensation () const;
    errorCompensation::reference ref_errorCompensation ();
    errorCompensation::reference set_errorCompensation ();
    errorCompensation::reference set_errorCompensation (bool value);
    void omit_errorCompensation ();
    bool errorCompensation_isPresent () const;
    class enhancementLayerInfo {
      public:
        typedef EnhancementLayerInfo value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class enhancementLayerInfo
    enhancementLayerInfo::const_reference get_enhancementLayerInfo () const;
    enhancementLayerInfo::reference ref_enhancementLayerInfo ();
    enhancementLayerInfo::reference set_enhancementLayerInfo ();
    enhancementLayerInfo::reference set_enhancementLayerInfo (enhancementLayerInfo::const_reference value);
    void omit_enhancementLayerInfo ();
    bool enhancementLayerInfo_isPresent () const;
    class h263Options {
      public:
        typedef H263Options value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263Options
    h263Options::const_reference get_h263Options () const;
    h263Options::reference ref_h263Options ();
    h263Options::reference set_h263Options ();
    h263Options::reference set_h263Options (h263Options::const_reference value);
    void omit_h263Options ();
    bool h263Options_isPresent () const;
    void swap(H263VideoCapability& other);
    H263VideoCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[21];
    static int fieldIds[21];
    static const char* nonOptionalExtensions;
    static const char* fieldNames[21];
};

//
// VideoMode
//

class VideoMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VideoMode(const void* info) : Inherited(info) {}
  public:
    VideoMode() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class h261VideoMode {
      public:
        enum Id { id_ = 1 };
        typedef H261VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h261VideoMode

    h261VideoMode::const_reference get_h261VideoMode () const;
    h261VideoMode::reference ref_h261VideoMode (); 
    h261VideoMode::reference select_h261VideoMode (); 
    h261VideoMode::reference select_h261VideoMode (h261VideoMode::const_reference value); 
    bool h261VideoMode_isSelected() const;

    class h262VideoMode {
      public:
        enum Id { id_ = 2 };
        typedef H262VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h262VideoMode

    h262VideoMode::const_reference get_h262VideoMode () const;
    h262VideoMode::reference ref_h262VideoMode (); 
    h262VideoMode::reference select_h262VideoMode (); 
    h262VideoMode::reference select_h262VideoMode (h262VideoMode::const_reference value); 
    bool h262VideoMode_isSelected() const;

    class h263VideoMode {
      public:
        enum Id { id_ = 3 };
        typedef H263VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263VideoMode

    h263VideoMode::const_reference get_h263VideoMode () const;
    h263VideoMode::reference ref_h263VideoMode (); 
    h263VideoMode::reference select_h263VideoMode (); 
    h263VideoMode::reference select_h263VideoMode (h263VideoMode::const_reference value); 
    bool h263VideoMode_isSelected() const;

    class is11172VideoMode {
      public:
        enum Id { id_ = 4 };
        typedef IS11172VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class is11172VideoMode

    is11172VideoMode::const_reference get_is11172VideoMode () const;
    is11172VideoMode::reference ref_is11172VideoMode (); 
    is11172VideoMode::reference select_is11172VideoMode (); 
    is11172VideoMode::reference select_is11172VideoMode (is11172VideoMode::const_reference value); 
    bool is11172VideoMode_isSelected() const;

    class genericVideoMode {
      public:
        enum Id { id_ = 5 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericVideoMode

    genericVideoMode::const_reference get_genericVideoMode () const;
    genericVideoMode::reference ref_genericVideoMode (); 
    genericVideoMode::reference select_genericVideoMode (); 
    genericVideoMode::reference select_genericVideoMode (genericVideoMode::const_reference value); 
    bool genericVideoMode_isSelected() const;

    VideoMode(nonStandard::Id id, nonStandard::const_reference value);
    VideoMode(h261VideoMode::Id id, h261VideoMode::const_reference value);
    VideoMode(h262VideoMode::Id id, h262VideoMode::const_reference value);
    VideoMode(h263VideoMode::Id id, h263VideoMode::const_reference value);
    VideoMode(is11172VideoMode::Id id, is11172VideoMode::const_reference value);
    VideoMode(genericVideoMode::Id id, genericVideoMode::const_reference value);
    void swap(VideoMode & other);
    VideoMode(const VideoMode & other)
    : Inherited(other) {} 

    VideoMode & operator = (const VideoMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    VideoMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[6];
    static const char* selectionNames[6];
};

//
// H235Mode_mediaMode
//

class H235Mode_mediaMode : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H235Mode_mediaMode(const void* info) : Inherited(info) {}
  public:
    H235Mode_mediaMode() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class videoMode {
      public:
        enum Id { id_ = 1 };
        typedef VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoMode

    videoMode::const_reference get_videoMode () const;
    videoMode::reference ref_videoMode (); 
    videoMode::reference select_videoMode (); 
    videoMode::reference select_videoMode (videoMode::const_reference value); 
    bool videoMode_isSelected() const;

    class audioMode {
      public:
        enum Id { id_ = 2 };
        typedef AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioMode

    audioMode::const_reference get_audioMode () const;
    audioMode::reference ref_audioMode (); 
    audioMode::reference select_audioMode (); 
    audioMode::reference select_audioMode (audioMode::const_reference value); 
    bool audioMode_isSelected() const;

    class dataMode {
      public:
        enum Id { id_ = 3 };
        typedef DataMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataMode

    dataMode::const_reference get_dataMode () const;
    dataMode::reference ref_dataMode (); 
    dataMode::reference select_dataMode (); 
    dataMode::reference select_dataMode (dataMode::const_reference value); 
    bool dataMode_isSelected() const;

    H235Mode_mediaMode(nonStandard::Id id, nonStandard::const_reference value);
    H235Mode_mediaMode(videoMode::Id id, videoMode::const_reference value);
    H235Mode_mediaMode(audioMode::Id id, audioMode::const_reference value);
    H235Mode_mediaMode(dataMode::Id id, dataMode::const_reference value);
    void swap(H235Mode_mediaMode & other);
    H235Mode_mediaMode(const H235Mode_mediaMode & other)
    : Inherited(other) {} 

    H235Mode_mediaMode & operator = (const H235Mode_mediaMode & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    H235Mode_mediaMode * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

//
// MultiplexCapability
//

class MultiplexCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplexCapability(const void* info) : Inherited(info) {}
  public:
    MultiplexCapability() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class h222Capability {
      public:
        enum Id { id_ = 1 };
        typedef H222Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h222Capability

    h222Capability::const_reference get_h222Capability () const;
    h222Capability::reference ref_h222Capability (); 
    h222Capability::reference select_h222Capability (); 
    h222Capability::reference select_h222Capability (h222Capability::const_reference value); 
    bool h222Capability_isSelected() const;

    class h223Capability {
      public:
        enum Id { id_ = 2 };
        typedef H223Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223Capability

    h223Capability::const_reference get_h223Capability () const;
    h223Capability::reference ref_h223Capability (); 
    h223Capability::reference select_h223Capability (); 
    h223Capability::reference select_h223Capability (h223Capability::const_reference value); 
    bool h223Capability_isSelected() const;

    class v76Capability {
      public:
        enum Id { id_ = 3 };
        typedef V76Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v76Capability

    v76Capability::const_reference get_v76Capability () const;
    v76Capability::reference ref_v76Capability (); 
    v76Capability::reference select_v76Capability (); 
    v76Capability::reference select_v76Capability (v76Capability::const_reference value); 
    bool v76Capability_isSelected() const;

    class h2250Capability {
      public:
        enum Id { id_ = 4 };
        typedef H2250Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250Capability

    h2250Capability::const_reference get_h2250Capability () const;
    h2250Capability::reference ref_h2250Capability (); 
    h2250Capability::reference select_h2250Capability (); 
    h2250Capability::reference select_h2250Capability (h2250Capability::const_reference value); 
    bool h2250Capability_isSelected() const;

    class genericMultiplexCapability {
      public:
        enum Id { id_ = 5 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericMultiplexCapability

    genericMultiplexCapability::const_reference get_genericMultiplexCapability () const;
    genericMultiplexCapability::reference ref_genericMultiplexCapability (); 
    genericMultiplexCapability::reference select_genericMultiplexCapability (); 
    genericMultiplexCapability::reference select_genericMultiplexCapability (genericMultiplexCapability::const_reference value); 
    bool genericMultiplexCapability_isSelected() const;

    MultiplexCapability(nonStandard::Id id, nonStandard::const_reference value);
    MultiplexCapability(h222Capability::Id id, h222Capability::const_reference value);
    MultiplexCapability(h223Capability::Id id, h223Capability::const_reference value);
    MultiplexCapability(v76Capability::Id id, v76Capability::const_reference value);
    MultiplexCapability(h2250Capability::Id id, h2250Capability::const_reference value);
    MultiplexCapability(genericMultiplexCapability::Id id, genericMultiplexCapability::const_reference value);
    void swap(MultiplexCapability & other);
    MultiplexCapability(const MultiplexCapability & other)
    : Inherited(other) {} 

    MultiplexCapability & operator = (const MultiplexCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultiplexCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[6];
    static const char* selectionNames[6];
};

//
// VideoCapability
//

class ExtendedVideoCapability;

class VideoCapability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    VideoCapability(const void* info) : Inherited(info) {}
  public:
    VideoCapability() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class h261VideoCapability {
      public:
        enum Id { id_ = 1 };
        typedef H261VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h261VideoCapability

    h261VideoCapability::const_reference get_h261VideoCapability () const;
    h261VideoCapability::reference ref_h261VideoCapability (); 
    h261VideoCapability::reference select_h261VideoCapability (); 
    h261VideoCapability::reference select_h261VideoCapability (h261VideoCapability::const_reference value); 
    bool h261VideoCapability_isSelected() const;

    class h262VideoCapability {
      public:
        enum Id { id_ = 2 };
        typedef H262VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h262VideoCapability

    h262VideoCapability::const_reference get_h262VideoCapability () const;
    h262VideoCapability::reference ref_h262VideoCapability (); 
    h262VideoCapability::reference select_h262VideoCapability (); 
    h262VideoCapability::reference select_h262VideoCapability (h262VideoCapability::const_reference value); 
    bool h262VideoCapability_isSelected() const;

    class h263VideoCapability {
      public:
        enum Id { id_ = 3 };
        typedef H263VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h263VideoCapability

    h263VideoCapability::const_reference get_h263VideoCapability () const;
    h263VideoCapability::reference ref_h263VideoCapability (); 
    h263VideoCapability::reference select_h263VideoCapability (); 
    h263VideoCapability::reference select_h263VideoCapability (h263VideoCapability::const_reference value); 
    bool h263VideoCapability_isSelected() const;

    class is11172VideoCapability {
      public:
        enum Id { id_ = 4 };
        typedef IS11172VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class is11172VideoCapability

    is11172VideoCapability::const_reference get_is11172VideoCapability () const;
    is11172VideoCapability::reference ref_is11172VideoCapability (); 
    is11172VideoCapability::reference select_is11172VideoCapability (); 
    is11172VideoCapability::reference select_is11172VideoCapability (is11172VideoCapability::const_reference value); 
    bool is11172VideoCapability_isSelected() const;

    class genericVideoCapability {
      public:
        enum Id { id_ = 5 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericVideoCapability

    genericVideoCapability::const_reference get_genericVideoCapability () const;
    genericVideoCapability::reference ref_genericVideoCapability (); 
    genericVideoCapability::reference select_genericVideoCapability (); 
    genericVideoCapability::reference select_genericVideoCapability (genericVideoCapability::const_reference value); 
    bool genericVideoCapability_isSelected() const;

    class extendedVideoCapability {
      public:
        enum Id { id_ = 6 };
        typedef ExtendedVideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class extendedVideoCapability

    extendedVideoCapability::const_reference get_extendedVideoCapability () const;
    extendedVideoCapability::reference ref_extendedVideoCapability (); 
    extendedVideoCapability::reference select_extendedVideoCapability (); 
    extendedVideoCapability::reference select_extendedVideoCapability (extendedVideoCapability::const_reference value); 
    bool extendedVideoCapability_isSelected() const;

    VideoCapability(nonStandard::Id id, nonStandard::const_reference value);
    VideoCapability(h261VideoCapability::Id id, h261VideoCapability::const_reference value);
    VideoCapability(h262VideoCapability::Id id, h262VideoCapability::const_reference value);
    VideoCapability(h263VideoCapability::Id id, h263VideoCapability::const_reference value);
    VideoCapability(is11172VideoCapability::Id id, is11172VideoCapability::const_reference value);
    VideoCapability(genericVideoCapability::Id id, genericVideoCapability::const_reference value);
    VideoCapability(extendedVideoCapability::Id id, extendedVideoCapability::const_reference value);
    void swap(VideoCapability & other);
    VideoCapability(const VideoCapability & other)
    : Inherited(other) {} 

    VideoCapability & operator = (const VideoCapability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    VideoCapability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[7];
    static const char* selectionNames[7];
};

//
// ExtendedVideoCapability
//

class ExtendedVideoCapability : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ExtendedVideoCapability(const void* info) : Inherited(info) {}
  public:
    ExtendedVideoCapability() : Inherited(&theInfo) {}
    ExtendedVideoCapability(const ExtendedVideoCapability & other) : Inherited(other)
    {}
    ExtendedVideoCapability& operator = (const ExtendedVideoCapability& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_videoCapabilityExtension
    };

    class videoCapability {
      public:
        typedef ASN1::SEQUENCE_OF<VideoCapability>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoCapability
    videoCapability::const_reference get_videoCapability () const;
    videoCapability::reference ref_videoCapability ();
    videoCapability::reference set_videoCapability ();
    videoCapability::reference set_videoCapability (videoCapability::const_reference value);
    class videoCapabilityExtension {
      public:
        typedef ASN1::SEQUENCE_OF<GenericCapability>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoCapabilityExtension
    videoCapabilityExtension::const_reference get_videoCapabilityExtension () const;
    videoCapabilityExtension::reference ref_videoCapabilityExtension ();
    videoCapabilityExtension::reference set_videoCapabilityExtension ();
    videoCapabilityExtension::reference set_videoCapabilityExtension (videoCapabilityExtension::const_reference value);
    void omit_videoCapabilityExtension ();
    bool videoCapabilityExtension_isPresent () const;
    void swap(ExtendedVideoCapability& other);
    ExtendedVideoCapability * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// DataType
//

class DataType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    DataType(const void* info) : Inherited(info) {}
  public:
    DataType() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class nullData {
      public:
        enum Id { id_ = 1 };
        typedef ASN1::Null value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nullData

    nullData::reference select_nullData (); 
    bool nullData_isSelected() const;

    class videoData {
      public:
        enum Id { id_ = 2 };
        typedef VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoData

    videoData::const_reference get_videoData () const;
    videoData::reference ref_videoData (); 
    videoData::reference select_videoData (); 
    videoData::reference select_videoData (videoData::const_reference value); 
    bool videoData_isSelected() const;

    class audioData {
      public:
        enum Id { id_ = 3 };
        typedef AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioData

    audioData::const_reference get_audioData () const;
    audioData::reference ref_audioData (); 
    audioData::reference select_audioData (); 
    audioData::reference select_audioData (audioData::const_reference value); 
    bool audioData_isSelected() const;

    class data {
      public:
        enum Id { id_ = 4 };
        typedef DataApplicationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class data

    data::const_reference get_data () const;
    data::reference ref_data (); 
    data::reference select_data (); 
    data::reference select_data (data::const_reference value); 
    bool data_isSelected() const;

    class encryptionData {
      public:
        enum Id { id_ = 5 };
        typedef EncryptionMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionData

    encryptionData::const_reference get_encryptionData () const;
    encryptionData::reference ref_encryptionData (); 
    encryptionData::reference select_encryptionData (); 
    encryptionData::reference select_encryptionData (encryptionData::const_reference value); 
    bool encryptionData_isSelected() const;

    class h235Control {
      public:
        enum Id { id_ = 6 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h235Control

    h235Control::const_reference get_h235Control () const;
    h235Control::reference ref_h235Control (); 
    h235Control::reference select_h235Control (); 
    h235Control::reference select_h235Control (h235Control::const_reference value); 
    bool h235Control_isSelected() const;

    class multiplexedStream {
      public:
        enum Id { id_ = 7 };
        typedef MultiplexedStreamParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexedStream

    multiplexedStream::const_reference get_multiplexedStream () const;
    multiplexedStream::reference ref_multiplexedStream (); 
    multiplexedStream::reference select_multiplexedStream (); 
    multiplexedStream::reference select_multiplexedStream (multiplexedStream::const_reference value); 
    bool multiplexedStream_isSelected() const;

    class redundancyEncoding {
      public:
        enum Id { id_ = 8 };
        typedef RedundancyEncoding value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncoding

    redundancyEncoding::const_reference get_redundancyEncoding () const;
    redundancyEncoding::reference ref_redundancyEncoding (); 
    redundancyEncoding::reference select_redundancyEncoding (); 
    redundancyEncoding::reference select_redundancyEncoding (redundancyEncoding::const_reference value); 
    bool redundancyEncoding_isSelected() const;

    class multiplePayloadStream {
      public:
        enum Id { id_ = 9 };
        typedef MultiplePayloadStream value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplePayloadStream

    multiplePayloadStream::const_reference get_multiplePayloadStream () const;
    multiplePayloadStream::reference ref_multiplePayloadStream (); 
    multiplePayloadStream::reference select_multiplePayloadStream (); 
    multiplePayloadStream::reference select_multiplePayloadStream (multiplePayloadStream::const_reference value); 
    bool multiplePayloadStream_isSelected() const;

    class depFec {
      public:
        enum Id { id_ = 10 };
        typedef DepFECData value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class depFec

    depFec::const_reference get_depFec () const;
    depFec::reference ref_depFec (); 
    depFec::reference select_depFec (); 
    depFec::reference select_depFec (depFec::const_reference value); 
    bool depFec_isSelected() const;

    class fec {
      public:
        enum Id { id_ = 11 };
        typedef FECData value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fec

    fec::const_reference get_fec () const;
    fec::reference ref_fec (); 
    fec::reference select_fec (); 
    fec::reference select_fec (fec::const_reference value); 
    bool fec_isSelected() const;

    DataType(nonStandard::Id id, nonStandard::const_reference value);
    DataType(nullData::Id id, nullData::const_reference value);
    DataType(videoData::Id id, videoData::const_reference value);
    DataType(audioData::Id id, audioData::const_reference value);
    DataType(data::Id id, data::const_reference value);
    DataType(encryptionData::Id id, encryptionData::const_reference value);
    DataType(h235Control::Id id, h235Control::const_reference value);
    DataType(multiplexedStream::Id id, multiplexedStream::const_reference value);
    DataType(redundancyEncoding::Id id, redundancyEncoding::const_reference value);
    DataType(multiplePayloadStream::Id id, multiplePayloadStream::const_reference value);
    DataType(depFec::Id id, depFec::const_reference value);
    DataType(fec::Id id, fec::const_reference value);
    void swap(DataType & other);
    DataType(const DataType & other)
    : Inherited(other) {} 

    DataType & operator = (const DataType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    DataType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[12];
    static const char* selectionNames[12];
};

//
// H235Mode
//

class H235Mode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    H235Mode(const void* info) : Inherited(info) {}
  public:
    H235Mode() : Inherited(&theInfo) {}
    H235Mode(const H235Mode & other) : Inherited(other)
    {}
    H235Mode& operator = (const H235Mode& other)
    { Inherited::operator = (other); return *this; } 
    class encryptionAuthenticationAndIntegrity {
      public:
        typedef EncryptionAuthenticationAndIntegrity value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionAuthenticationAndIntegrity
    encryptionAuthenticationAndIntegrity::const_reference get_encryptionAuthenticationAndIntegrity () const;
    encryptionAuthenticationAndIntegrity::reference ref_encryptionAuthenticationAndIntegrity ();
    encryptionAuthenticationAndIntegrity::reference set_encryptionAuthenticationAndIntegrity ();
    encryptionAuthenticationAndIntegrity::reference set_encryptionAuthenticationAndIntegrity (encryptionAuthenticationAndIntegrity::const_reference value);
    class mediaMode {
      public:
        typedef H235Mode_mediaMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaMode
    mediaMode::const_reference get_mediaMode () const;
    mediaMode::reference ref_mediaMode ();
    mediaMode::reference set_mediaMode ();
    mediaMode::reference set_mediaMode (mediaMode::const_reference value);
    void swap(H235Mode& other);
    H235Mode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// OpenLogicalChannel_forwardLogicalChannelParameters
//

class OpenLogicalChannel_forwardLogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannel_forwardLogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannel_forwardLogicalChannelParameters() : Inherited(&theInfo) {}
    OpenLogicalChannel_forwardLogicalChannelParameters(const OpenLogicalChannel_forwardLogicalChannelParameters & other) : Inherited(other)
    {}
    OpenLogicalChannel_forwardLogicalChannelParameters& operator = (const OpenLogicalChannel_forwardLogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_portNumber,
      e_forwardLogicalChannelDependency,
      e_replacementFor
    };

    class portNumber {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 65535>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class portNumber
    portNumber::const_reference get_portNumber () const;
    portNumber::reference ref_portNumber ();
    portNumber::reference set_portNumber ();
    portNumber::reference set_portNumber (portNumber::value_type::int_type value);
    void omit_portNumber ();
    bool portNumber_isPresent () const;
    class dataType {
      public:
        typedef DataType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataType
    dataType::const_reference get_dataType () const;
    dataType::reference ref_dataType ();
    dataType::reference set_dataType ();
    dataType::reference set_dataType (dataType::const_reference value);
    class multiplexParameters {
      public:
        typedef OpenLogicalChannel_forwardLogicalChannelParameters_multiplexParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexParameters
    multiplexParameters::const_reference get_multiplexParameters () const;
    multiplexParameters::reference ref_multiplexParameters ();
    multiplexParameters::reference set_multiplexParameters ();
    multiplexParameters::reference set_multiplexParameters (multiplexParameters::const_reference value);
    class forwardLogicalChannelDependency {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelDependency
    forwardLogicalChannelDependency::const_reference get_forwardLogicalChannelDependency () const;
    forwardLogicalChannelDependency::reference ref_forwardLogicalChannelDependency ();
    forwardLogicalChannelDependency::reference set_forwardLogicalChannelDependency ();
    forwardLogicalChannelDependency::reference set_forwardLogicalChannelDependency (forwardLogicalChannelDependency::value_type::int_type value);
    void omit_forwardLogicalChannelDependency ();
    bool forwardLogicalChannelDependency_isPresent () const;
    class replacementFor {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class replacementFor
    replacementFor::const_reference get_replacementFor () const;
    replacementFor::reference ref_replacementFor ();
    replacementFor::reference set_replacementFor ();
    replacementFor::reference set_replacementFor (replacementFor::value_type::int_type value);
    void omit_replacementFor ();
    bool replacementFor_isPresent () const;
    void swap(OpenLogicalChannel_forwardLogicalChannelParameters& other);
    OpenLogicalChannel_forwardLogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[5];
    static int fieldIds[5];
    static const char* fieldNames[5];
};

//
// OpenLogicalChannel_reverseLogicalChannelParameters
//

class OpenLogicalChannel_reverseLogicalChannelParameters : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannel_reverseLogicalChannelParameters(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannel_reverseLogicalChannelParameters() : Inherited(&theInfo) {}
    OpenLogicalChannel_reverseLogicalChannelParameters(const OpenLogicalChannel_reverseLogicalChannelParameters & other) : Inherited(other)
    {}
    OpenLogicalChannel_reverseLogicalChannelParameters& operator = (const OpenLogicalChannel_reverseLogicalChannelParameters& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_multiplexParameters,
      e_reverseLogicalChannelDependency,
      e_replacementFor
    };

    class dataType {
      public:
        typedef DataType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataType
    dataType::const_reference get_dataType () const;
    dataType::reference ref_dataType ();
    dataType::reference set_dataType ();
    dataType::reference set_dataType (dataType::const_reference value);
    class multiplexParameters {
      public:
        typedef OpenLogicalChannel_reverseLogicalChannelParameters_multiplexParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexParameters
    multiplexParameters::const_reference get_multiplexParameters () const;
    multiplexParameters::reference ref_multiplexParameters ();
    multiplexParameters::reference set_multiplexParameters ();
    multiplexParameters::reference set_multiplexParameters (multiplexParameters::const_reference value);
    void omit_multiplexParameters ();
    bool multiplexParameters_isPresent () const;
    class reverseLogicalChannelDependency {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reverseLogicalChannelDependency
    reverseLogicalChannelDependency::const_reference get_reverseLogicalChannelDependency () const;
    reverseLogicalChannelDependency::reference ref_reverseLogicalChannelDependency ();
    reverseLogicalChannelDependency::reference set_reverseLogicalChannelDependency ();
    reverseLogicalChannelDependency::reference set_reverseLogicalChannelDependency (reverseLogicalChannelDependency::value_type::int_type value);
    void omit_reverseLogicalChannelDependency ();
    bool reverseLogicalChannelDependency_isPresent () const;
    class replacementFor {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class replacementFor
    replacementFor::const_reference get_replacementFor () const;
    replacementFor::reference ref_replacementFor ();
    replacementFor::reference set_replacementFor ();
    replacementFor::reference set_replacementFor (replacementFor::value_type::int_type value);
    void omit_replacementFor ();
    bool replacementFor_isPresent () const;
    void swap(OpenLogicalChannel_reverseLogicalChannelParameters& other);
    OpenLogicalChannel_reverseLogicalChannelParameters * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[4];
    static int fieldIds[4];
    static const char* fieldNames[4];
};

//
// RedundancyEncodingDTModeElement_type
//

class RedundancyEncodingDTModeElement_type : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingDTModeElement_type(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingDTModeElement_type() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class videoMode {
      public:
        enum Id { id_ = 1 };
        typedef VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoMode

    videoMode::const_reference get_videoMode () const;
    videoMode::reference ref_videoMode (); 
    videoMode::reference select_videoMode (); 
    videoMode::reference select_videoMode (videoMode::const_reference value); 
    bool videoMode_isSelected() const;

    class audioMode {
      public:
        enum Id { id_ = 2 };
        typedef AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioMode

    audioMode::const_reference get_audioMode () const;
    audioMode::reference ref_audioMode (); 
    audioMode::reference select_audioMode (); 
    audioMode::reference select_audioMode (audioMode::const_reference value); 
    bool audioMode_isSelected() const;

    class dataMode {
      public:
        enum Id { id_ = 3 };
        typedef DataMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataMode

    dataMode::const_reference get_dataMode () const;
    dataMode::reference ref_dataMode (); 
    dataMode::reference select_dataMode (); 
    dataMode::reference select_dataMode (dataMode::const_reference value); 
    bool dataMode_isSelected() const;

    class encryptionMode {
      public:
        enum Id { id_ = 4 };
        typedef EncryptionMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionMode

    encryptionMode::const_reference get_encryptionMode () const;
    encryptionMode::reference ref_encryptionMode (); 
    encryptionMode::reference select_encryptionMode (); 
    encryptionMode::reference select_encryptionMode (encryptionMode::const_reference value); 
    bool encryptionMode_isSelected() const;

    class h235Mode {
      public:
        enum Id { id_ = 5 };
        typedef H235Mode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h235Mode

    h235Mode::const_reference get_h235Mode () const;
    h235Mode::reference ref_h235Mode (); 
    h235Mode::reference select_h235Mode (); 
    h235Mode::reference select_h235Mode (h235Mode::const_reference value); 
    bool h235Mode_isSelected() const;

    class fecMode {
      public:
        enum Id { id_ = 6 };
        typedef FECMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fecMode

    fecMode::const_reference get_fecMode () const;
    fecMode::reference ref_fecMode (); 
    fecMode::reference select_fecMode (); 
    fecMode::reference select_fecMode (fecMode::const_reference value); 
    bool fecMode_isSelected() const;

    RedundancyEncodingDTModeElement_type(nonStandard::Id id, nonStandard::const_reference value);
    RedundancyEncodingDTModeElement_type(videoMode::Id id, videoMode::const_reference value);
    RedundancyEncodingDTModeElement_type(audioMode::Id id, audioMode::const_reference value);
    RedundancyEncodingDTModeElement_type(dataMode::Id id, dataMode::const_reference value);
    RedundancyEncodingDTModeElement_type(encryptionMode::Id id, encryptionMode::const_reference value);
    RedundancyEncodingDTModeElement_type(h235Mode::Id id, h235Mode::const_reference value);
    RedundancyEncodingDTModeElement_type(fecMode::Id id, fecMode::const_reference value);
    void swap(RedundancyEncodingDTModeElement_type & other);
    RedundancyEncodingDTModeElement_type(const RedundancyEncodingDTModeElement_type & other)
    : Inherited(other) {} 

    RedundancyEncodingDTModeElement_type & operator = (const RedundancyEncodingDTModeElement_type & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RedundancyEncodingDTModeElement_type * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[7];
    static const char* selectionNames[7];
};

//
// CommunicationModeTableEntry_dataType
//

class CommunicationModeTableEntry_dataType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CommunicationModeTableEntry_dataType(const void* info) : Inherited(info) {}
  public:
    CommunicationModeTableEntry_dataType() : Inherited(&theInfo) {}
    class videoData {
      public:
        enum Id { id_ = 0 };
        typedef VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoData

    videoData::const_reference get_videoData () const;
    videoData::reference ref_videoData (); 
    videoData::reference select_videoData (); 
    videoData::reference select_videoData (videoData::const_reference value); 
    bool videoData_isSelected() const;

    class audioData {
      public:
        enum Id { id_ = 1 };
        typedef AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioData

    audioData::const_reference get_audioData () const;
    audioData::reference ref_audioData (); 
    audioData::reference select_audioData (); 
    audioData::reference select_audioData (audioData::const_reference value); 
    bool audioData_isSelected() const;

    class data {
      public:
        enum Id { id_ = 2 };
        typedef DataApplicationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class data

    data::const_reference get_data () const;
    data::reference ref_data (); 
    data::reference select_data (); 
    data::reference select_data (data::const_reference value); 
    bool data_isSelected() const;

    CommunicationModeTableEntry_dataType(videoData::Id id, videoData::const_reference value);
    CommunicationModeTableEntry_dataType(audioData::Id id, audioData::const_reference value);
    CommunicationModeTableEntry_dataType(data::Id id, data::const_reference value);
    void swap(CommunicationModeTableEntry_dataType & other);
    CommunicationModeTableEntry_dataType(const CommunicationModeTableEntry_dataType & other)
    : Inherited(other) {} 

    CommunicationModeTableEntry_dataType & operator = (const CommunicationModeTableEntry_dataType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CommunicationModeTableEntry_dataType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// Capability
//

class Capability : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    Capability(const void* info) : Inherited(info) {}
  public:
    Capability() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class receiveVideoCapability {
      public:
        enum Id { id_ = 1 };
        typedef VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveVideoCapability

    receiveVideoCapability::const_reference get_receiveVideoCapability () const;
    receiveVideoCapability::reference ref_receiveVideoCapability (); 
    receiveVideoCapability::reference select_receiveVideoCapability (); 
    receiveVideoCapability::reference select_receiveVideoCapability (receiveVideoCapability::const_reference value); 
    bool receiveVideoCapability_isSelected() const;

    class transmitVideoCapability {
      public:
        enum Id { id_ = 2 };
        typedef VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitVideoCapability

    transmitVideoCapability::const_reference get_transmitVideoCapability () const;
    transmitVideoCapability::reference ref_transmitVideoCapability (); 
    transmitVideoCapability::reference select_transmitVideoCapability (); 
    transmitVideoCapability::reference select_transmitVideoCapability (transmitVideoCapability::const_reference value); 
    bool transmitVideoCapability_isSelected() const;

    class receiveAndTransmitVideoCapability {
      public:
        enum Id { id_ = 3 };
        typedef VideoCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAndTransmitVideoCapability

    receiveAndTransmitVideoCapability::const_reference get_receiveAndTransmitVideoCapability () const;
    receiveAndTransmitVideoCapability::reference ref_receiveAndTransmitVideoCapability (); 
    receiveAndTransmitVideoCapability::reference select_receiveAndTransmitVideoCapability (); 
    receiveAndTransmitVideoCapability::reference select_receiveAndTransmitVideoCapability (receiveAndTransmitVideoCapability::const_reference value); 
    bool receiveAndTransmitVideoCapability_isSelected() const;

    class receiveAudioCapability {
      public:
        enum Id { id_ = 4 };
        typedef AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAudioCapability

    receiveAudioCapability::const_reference get_receiveAudioCapability () const;
    receiveAudioCapability::reference ref_receiveAudioCapability (); 
    receiveAudioCapability::reference select_receiveAudioCapability (); 
    receiveAudioCapability::reference select_receiveAudioCapability (receiveAudioCapability::const_reference value); 
    bool receiveAudioCapability_isSelected() const;

    class transmitAudioCapability {
      public:
        enum Id { id_ = 5 };
        typedef AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitAudioCapability

    transmitAudioCapability::const_reference get_transmitAudioCapability () const;
    transmitAudioCapability::reference ref_transmitAudioCapability (); 
    transmitAudioCapability::reference select_transmitAudioCapability (); 
    transmitAudioCapability::reference select_transmitAudioCapability (transmitAudioCapability::const_reference value); 
    bool transmitAudioCapability_isSelected() const;

    class receiveAndTransmitAudioCapability {
      public:
        enum Id { id_ = 6 };
        typedef AudioCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAndTransmitAudioCapability

    receiveAndTransmitAudioCapability::const_reference get_receiveAndTransmitAudioCapability () const;
    receiveAndTransmitAudioCapability::reference ref_receiveAndTransmitAudioCapability (); 
    receiveAndTransmitAudioCapability::reference select_receiveAndTransmitAudioCapability (); 
    receiveAndTransmitAudioCapability::reference select_receiveAndTransmitAudioCapability (receiveAndTransmitAudioCapability::const_reference value); 
    bool receiveAndTransmitAudioCapability_isSelected() const;

    class receiveDataApplicationCapability {
      public:
        enum Id { id_ = 7 };
        typedef DataApplicationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveDataApplicationCapability

    receiveDataApplicationCapability::const_reference get_receiveDataApplicationCapability () const;
    receiveDataApplicationCapability::reference ref_receiveDataApplicationCapability (); 
    receiveDataApplicationCapability::reference select_receiveDataApplicationCapability (); 
    receiveDataApplicationCapability::reference select_receiveDataApplicationCapability (receiveDataApplicationCapability::const_reference value); 
    bool receiveDataApplicationCapability_isSelected() const;

    class transmitDataApplicationCapability {
      public:
        enum Id { id_ = 8 };
        typedef DataApplicationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitDataApplicationCapability

    transmitDataApplicationCapability::const_reference get_transmitDataApplicationCapability () const;
    transmitDataApplicationCapability::reference ref_transmitDataApplicationCapability (); 
    transmitDataApplicationCapability::reference select_transmitDataApplicationCapability (); 
    transmitDataApplicationCapability::reference select_transmitDataApplicationCapability (transmitDataApplicationCapability::const_reference value); 
    bool transmitDataApplicationCapability_isSelected() const;

    class receiveAndTransmitDataApplicationCapability {
      public:
        enum Id { id_ = 9 };
        typedef DataApplicationCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAndTransmitDataApplicationCapability

    receiveAndTransmitDataApplicationCapability::const_reference get_receiveAndTransmitDataApplicationCapability () const;
    receiveAndTransmitDataApplicationCapability::reference ref_receiveAndTransmitDataApplicationCapability (); 
    receiveAndTransmitDataApplicationCapability::reference select_receiveAndTransmitDataApplicationCapability (); 
    receiveAndTransmitDataApplicationCapability::reference select_receiveAndTransmitDataApplicationCapability (receiveAndTransmitDataApplicationCapability::const_reference value); 
    bool receiveAndTransmitDataApplicationCapability_isSelected() const;

    class h233EncryptionTransmitCapability {
      public:
        enum Id { id_ = 10 };
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h233EncryptionTransmitCapability

    h233EncryptionTransmitCapability::const_reference get_h233EncryptionTransmitCapability () const;
    h233EncryptionTransmitCapability::reference ref_h233EncryptionTransmitCapability (); 
    h233EncryptionTransmitCapability::reference select_h233EncryptionTransmitCapability (); 
    h233EncryptionTransmitCapability::reference select_h233EncryptionTransmitCapability (bool value); 
    bool h233EncryptionTransmitCapability_isSelected() const;

    class h233EncryptionReceiveCapability {
      public:
        enum Id { id_ = 11 };
        typedef Capability_h233EncryptionReceiveCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h233EncryptionReceiveCapability

    h233EncryptionReceiveCapability::const_reference get_h233EncryptionReceiveCapability () const;
    h233EncryptionReceiveCapability::reference ref_h233EncryptionReceiveCapability (); 
    h233EncryptionReceiveCapability::reference select_h233EncryptionReceiveCapability (); 
    h233EncryptionReceiveCapability::reference select_h233EncryptionReceiveCapability (h233EncryptionReceiveCapability::const_reference value); 
    bool h233EncryptionReceiveCapability_isSelected() const;

    class conferenceCapability {
      public:
        enum Id { id_ = 12 };
        typedef ConferenceCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceCapability

    conferenceCapability::const_reference get_conferenceCapability () const;
    conferenceCapability::reference ref_conferenceCapability (); 
    conferenceCapability::reference select_conferenceCapability (); 
    conferenceCapability::reference select_conferenceCapability (conferenceCapability::const_reference value); 
    bool conferenceCapability_isSelected() const;

    class h235SecurityCapability {
      public:
        enum Id { id_ = 13 };
        typedef H235SecurityCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h235SecurityCapability

    h235SecurityCapability::const_reference get_h235SecurityCapability () const;
    h235SecurityCapability::reference ref_h235SecurityCapability (); 
    h235SecurityCapability::reference select_h235SecurityCapability (); 
    h235SecurityCapability::reference select_h235SecurityCapability (h235SecurityCapability::const_reference value); 
    bool h235SecurityCapability_isSelected() const;

    class maxPendingReplacementFor {
      public:
        enum Id { id_ = 14 };
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 0, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maxPendingReplacementFor

    maxPendingReplacementFor::const_reference get_maxPendingReplacementFor () const;
    maxPendingReplacementFor::reference ref_maxPendingReplacementFor (); 
    maxPendingReplacementFor::reference select_maxPendingReplacementFor (); 
    maxPendingReplacementFor::reference select_maxPendingReplacementFor (maxPendingReplacementFor::value_type::int_type value); 
    bool maxPendingReplacementFor_isSelected() const;

    class receiveUserInputCapability {
      public:
        enum Id { id_ = 15 };
        typedef UserInputCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveUserInputCapability

    receiveUserInputCapability::const_reference get_receiveUserInputCapability () const;
    receiveUserInputCapability::reference ref_receiveUserInputCapability (); 
    receiveUserInputCapability::reference select_receiveUserInputCapability (); 
    receiveUserInputCapability::reference select_receiveUserInputCapability (receiveUserInputCapability::const_reference value); 
    bool receiveUserInputCapability_isSelected() const;

    class transmitUserInputCapability {
      public:
        enum Id { id_ = 16 };
        typedef UserInputCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitUserInputCapability

    transmitUserInputCapability::const_reference get_transmitUserInputCapability () const;
    transmitUserInputCapability::reference ref_transmitUserInputCapability (); 
    transmitUserInputCapability::reference select_transmitUserInputCapability (); 
    transmitUserInputCapability::reference select_transmitUserInputCapability (transmitUserInputCapability::const_reference value); 
    bool transmitUserInputCapability_isSelected() const;

    class receiveAndTransmitUserInputCapability {
      public:
        enum Id { id_ = 17 };
        typedef UserInputCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAndTransmitUserInputCapability

    receiveAndTransmitUserInputCapability::const_reference get_receiveAndTransmitUserInputCapability () const;
    receiveAndTransmitUserInputCapability::reference ref_receiveAndTransmitUserInputCapability (); 
    receiveAndTransmitUserInputCapability::reference select_receiveAndTransmitUserInputCapability (); 
    receiveAndTransmitUserInputCapability::reference select_receiveAndTransmitUserInputCapability (receiveAndTransmitUserInputCapability::const_reference value); 
    bool receiveAndTransmitUserInputCapability_isSelected() const;

    class genericControlCapability {
      public:
        enum Id { id_ = 18 };
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericControlCapability

    genericControlCapability::const_reference get_genericControlCapability () const;
    genericControlCapability::reference ref_genericControlCapability (); 
    genericControlCapability::reference select_genericControlCapability (); 
    genericControlCapability::reference select_genericControlCapability (genericControlCapability::const_reference value); 
    bool genericControlCapability_isSelected() const;

    class receiveMultiplexedStreamCapability {
      public:
        enum Id { id_ = 19 };
        typedef MultiplexedStreamCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveMultiplexedStreamCapability

    receiveMultiplexedStreamCapability::const_reference get_receiveMultiplexedStreamCapability () const;
    receiveMultiplexedStreamCapability::reference ref_receiveMultiplexedStreamCapability (); 
    receiveMultiplexedStreamCapability::reference select_receiveMultiplexedStreamCapability (); 
    receiveMultiplexedStreamCapability::reference select_receiveMultiplexedStreamCapability (receiveMultiplexedStreamCapability::const_reference value); 
    bool receiveMultiplexedStreamCapability_isSelected() const;

    class transmitMultiplexedStreamCapability {
      public:
        enum Id { id_ = 20 };
        typedef MultiplexedStreamCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class transmitMultiplexedStreamCapability

    transmitMultiplexedStreamCapability::const_reference get_transmitMultiplexedStreamCapability () const;
    transmitMultiplexedStreamCapability::reference ref_transmitMultiplexedStreamCapability (); 
    transmitMultiplexedStreamCapability::reference select_transmitMultiplexedStreamCapability (); 
    transmitMultiplexedStreamCapability::reference select_transmitMultiplexedStreamCapability (transmitMultiplexedStreamCapability::const_reference value); 
    bool transmitMultiplexedStreamCapability_isSelected() const;

    class receiveAndTransmitMultiplexedStreamCapability {
      public:
        enum Id { id_ = 21 };
        typedef MultiplexedStreamCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveAndTransmitMultiplexedStreamCapability

    receiveAndTransmitMultiplexedStreamCapability::const_reference get_receiveAndTransmitMultiplexedStreamCapability () const;
    receiveAndTransmitMultiplexedStreamCapability::reference ref_receiveAndTransmitMultiplexedStreamCapability (); 
    receiveAndTransmitMultiplexedStreamCapability::reference select_receiveAndTransmitMultiplexedStreamCapability (); 
    receiveAndTransmitMultiplexedStreamCapability::reference select_receiveAndTransmitMultiplexedStreamCapability (receiveAndTransmitMultiplexedStreamCapability::const_reference value); 
    bool receiveAndTransmitMultiplexedStreamCapability_isSelected() const;

    class receiveRTPAudioTelephonyEventCapability {
      public:
        enum Id { id_ = 22 };
        typedef AudioTelephonyEventCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveRTPAudioTelephonyEventCapability

    receiveRTPAudioTelephonyEventCapability::const_reference get_receiveRTPAudioTelephonyEventCapability () const;
    receiveRTPAudioTelephonyEventCapability::reference ref_receiveRTPAudioTelephonyEventCapability (); 
    receiveRTPAudioTelephonyEventCapability::reference select_receiveRTPAudioTelephonyEventCapability (); 
    receiveRTPAudioTelephonyEventCapability::reference select_receiveRTPAudioTelephonyEventCapability (receiveRTPAudioTelephonyEventCapability::const_reference value); 
    bool receiveRTPAudioTelephonyEventCapability_isSelected() const;

    class receiveRTPAudioToneCapability {
      public:
        enum Id { id_ = 23 };
        typedef AudioToneCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class receiveRTPAudioToneCapability

    receiveRTPAudioToneCapability::const_reference get_receiveRTPAudioToneCapability () const;
    receiveRTPAudioToneCapability::reference ref_receiveRTPAudioToneCapability (); 
    receiveRTPAudioToneCapability::reference select_receiveRTPAudioToneCapability (); 
    receiveRTPAudioToneCapability::reference select_receiveRTPAudioToneCapability (receiveRTPAudioToneCapability::const_reference value); 
    bool receiveRTPAudioToneCapability_isSelected() const;

    class depFecCapability {
      public:
        enum Id { id_ = 24 };
        typedef DepFECCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class depFecCapability

    depFecCapability::const_reference get_depFecCapability () const;
    depFecCapability::reference ref_depFecCapability (); 
    depFecCapability::reference select_depFecCapability (); 
    depFecCapability::reference select_depFecCapability (depFecCapability::const_reference value); 
    bool depFecCapability_isSelected() const;

    class multiplePayloadStreamCapability {
      public:
        enum Id { id_ = 25 };
        typedef MultiplePayloadStreamCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplePayloadStreamCapability

    multiplePayloadStreamCapability::const_reference get_multiplePayloadStreamCapability () const;
    multiplePayloadStreamCapability::reference ref_multiplePayloadStreamCapability (); 
    multiplePayloadStreamCapability::reference select_multiplePayloadStreamCapability (); 
    multiplePayloadStreamCapability::reference select_multiplePayloadStreamCapability (multiplePayloadStreamCapability::const_reference value); 
    bool multiplePayloadStreamCapability_isSelected() const;

    class fecCapability {
      public:
        enum Id { id_ = 26 };
        typedef FECCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fecCapability

    fecCapability::const_reference get_fecCapability () const;
    fecCapability::reference ref_fecCapability (); 
    fecCapability::reference select_fecCapability (); 
    fecCapability::reference select_fecCapability (fecCapability::const_reference value); 
    bool fecCapability_isSelected() const;

    class redundancyEncodingCap {
      public:
        enum Id { id_ = 27 };
        typedef RedundancyEncodingCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingCap

    redundancyEncodingCap::const_reference get_redundancyEncodingCap () const;
    redundancyEncodingCap::reference ref_redundancyEncodingCap (); 
    redundancyEncodingCap::reference select_redundancyEncodingCap (); 
    redundancyEncodingCap::reference select_redundancyEncodingCap (redundancyEncodingCap::const_reference value); 
    bool redundancyEncodingCap_isSelected() const;

    class oneOfCapabilities {
      public:
        enum Id { id_ = 28 };
        typedef AlternativeCapabilitySet value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class oneOfCapabilities

    oneOfCapabilities::const_reference get_oneOfCapabilities () const;
    oneOfCapabilities::reference ref_oneOfCapabilities (); 
    oneOfCapabilities::reference select_oneOfCapabilities (); 
    oneOfCapabilities::reference select_oneOfCapabilities (oneOfCapabilities::const_reference value); 
    bool oneOfCapabilities_isSelected() const;

    Capability(nonStandard::Id id, nonStandard::const_reference value);
    Capability(receiveVideoCapability::Id id, receiveVideoCapability::const_reference value);
    Capability(transmitVideoCapability::Id id, transmitVideoCapability::const_reference value);
    Capability(receiveAndTransmitVideoCapability::Id id, receiveAndTransmitVideoCapability::const_reference value);
    Capability(receiveAudioCapability::Id id, receiveAudioCapability::const_reference value);
    Capability(transmitAudioCapability::Id id, transmitAudioCapability::const_reference value);
    Capability(receiveAndTransmitAudioCapability::Id id, receiveAndTransmitAudioCapability::const_reference value);
    Capability(receiveDataApplicationCapability::Id id, receiveDataApplicationCapability::const_reference value);
    Capability(transmitDataApplicationCapability::Id id, transmitDataApplicationCapability::const_reference value);
    Capability(receiveAndTransmitDataApplicationCapability::Id id, receiveAndTransmitDataApplicationCapability::const_reference value);
    Capability(h233EncryptionTransmitCapability::Id id, bool value);
    Capability(h233EncryptionReceiveCapability::Id id, h233EncryptionReceiveCapability::const_reference value);
    Capability(conferenceCapability::Id id, conferenceCapability::const_reference value);
    Capability(h235SecurityCapability::Id id, h235SecurityCapability::const_reference value);
    Capability(maxPendingReplacementFor::Id id, maxPendingReplacementFor::value_type::int_type value);
    Capability(receiveUserInputCapability::Id id, receiveUserInputCapability::const_reference value);
    Capability(transmitUserInputCapability::Id id, transmitUserInputCapability::const_reference value);
    Capability(receiveAndTransmitUserInputCapability::Id id, receiveAndTransmitUserInputCapability::const_reference value);
    Capability(genericControlCapability::Id id, genericControlCapability::const_reference value);
    Capability(receiveMultiplexedStreamCapability::Id id, receiveMultiplexedStreamCapability::const_reference value);
    Capability(transmitMultiplexedStreamCapability::Id id, transmitMultiplexedStreamCapability::const_reference value);
    Capability(receiveAndTransmitMultiplexedStreamCapability::Id id, receiveAndTransmitMultiplexedStreamCapability::const_reference value);
    Capability(receiveRTPAudioTelephonyEventCapability::Id id, receiveRTPAudioTelephonyEventCapability::const_reference value);
    Capability(receiveRTPAudioToneCapability::Id id, receiveRTPAudioToneCapability::const_reference value);
    Capability(depFecCapability::Id id, depFecCapability::const_reference value);
    Capability(multiplePayloadStreamCapability::Id id, multiplePayloadStreamCapability::const_reference value);
    Capability(fecCapability::Id id, fecCapability::const_reference value);
    Capability(redundancyEncodingCap::Id id, redundancyEncodingCap::const_reference value);
    Capability(oneOfCapabilities::Id id, oneOfCapabilities::const_reference value);
    void swap(Capability & other);
    Capability(const Capability & other)
    : Inherited(other) {} 

    Capability & operator = (const Capability & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    Capability * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[29];
    static const char* selectionNames[29];
};

//
// OpenLogicalChannel
//

class OpenLogicalChannel : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    OpenLogicalChannel(const void* info) : Inherited(info) {}
  public:
    OpenLogicalChannel() : Inherited(&theInfo) {}
    OpenLogicalChannel(const OpenLogicalChannel & other) : Inherited(other)
    {}
    OpenLogicalChannel& operator = (const OpenLogicalChannel& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_reverseLogicalChannelParameters,
      e_separateStack,
      e_encryptionSync,
      e_genericInformation
    };

    class forwardLogicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelNumber
    forwardLogicalChannelNumber::const_reference get_forwardLogicalChannelNumber () const;
    forwardLogicalChannelNumber::reference ref_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber ();
    forwardLogicalChannelNumber::reference set_forwardLogicalChannelNumber (forwardLogicalChannelNumber::value_type::int_type value);
    class forwardLogicalChannelParameters {
      public:
        typedef OpenLogicalChannel_forwardLogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class forwardLogicalChannelParameters
    forwardLogicalChannelParameters::const_reference get_forwardLogicalChannelParameters () const;
    forwardLogicalChannelParameters::reference ref_forwardLogicalChannelParameters ();
    forwardLogicalChannelParameters::reference set_forwardLogicalChannelParameters ();
    forwardLogicalChannelParameters::reference set_forwardLogicalChannelParameters (forwardLogicalChannelParameters::const_reference value);
    class reverseLogicalChannelParameters {
      public:
        typedef OpenLogicalChannel_reverseLogicalChannelParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class reverseLogicalChannelParameters
    reverseLogicalChannelParameters::const_reference get_reverseLogicalChannelParameters () const;
    reverseLogicalChannelParameters::reference ref_reverseLogicalChannelParameters ();
    reverseLogicalChannelParameters::reference set_reverseLogicalChannelParameters ();
    reverseLogicalChannelParameters::reference set_reverseLogicalChannelParameters (reverseLogicalChannelParameters::const_reference value);
    void omit_reverseLogicalChannelParameters ();
    bool reverseLogicalChannelParameters_isPresent () const;
    class separateStack {
      public:
        typedef NetworkAccessParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class separateStack
    separateStack::const_reference get_separateStack () const;
    separateStack::reference ref_separateStack ();
    separateStack::reference set_separateStack ();
    separateStack::reference set_separateStack (separateStack::const_reference value);
    void omit_separateStack ();
    bool separateStack_isPresent () const;
    class encryptionSync {
      public:
        typedef EncryptionSync value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionSync
    encryptionSync::const_reference get_encryptionSync () const;
    encryptionSync::reference ref_encryptionSync ();
    encryptionSync::reference set_encryptionSync ();
    encryptionSync::reference set_encryptionSync (encryptionSync::const_reference value);
    void omit_encryptionSync ();
    bool encryptionSync_isPresent () const;
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(OpenLogicalChannel& other);
    OpenLogicalChannel * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// RedundancyEncodingDTModeElement
//

class RedundancyEncodingDTModeElement : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingDTModeElement(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingDTModeElement() : Inherited(&theInfo) {}
    RedundancyEncodingDTModeElement(const RedundancyEncodingDTModeElement & other) : Inherited(other)
    {}
    RedundancyEncodingDTModeElement& operator = (const RedundancyEncodingDTModeElement& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef RedundancyEncodingDTModeElement_type value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(RedundancyEncodingDTModeElement& other);
    RedundancyEncodingDTModeElement * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// CommunicationModeTableEntry
//

class CommunicationModeTableEntry : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CommunicationModeTableEntry(const void* info) : Inherited(info) {}
  public:
    CommunicationModeTableEntry() : Inherited(&theInfo) {}
    CommunicationModeTableEntry(const CommunicationModeTableEntry & other) : Inherited(other)
    {}
    CommunicationModeTableEntry& operator = (const CommunicationModeTableEntry& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_nonStandard,
      e_associatedSessionID,
      e_terminalLabel,
      e_mediaChannel,
      e_mediaGuaranteedDelivery,
      e_mediaControlChannel,
      e_mediaControlGuaranteedDelivery,
      e_redundancyEncoding,
      e_sessionDependency,
      e_destination
    };

    class nonStandard {
      public:
        typedef ASN1::SEQUENCE_OF<NonStandardParameter>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard
    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard ();
    nonStandard::reference set_nonStandard ();
    nonStandard::reference set_nonStandard (nonStandard::const_reference value);
    void omit_nonStandard ();
    bool nonStandard_isPresent () const;
    class sessionID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sessionID
    sessionID::const_reference get_sessionID () const;
    sessionID::reference ref_sessionID ();
    sessionID::reference set_sessionID ();
    sessionID::reference set_sessionID (sessionID::value_type::int_type value);
    class associatedSessionID {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class associatedSessionID
    associatedSessionID::const_reference get_associatedSessionID () const;
    associatedSessionID::reference ref_associatedSessionID ();
    associatedSessionID::reference set_associatedSessionID ();
    associatedSessionID::reference set_associatedSessionID (associatedSessionID::value_type::int_type value);
    void omit_associatedSessionID ();
    bool associatedSessionID_isPresent () const;
    class terminalLabel {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalLabel
    terminalLabel::const_reference get_terminalLabel () const;
    terminalLabel::reference ref_terminalLabel ();
    terminalLabel::reference set_terminalLabel ();
    terminalLabel::reference set_terminalLabel (terminalLabel::const_reference value);
    void omit_terminalLabel ();
    bool terminalLabel_isPresent () const;
    class sessionDescription {
      public:
        class value_type : public ASN1::BMPString
        {
            typedef ASN1::BMPString Inherited;
          protected:
            typedef Inherited::InfoType InfoType;
            value_type(const void* info) : Inherited(info) {}
          public:
            value_type() : Inherited(&theInfo) { }
            value_type(const base_string& str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const wchar_t* str, const void* info = &theInfo) : Inherited(str, info) { }
            value_type(const value_type& other) : Inherited(other) {}
            value_type& operator = (const std::wstring& other)
            { Inherited::operator=(other); return *this;}
            value_type& operator = (const wchar_t* other)
            { Inherited::operator=(other); return *this;}
            value_type * clone() const;
            static bool equal_type(const ASN1::AbstractData&);
            static const InfoType theInfo;
        };

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sessionDescription
    sessionDescription::const_reference get_sessionDescription () const;
    sessionDescription::reference ref_sessionDescription ();
    sessionDescription::reference set_sessionDescription ();
    sessionDescription::reference set_sessionDescription (const std::wstring& value);
    class dataType {
      public:
        typedef CommunicationModeTableEntry_dataType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataType
    dataType::const_reference get_dataType () const;
    dataType::reference ref_dataType ();
    dataType::reference set_dataType ();
    dataType::reference set_dataType (dataType::const_reference value);
    class mediaChannel {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaChannel
    mediaChannel::const_reference get_mediaChannel () const;
    mediaChannel::reference ref_mediaChannel ();
    mediaChannel::reference set_mediaChannel ();
    mediaChannel::reference set_mediaChannel (mediaChannel::const_reference value);
    void omit_mediaChannel ();
    bool mediaChannel_isPresent () const;
    class mediaGuaranteedDelivery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaGuaranteedDelivery
    mediaGuaranteedDelivery::const_reference get_mediaGuaranteedDelivery () const;
    mediaGuaranteedDelivery::reference ref_mediaGuaranteedDelivery ();
    mediaGuaranteedDelivery::reference set_mediaGuaranteedDelivery ();
    mediaGuaranteedDelivery::reference set_mediaGuaranteedDelivery (bool value);
    void omit_mediaGuaranteedDelivery ();
    bool mediaGuaranteedDelivery_isPresent () const;
    class mediaControlChannel {
      public:
        typedef TransportAddress value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaControlChannel
    mediaControlChannel::const_reference get_mediaControlChannel () const;
    mediaControlChannel::reference ref_mediaControlChannel ();
    mediaControlChannel::reference set_mediaControlChannel ();
    mediaControlChannel::reference set_mediaControlChannel (mediaControlChannel::const_reference value);
    void omit_mediaControlChannel ();
    bool mediaControlChannel_isPresent () const;
    class mediaControlGuaranteedDelivery {
      public:
        typedef ASN1::BOOLEAN value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mediaControlGuaranteedDelivery
    mediaControlGuaranteedDelivery::const_reference get_mediaControlGuaranteedDelivery () const;
    mediaControlGuaranteedDelivery::reference ref_mediaControlGuaranteedDelivery ();
    mediaControlGuaranteedDelivery::reference set_mediaControlGuaranteedDelivery ();
    mediaControlGuaranteedDelivery::reference set_mediaControlGuaranteedDelivery (bool value);
    void omit_mediaControlGuaranteedDelivery ();
    bool mediaControlGuaranteedDelivery_isPresent () const;
    class redundancyEncoding {
      public:
        typedef RedundancyEncoding value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncoding
    redundancyEncoding::const_reference get_redundancyEncoding () const;
    redundancyEncoding::reference ref_redundancyEncoding ();
    redundancyEncoding::reference set_redundancyEncoding ();
    redundancyEncoding::reference set_redundancyEncoding (redundancyEncoding::const_reference value);
    void omit_redundancyEncoding ();
    bool redundancyEncoding_isPresent () const;
    class sessionDependency {
      public:
        typedef ASN1::Constrained_INTEGER<ASN1::FixedConstraint, 1, 255>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sessionDependency
    sessionDependency::const_reference get_sessionDependency () const;
    sessionDependency::reference ref_sessionDependency ();
    sessionDependency::reference set_sessionDependency ();
    sessionDependency::reference set_sessionDependency (sessionDependency::value_type::int_type value);
    void omit_sessionDependency ();
    bool sessionDependency_isPresent () const;
    class destination {
      public:
        typedef TerminalLabel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class destination
    destination::const_reference get_destination () const;
    destination::reference ref_destination ();
    destination::reference set_destination ();
    destination::reference set_destination (destination::const_reference value);
    void omit_destination ();
    bool destination_isPresent () const;
    void swap(CommunicationModeTableEntry& other);
    CommunicationModeTableEntry * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[13];
    static int fieldIds[13];
    static const char* fieldNames[13];
};

//
// CapabilityTableEntry
//

class CapabilityTableEntry : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CapabilityTableEntry(const void* info) : Inherited(info) {}
  public:
    CapabilityTableEntry() : Inherited(&theInfo) {}
    CapabilityTableEntry(const CapabilityTableEntry & other) : Inherited(other)
    {}
    CapabilityTableEntry& operator = (const CapabilityTableEntry& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_capability
    };

    class capabilityTableEntryNumber {
      public:
        typedef CapabilityTableEntryNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityTableEntryNumber
    capabilityTableEntryNumber::const_reference get_capabilityTableEntryNumber () const;
    capabilityTableEntryNumber::reference ref_capabilityTableEntryNumber ();
    capabilityTableEntryNumber::reference set_capabilityTableEntryNumber ();
    capabilityTableEntryNumber::reference set_capabilityTableEntryNumber (capabilityTableEntryNumber::value_type::int_type value);
    class capability {
      public:
        typedef Capability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capability
    capability::const_reference get_capability () const;
    capability::reference ref_capability ();
    capability::reference set_capability ();
    capability::reference set_capability (capability::const_reference value);
    void omit_capability ();
    bool capability_isPresent () const;
    void swap(CapabilityTableEntry& other);
    CapabilityTableEntry * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RedundancyEncodingDTMode
//

class RedundancyEncodingDTMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RedundancyEncodingDTMode(const void* info) : Inherited(info) {}
  public:
    RedundancyEncodingDTMode() : Inherited(&theInfo) {}
    RedundancyEncodingDTMode(const RedundancyEncodingDTMode & other) : Inherited(other)
    {}
    RedundancyEncodingDTMode& operator = (const RedundancyEncodingDTMode& other)
    { Inherited::operator = (other); return *this; } 
    class redundancyEncodingMethod {
      public:
        typedef RedundancyEncodingMethod value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingMethod
    redundancyEncodingMethod::const_reference get_redundancyEncodingMethod () const;
    redundancyEncodingMethod::reference ref_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod ();
    redundancyEncodingMethod::reference set_redundancyEncodingMethod (redundancyEncodingMethod::const_reference value);
    class primary {
      public:
        typedef RedundancyEncodingDTModeElement value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class primary
    primary::const_reference get_primary () const;
    primary::reference ref_primary ();
    primary::reference set_primary ();
    primary::reference set_primary (primary::const_reference value);
    class secondary {
      public:
        typedef ASN1::SEQUENCE_OF<RedundancyEncodingDTModeElement>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class secondary
    secondary::const_reference get_secondary () const;
    secondary::reference ref_secondary ();
    secondary::reference set_secondary ();
    secondary::reference set_secondary (secondary::const_reference value);
    void swap(RedundancyEncodingDTMode& other);
    RedundancyEncodingDTMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[3];
    static int fieldIds[3];
    static const char* fieldNames[3];
};

//
// CommunicationModeCommand
//

class CommunicationModeCommand : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CommunicationModeCommand(const void* info) : Inherited(info) {}
  public:
    CommunicationModeCommand() : Inherited(&theInfo) {}
    CommunicationModeCommand(const CommunicationModeCommand & other) : Inherited(other)
    {}
    CommunicationModeCommand& operator = (const CommunicationModeCommand& other)
    { Inherited::operator = (other); return *this; } 
    class communicationModeTable {
      public:
        typedef ASN1::SET_OF<CommunicationModeTableEntry,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class communicationModeTable
    communicationModeTable::const_reference get_communicationModeTable () const;
    communicationModeTable::reference ref_communicationModeTable ();
    communicationModeTable::reference set_communicationModeTable ();
    communicationModeTable::reference set_communicationModeTable (communicationModeTable::const_reference value);
    void swap(CommunicationModeCommand& other);
    CommunicationModeCommand * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// CommunicationModeResponse
//

class CommunicationModeResponse : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CommunicationModeResponse(const void* info) : Inherited(info) {}
  public:
    CommunicationModeResponse() : Inherited(&theInfo) {}
    class communicationModeTable {
      public:
        enum Id { id_ = 0 };
        typedef ASN1::SET_OF<CommunicationModeTableEntry,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class communicationModeTable

    communicationModeTable::const_reference get_communicationModeTable () const;
    communicationModeTable::reference ref_communicationModeTable (); 
    communicationModeTable::reference select_communicationModeTable (); 
    communicationModeTable::reference select_communicationModeTable (communicationModeTable::const_reference value); 
    bool communicationModeTable_isSelected() const;

    CommunicationModeResponse(communicationModeTable::Id id, communicationModeTable::const_reference value);
    void swap(CommunicationModeResponse & other);
    CommunicationModeResponse(const CommunicationModeResponse & other)
    : Inherited(other) {} 

    CommunicationModeResponse & operator = (const CommunicationModeResponse & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CommunicationModeResponse * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[1];
    static const char* selectionNames[1];
};

//
// ResponseMessage
//

class ResponseMessage : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ResponseMessage(const void* info) : Inherited(info) {}
  public:
    ResponseMessage() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class masterSlaveDeterminationAck {
      public:
        enum Id { id_ = 1 };
        typedef MasterSlaveDeterminationAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterSlaveDeterminationAck

    masterSlaveDeterminationAck::const_reference get_masterSlaveDeterminationAck () const;
    masterSlaveDeterminationAck::reference ref_masterSlaveDeterminationAck (); 
    masterSlaveDeterminationAck::reference select_masterSlaveDeterminationAck (); 
    masterSlaveDeterminationAck::reference select_masterSlaveDeterminationAck (masterSlaveDeterminationAck::const_reference value); 
    bool masterSlaveDeterminationAck_isSelected() const;

    class masterSlaveDeterminationReject {
      public:
        enum Id { id_ = 2 };
        typedef MasterSlaveDeterminationReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterSlaveDeterminationReject

    masterSlaveDeterminationReject::const_reference get_masterSlaveDeterminationReject () const;
    masterSlaveDeterminationReject::reference ref_masterSlaveDeterminationReject (); 
    masterSlaveDeterminationReject::reference select_masterSlaveDeterminationReject (); 
    masterSlaveDeterminationReject::reference select_masterSlaveDeterminationReject (masterSlaveDeterminationReject::const_reference value); 
    bool masterSlaveDeterminationReject_isSelected() const;

    class terminalCapabilitySetAck {
      public:
        enum Id { id_ = 3 };
        typedef TerminalCapabilitySetAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalCapabilitySetAck

    terminalCapabilitySetAck::const_reference get_terminalCapabilitySetAck () const;
    terminalCapabilitySetAck::reference ref_terminalCapabilitySetAck (); 
    terminalCapabilitySetAck::reference select_terminalCapabilitySetAck (); 
    terminalCapabilitySetAck::reference select_terminalCapabilitySetAck (terminalCapabilitySetAck::const_reference value); 
    bool terminalCapabilitySetAck_isSelected() const;

    class terminalCapabilitySetReject {
      public:
        enum Id { id_ = 4 };
        typedef TerminalCapabilitySetReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalCapabilitySetReject

    terminalCapabilitySetReject::const_reference get_terminalCapabilitySetReject () const;
    terminalCapabilitySetReject::reference ref_terminalCapabilitySetReject (); 
    terminalCapabilitySetReject::reference select_terminalCapabilitySetReject (); 
    terminalCapabilitySetReject::reference select_terminalCapabilitySetReject (terminalCapabilitySetReject::const_reference value); 
    bool terminalCapabilitySetReject_isSelected() const;

    class openLogicalChannelAck {
      public:
        enum Id { id_ = 5 };
        typedef OpenLogicalChannelAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class openLogicalChannelAck

    openLogicalChannelAck::const_reference get_openLogicalChannelAck () const;
    openLogicalChannelAck::reference ref_openLogicalChannelAck (); 
    openLogicalChannelAck::reference select_openLogicalChannelAck (); 
    openLogicalChannelAck::reference select_openLogicalChannelAck (openLogicalChannelAck::const_reference value); 
    bool openLogicalChannelAck_isSelected() const;

    class openLogicalChannelReject {
      public:
        enum Id { id_ = 6 };
        typedef OpenLogicalChannelReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class openLogicalChannelReject

    openLogicalChannelReject::const_reference get_openLogicalChannelReject () const;
    openLogicalChannelReject::reference ref_openLogicalChannelReject (); 
    openLogicalChannelReject::reference select_openLogicalChannelReject (); 
    openLogicalChannelReject::reference select_openLogicalChannelReject (openLogicalChannelReject::const_reference value); 
    bool openLogicalChannelReject_isSelected() const;

    class closeLogicalChannelAck {
      public:
        enum Id { id_ = 7 };
        typedef CloseLogicalChannelAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class closeLogicalChannelAck

    closeLogicalChannelAck::const_reference get_closeLogicalChannelAck () const;
    closeLogicalChannelAck::reference ref_closeLogicalChannelAck (); 
    closeLogicalChannelAck::reference select_closeLogicalChannelAck (); 
    closeLogicalChannelAck::reference select_closeLogicalChannelAck (closeLogicalChannelAck::const_reference value); 
    bool closeLogicalChannelAck_isSelected() const;

    class requestChannelCloseAck {
      public:
        enum Id { id_ = 8 };
        typedef RequestChannelCloseAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestChannelCloseAck

    requestChannelCloseAck::const_reference get_requestChannelCloseAck () const;
    requestChannelCloseAck::reference ref_requestChannelCloseAck (); 
    requestChannelCloseAck::reference select_requestChannelCloseAck (); 
    requestChannelCloseAck::reference select_requestChannelCloseAck (requestChannelCloseAck::const_reference value); 
    bool requestChannelCloseAck_isSelected() const;

    class requestChannelCloseReject {
      public:
        enum Id { id_ = 9 };
        typedef RequestChannelCloseReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestChannelCloseReject

    requestChannelCloseReject::const_reference get_requestChannelCloseReject () const;
    requestChannelCloseReject::reference ref_requestChannelCloseReject (); 
    requestChannelCloseReject::reference select_requestChannelCloseReject (); 
    requestChannelCloseReject::reference select_requestChannelCloseReject (requestChannelCloseReject::const_reference value); 
    bool requestChannelCloseReject_isSelected() const;

    class multiplexEntrySendAck {
      public:
        enum Id { id_ = 10 };
        typedef MultiplexEntrySendAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexEntrySendAck

    multiplexEntrySendAck::const_reference get_multiplexEntrySendAck () const;
    multiplexEntrySendAck::reference ref_multiplexEntrySendAck (); 
    multiplexEntrySendAck::reference select_multiplexEntrySendAck (); 
    multiplexEntrySendAck::reference select_multiplexEntrySendAck (multiplexEntrySendAck::const_reference value); 
    bool multiplexEntrySendAck_isSelected() const;

    class multiplexEntrySendReject {
      public:
        enum Id { id_ = 11 };
        typedef MultiplexEntrySendReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexEntrySendReject

    multiplexEntrySendReject::const_reference get_multiplexEntrySendReject () const;
    multiplexEntrySendReject::reference ref_multiplexEntrySendReject (); 
    multiplexEntrySendReject::reference select_multiplexEntrySendReject (); 
    multiplexEntrySendReject::reference select_multiplexEntrySendReject (multiplexEntrySendReject::const_reference value); 
    bool multiplexEntrySendReject_isSelected() const;

    class requestMultiplexEntryAck {
      public:
        enum Id { id_ = 12 };
        typedef RequestMultiplexEntryAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestMultiplexEntryAck

    requestMultiplexEntryAck::const_reference get_requestMultiplexEntryAck () const;
    requestMultiplexEntryAck::reference ref_requestMultiplexEntryAck (); 
    requestMultiplexEntryAck::reference select_requestMultiplexEntryAck (); 
    requestMultiplexEntryAck::reference select_requestMultiplexEntryAck (requestMultiplexEntryAck::const_reference value); 
    bool requestMultiplexEntryAck_isSelected() const;

    class requestMultiplexEntryReject {
      public:
        enum Id { id_ = 13 };
        typedef RequestMultiplexEntryReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestMultiplexEntryReject

    requestMultiplexEntryReject::const_reference get_requestMultiplexEntryReject () const;
    requestMultiplexEntryReject::reference ref_requestMultiplexEntryReject (); 
    requestMultiplexEntryReject::reference select_requestMultiplexEntryReject (); 
    requestMultiplexEntryReject::reference select_requestMultiplexEntryReject (requestMultiplexEntryReject::const_reference value); 
    bool requestMultiplexEntryReject_isSelected() const;

    class requestModeAck {
      public:
        enum Id { id_ = 14 };
        typedef RequestModeAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestModeAck

    requestModeAck::const_reference get_requestModeAck () const;
    requestModeAck::reference ref_requestModeAck (); 
    requestModeAck::reference select_requestModeAck (); 
    requestModeAck::reference select_requestModeAck (requestModeAck::const_reference value); 
    bool requestModeAck_isSelected() const;

    class requestModeReject {
      public:
        enum Id { id_ = 15 };
        typedef RequestModeReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestModeReject

    requestModeReject::const_reference get_requestModeReject () const;
    requestModeReject::reference ref_requestModeReject (); 
    requestModeReject::reference select_requestModeReject (); 
    requestModeReject::reference select_requestModeReject (requestModeReject::const_reference value); 
    bool requestModeReject_isSelected() const;

    class roundTripDelayResponse {
      public:
        enum Id { id_ = 16 };
        typedef RoundTripDelayResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class roundTripDelayResponse

    roundTripDelayResponse::const_reference get_roundTripDelayResponse () const;
    roundTripDelayResponse::reference ref_roundTripDelayResponse (); 
    roundTripDelayResponse::reference select_roundTripDelayResponse (); 
    roundTripDelayResponse::reference select_roundTripDelayResponse (roundTripDelayResponse::const_reference value); 
    bool roundTripDelayResponse_isSelected() const;

    class maintenanceLoopAck {
      public:
        enum Id { id_ = 17 };
        typedef MaintenanceLoopAck value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maintenanceLoopAck

    maintenanceLoopAck::const_reference get_maintenanceLoopAck () const;
    maintenanceLoopAck::reference ref_maintenanceLoopAck (); 
    maintenanceLoopAck::reference select_maintenanceLoopAck (); 
    maintenanceLoopAck::reference select_maintenanceLoopAck (maintenanceLoopAck::const_reference value); 
    bool maintenanceLoopAck_isSelected() const;

    class maintenanceLoopReject {
      public:
        enum Id { id_ = 18 };
        typedef MaintenanceLoopReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maintenanceLoopReject

    maintenanceLoopReject::const_reference get_maintenanceLoopReject () const;
    maintenanceLoopReject::reference ref_maintenanceLoopReject (); 
    maintenanceLoopReject::reference select_maintenanceLoopReject (); 
    maintenanceLoopReject::reference select_maintenanceLoopReject (maintenanceLoopReject::const_reference value); 
    bool maintenanceLoopReject_isSelected() const;

    class communicationModeResponse {
      public:
        enum Id { id_ = 19 };
        typedef CommunicationModeResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class communicationModeResponse

    communicationModeResponse::const_reference get_communicationModeResponse () const;
    communicationModeResponse::reference ref_communicationModeResponse (); 
    communicationModeResponse::reference select_communicationModeResponse (); 
    communicationModeResponse::reference select_communicationModeResponse (communicationModeResponse::const_reference value); 
    bool communicationModeResponse_isSelected() const;

    class conferenceResponse {
      public:
        enum Id { id_ = 20 };
        typedef ConferenceResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceResponse

    conferenceResponse::const_reference get_conferenceResponse () const;
    conferenceResponse::reference ref_conferenceResponse (); 
    conferenceResponse::reference select_conferenceResponse (); 
    conferenceResponse::reference select_conferenceResponse (conferenceResponse::const_reference value); 
    bool conferenceResponse_isSelected() const;

    class multilinkResponse {
      public:
        enum Id { id_ = 21 };
        typedef MultilinkResponse value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multilinkResponse

    multilinkResponse::const_reference get_multilinkResponse () const;
    multilinkResponse::reference ref_multilinkResponse (); 
    multilinkResponse::reference select_multilinkResponse (); 
    multilinkResponse::reference select_multilinkResponse (multilinkResponse::const_reference value); 
    bool multilinkResponse_isSelected() const;

    class logicalChannelRateAcknowledge {
      public:
        enum Id { id_ = 22 };
        typedef LogicalChannelRateAcknowledge value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelRateAcknowledge

    logicalChannelRateAcknowledge::const_reference get_logicalChannelRateAcknowledge () const;
    logicalChannelRateAcknowledge::reference ref_logicalChannelRateAcknowledge (); 
    logicalChannelRateAcknowledge::reference select_logicalChannelRateAcknowledge (); 
    logicalChannelRateAcknowledge::reference select_logicalChannelRateAcknowledge (logicalChannelRateAcknowledge::const_reference value); 
    bool logicalChannelRateAcknowledge_isSelected() const;

    class logicalChannelRateReject {
      public:
        enum Id { id_ = 23 };
        typedef LogicalChannelRateReject value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelRateReject

    logicalChannelRateReject::const_reference get_logicalChannelRateReject () const;
    logicalChannelRateReject::reference ref_logicalChannelRateReject (); 
    logicalChannelRateReject::reference select_logicalChannelRateReject (); 
    logicalChannelRateReject::reference select_logicalChannelRateReject (logicalChannelRateReject::const_reference value); 
    bool logicalChannelRateReject_isSelected() const;

    class genericResponse {
      public:
        enum Id { id_ = 24 };
        typedef GenericMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericResponse

    genericResponse::const_reference get_genericResponse () const;
    genericResponse::reference ref_genericResponse (); 
    genericResponse::reference select_genericResponse (); 
    genericResponse::reference select_genericResponse (genericResponse::const_reference value); 
    bool genericResponse_isSelected() const;

    ResponseMessage(nonStandard::Id id, nonStandard::const_reference value);
    ResponseMessage(masterSlaveDeterminationAck::Id id, masterSlaveDeterminationAck::const_reference value);
    ResponseMessage(masterSlaveDeterminationReject::Id id, masterSlaveDeterminationReject::const_reference value);
    ResponseMessage(terminalCapabilitySetAck::Id id, terminalCapabilitySetAck::const_reference value);
    ResponseMessage(terminalCapabilitySetReject::Id id, terminalCapabilitySetReject::const_reference value);
    ResponseMessage(openLogicalChannelAck::Id id, openLogicalChannelAck::const_reference value);
    ResponseMessage(openLogicalChannelReject::Id id, openLogicalChannelReject::const_reference value);
    ResponseMessage(closeLogicalChannelAck::Id id, closeLogicalChannelAck::const_reference value);
    ResponseMessage(requestChannelCloseAck::Id id, requestChannelCloseAck::const_reference value);
    ResponseMessage(requestChannelCloseReject::Id id, requestChannelCloseReject::const_reference value);
    ResponseMessage(multiplexEntrySendAck::Id id, multiplexEntrySendAck::const_reference value);
    ResponseMessage(multiplexEntrySendReject::Id id, multiplexEntrySendReject::const_reference value);
    ResponseMessage(requestMultiplexEntryAck::Id id, requestMultiplexEntryAck::const_reference value);
    ResponseMessage(requestMultiplexEntryReject::Id id, requestMultiplexEntryReject::const_reference value);
    ResponseMessage(requestModeAck::Id id, requestModeAck::const_reference value);
    ResponseMessage(requestModeReject::Id id, requestModeReject::const_reference value);
    ResponseMessage(roundTripDelayResponse::Id id, roundTripDelayResponse::const_reference value);
    ResponseMessage(maintenanceLoopAck::Id id, maintenanceLoopAck::const_reference value);
    ResponseMessage(maintenanceLoopReject::Id id, maintenanceLoopReject::const_reference value);
    ResponseMessage(communicationModeResponse::Id id, communicationModeResponse::const_reference value);
    ResponseMessage(conferenceResponse::Id id, conferenceResponse::const_reference value);
    ResponseMessage(multilinkResponse::Id id, multilinkResponse::const_reference value);
    ResponseMessage(logicalChannelRateAcknowledge::Id id, logicalChannelRateAcknowledge::const_reference value);
    ResponseMessage(logicalChannelRateReject::Id id, logicalChannelRateReject::const_reference value);
    ResponseMessage(genericResponse::Id id, genericResponse::const_reference value);
    void swap(ResponseMessage & other);
    ResponseMessage(const ResponseMessage & other)
    : Inherited(other) {} 

    ResponseMessage & operator = (const ResponseMessage & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ResponseMessage * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[25];
    static const char* selectionNames[25];
};

//
// CommandMessage
//

class CommandMessage : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    CommandMessage(const void* info) : Inherited(info) {}
  public:
    CommandMessage() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class maintenanceLoopOffCommand {
      public:
        enum Id { id_ = 1 };
        typedef MaintenanceLoopOffCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maintenanceLoopOffCommand

    maintenanceLoopOffCommand::const_reference get_maintenanceLoopOffCommand () const;
    maintenanceLoopOffCommand::reference ref_maintenanceLoopOffCommand (); 
    maintenanceLoopOffCommand::reference select_maintenanceLoopOffCommand (); 
    maintenanceLoopOffCommand::reference select_maintenanceLoopOffCommand (maintenanceLoopOffCommand::const_reference value); 
    bool maintenanceLoopOffCommand_isSelected() const;

    class sendTerminalCapabilitySet {
      public:
        enum Id { id_ = 2 };
        typedef SendTerminalCapabilitySet value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sendTerminalCapabilitySet

    sendTerminalCapabilitySet::const_reference get_sendTerminalCapabilitySet () const;
    sendTerminalCapabilitySet::reference ref_sendTerminalCapabilitySet (); 
    sendTerminalCapabilitySet::reference select_sendTerminalCapabilitySet (); 
    sendTerminalCapabilitySet::reference select_sendTerminalCapabilitySet (sendTerminalCapabilitySet::const_reference value); 
    bool sendTerminalCapabilitySet_isSelected() const;

    class encryptionCommand {
      public:
        enum Id { id_ = 3 };
        typedef EncryptionCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionCommand

    encryptionCommand::const_reference get_encryptionCommand () const;
    encryptionCommand::reference ref_encryptionCommand (); 
    encryptionCommand::reference select_encryptionCommand (); 
    encryptionCommand::reference select_encryptionCommand (encryptionCommand::const_reference value); 
    bool encryptionCommand_isSelected() const;

    class flowControlCommand {
      public:
        enum Id { id_ = 4 };
        typedef FlowControlCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class flowControlCommand

    flowControlCommand::const_reference get_flowControlCommand () const;
    flowControlCommand::reference ref_flowControlCommand (); 
    flowControlCommand::reference select_flowControlCommand (); 
    flowControlCommand::reference select_flowControlCommand (flowControlCommand::const_reference value); 
    bool flowControlCommand_isSelected() const;

    class endSessionCommand {
      public:
        enum Id { id_ = 5 };
        typedef EndSessionCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class endSessionCommand

    endSessionCommand::const_reference get_endSessionCommand () const;
    endSessionCommand::reference ref_endSessionCommand (); 
    endSessionCommand::reference select_endSessionCommand (); 
    endSessionCommand::reference select_endSessionCommand (endSessionCommand::const_reference value); 
    bool endSessionCommand_isSelected() const;

    class miscellaneousCommand {
      public:
        enum Id { id_ = 6 };
        typedef MiscellaneousCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class miscellaneousCommand

    miscellaneousCommand::const_reference get_miscellaneousCommand () const;
    miscellaneousCommand::reference ref_miscellaneousCommand (); 
    miscellaneousCommand::reference select_miscellaneousCommand (); 
    miscellaneousCommand::reference select_miscellaneousCommand (miscellaneousCommand::const_reference value); 
    bool miscellaneousCommand_isSelected() const;

    class communicationModeCommand {
      public:
        enum Id { id_ = 7 };
        typedef CommunicationModeCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class communicationModeCommand

    communicationModeCommand::const_reference get_communicationModeCommand () const;
    communicationModeCommand::reference ref_communicationModeCommand (); 
    communicationModeCommand::reference select_communicationModeCommand (); 
    communicationModeCommand::reference select_communicationModeCommand (communicationModeCommand::const_reference value); 
    bool communicationModeCommand_isSelected() const;

    class conferenceCommand {
      public:
        enum Id { id_ = 8 };
        typedef ConferenceCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceCommand

    conferenceCommand::const_reference get_conferenceCommand () const;
    conferenceCommand::reference ref_conferenceCommand (); 
    conferenceCommand::reference select_conferenceCommand (); 
    conferenceCommand::reference select_conferenceCommand (conferenceCommand::const_reference value); 
    bool conferenceCommand_isSelected() const;

    class h223MultiplexReconfiguration {
      public:
        enum Id { id_ = 9 };
        typedef H223MultiplexReconfiguration value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223MultiplexReconfiguration

    h223MultiplexReconfiguration::const_reference get_h223MultiplexReconfiguration () const;
    h223MultiplexReconfiguration::reference ref_h223MultiplexReconfiguration (); 
    h223MultiplexReconfiguration::reference select_h223MultiplexReconfiguration (); 
    h223MultiplexReconfiguration::reference select_h223MultiplexReconfiguration (h223MultiplexReconfiguration::const_reference value); 
    bool h223MultiplexReconfiguration_isSelected() const;

    class newATMVCCommand {
      public:
        enum Id { id_ = 10 };
        typedef NewATMVCCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class newATMVCCommand

    newATMVCCommand::const_reference get_newATMVCCommand () const;
    newATMVCCommand::reference ref_newATMVCCommand (); 
    newATMVCCommand::reference select_newATMVCCommand (); 
    newATMVCCommand::reference select_newATMVCCommand (newATMVCCommand::const_reference value); 
    bool newATMVCCommand_isSelected() const;

    class mobileMultilinkReconfigurationCommand {
      public:
        enum Id { id_ = 11 };
        typedef MobileMultilinkReconfigurationCommand value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mobileMultilinkReconfigurationCommand

    mobileMultilinkReconfigurationCommand::const_reference get_mobileMultilinkReconfigurationCommand () const;
    mobileMultilinkReconfigurationCommand::reference ref_mobileMultilinkReconfigurationCommand (); 
    mobileMultilinkReconfigurationCommand::reference select_mobileMultilinkReconfigurationCommand (); 
    mobileMultilinkReconfigurationCommand::reference select_mobileMultilinkReconfigurationCommand (mobileMultilinkReconfigurationCommand::const_reference value); 
    bool mobileMultilinkReconfigurationCommand_isSelected() const;

    class genericCommand {
      public:
        enum Id { id_ = 12 };
        typedef GenericMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericCommand

    genericCommand::const_reference get_genericCommand () const;
    genericCommand::reference ref_genericCommand (); 
    genericCommand::reference select_genericCommand (); 
    genericCommand::reference select_genericCommand (genericCommand::const_reference value); 
    bool genericCommand_isSelected() const;

    CommandMessage(nonStandard::Id id, nonStandard::const_reference value);
    CommandMessage(maintenanceLoopOffCommand::Id id, maintenanceLoopOffCommand::const_reference value);
    CommandMessage(sendTerminalCapabilitySet::Id id, sendTerminalCapabilitySet::const_reference value);
    CommandMessage(encryptionCommand::Id id, encryptionCommand::const_reference value);
    CommandMessage(flowControlCommand::Id id, flowControlCommand::const_reference value);
    CommandMessage(endSessionCommand::Id id, endSessionCommand::const_reference value);
    CommandMessage(miscellaneousCommand::Id id, miscellaneousCommand::const_reference value);
    CommandMessage(communicationModeCommand::Id id, communicationModeCommand::const_reference value);
    CommandMessage(conferenceCommand::Id id, conferenceCommand::const_reference value);
    CommandMessage(h223MultiplexReconfiguration::Id id, h223MultiplexReconfiguration::const_reference value);
    CommandMessage(newATMVCCommand::Id id, newATMVCCommand::const_reference value);
    CommandMessage(mobileMultilinkReconfigurationCommand::Id id, mobileMultilinkReconfigurationCommand::const_reference value);
    CommandMessage(genericCommand::Id id, genericCommand::const_reference value);
    void swap(CommandMessage & other);
    CommandMessage(const CommandMessage & other)
    : Inherited(other) {} 

    CommandMessage & operator = (const CommandMessage & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    CommandMessage * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[13];
    static const char* selectionNames[13];
};

//
// TerminalCapabilitySet
//

class TerminalCapabilitySet : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    TerminalCapabilitySet(const void* info) : Inherited(info) {}
  public:
    TerminalCapabilitySet() : Inherited(&theInfo) {}
    TerminalCapabilitySet(const TerminalCapabilitySet & other) : Inherited(other)
    {}
    TerminalCapabilitySet& operator = (const TerminalCapabilitySet& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_multiplexCapability,
      e_capabilityTable,
      e_capabilityDescriptors,
      e_genericInformation
    };

    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class protocolIdentifier {
      public:
        typedef ASN1::OBJECT_IDENTIFIER value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class protocolIdentifier
    protocolIdentifier::const_reference get_protocolIdentifier () const;
    protocolIdentifier::reference ref_protocolIdentifier ();
    protocolIdentifier::reference set_protocolIdentifier ();
    protocolIdentifier::reference set_protocolIdentifier (protocolIdentifier::const_reference value);
    class multiplexCapability {
      public:
        typedef MultiplexCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexCapability
    multiplexCapability::const_reference get_multiplexCapability () const;
    multiplexCapability::reference ref_multiplexCapability ();
    multiplexCapability::reference set_multiplexCapability ();
    multiplexCapability::reference set_multiplexCapability (multiplexCapability::const_reference value);
    void omit_multiplexCapability ();
    bool multiplexCapability_isPresent () const;
    class capabilityTable {
      public:
        typedef ASN1::SET_OF<CapabilityTableEntry,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityTable
    capabilityTable::const_reference get_capabilityTable () const;
    capabilityTable::reference ref_capabilityTable ();
    capabilityTable::reference set_capabilityTable ();
    capabilityTable::reference set_capabilityTable (capabilityTable::const_reference value);
    void omit_capabilityTable ();
    bool capabilityTable_isPresent () const;
    class capabilityDescriptors {
      public:
        typedef ASN1::SET_OF<CapabilityDescriptor,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class capabilityDescriptors
    capabilityDescriptors::const_reference get_capabilityDescriptors () const;
    capabilityDescriptors::reference ref_capabilityDescriptors ();
    capabilityDescriptors::reference set_capabilityDescriptors ();
    capabilityDescriptors::reference set_capabilityDescriptors (capabilityDescriptors::const_reference value);
    void omit_capabilityDescriptors ();
    bool capabilityDescriptors_isPresent () const;
    class genericInformation {
      public:
        typedef ASN1::SEQUENCE_OF<GenericInformation>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericInformation
    genericInformation::const_reference get_genericInformation () const;
    genericInformation::reference ref_genericInformation ();
    genericInformation::reference set_genericInformation ();
    genericInformation::reference set_genericInformation (genericInformation::const_reference value);
    void omit_genericInformation ();
    bool genericInformation_isPresent () const;
    void swap(TerminalCapabilitySet& other);
    TerminalCapabilitySet * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[6];
    static int fieldIds[6];
    static const char* fieldNames[6];
};

//
// ModeElementType
//

class ModeElementType : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ModeElementType(const void* info) : Inherited(info) {}
  public:
    ModeElementType() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class videoMode {
      public:
        enum Id { id_ = 1 };
        typedef VideoMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class videoMode

    videoMode::const_reference get_videoMode () const;
    videoMode::reference ref_videoMode (); 
    videoMode::reference select_videoMode (); 
    videoMode::reference select_videoMode (videoMode::const_reference value); 
    bool videoMode_isSelected() const;

    class audioMode {
      public:
        enum Id { id_ = 2 };
        typedef AudioMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class audioMode

    audioMode::const_reference get_audioMode () const;
    audioMode::reference ref_audioMode (); 
    audioMode::reference select_audioMode (); 
    audioMode::reference select_audioMode (audioMode::const_reference value); 
    bool audioMode_isSelected() const;

    class dataMode {
      public:
        enum Id { id_ = 3 };
        typedef DataMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class dataMode

    dataMode::const_reference get_dataMode () const;
    dataMode::reference ref_dataMode (); 
    dataMode::reference select_dataMode (); 
    dataMode::reference select_dataMode (dataMode::const_reference value); 
    bool dataMode_isSelected() const;

    class encryptionMode {
      public:
        enum Id { id_ = 4 };
        typedef EncryptionMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class encryptionMode

    encryptionMode::const_reference get_encryptionMode () const;
    encryptionMode::reference ref_encryptionMode (); 
    encryptionMode::reference select_encryptionMode (); 
    encryptionMode::reference select_encryptionMode (encryptionMode::const_reference value); 
    bool encryptionMode_isSelected() const;

    class h235Mode {
      public:
        enum Id { id_ = 5 };
        typedef H235Mode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h235Mode

    h235Mode::const_reference get_h235Mode () const;
    h235Mode::reference ref_h235Mode (); 
    h235Mode::reference select_h235Mode (); 
    h235Mode::reference select_h235Mode (h235Mode::const_reference value); 
    bool h235Mode_isSelected() const;

    class multiplexedStreamMode {
      public:
        enum Id { id_ = 6 };
        typedef MultiplexedStreamParameter value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexedStreamMode

    multiplexedStreamMode::const_reference get_multiplexedStreamMode () const;
    multiplexedStreamMode::reference ref_multiplexedStreamMode (); 
    multiplexedStreamMode::reference select_multiplexedStreamMode (); 
    multiplexedStreamMode::reference select_multiplexedStreamMode (multiplexedStreamMode::const_reference value); 
    bool multiplexedStreamMode_isSelected() const;

    class redundancyEncodingDTMode {
      public:
        enum Id { id_ = 7 };
        typedef RedundancyEncodingDTMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class redundancyEncodingDTMode

    redundancyEncodingDTMode::const_reference get_redundancyEncodingDTMode () const;
    redundancyEncodingDTMode::reference ref_redundancyEncodingDTMode (); 
    redundancyEncodingDTMode::reference select_redundancyEncodingDTMode (); 
    redundancyEncodingDTMode::reference select_redundancyEncodingDTMode (redundancyEncodingDTMode::const_reference value); 
    bool redundancyEncodingDTMode_isSelected() const;

    class fecMode {
      public:
        enum Id { id_ = 8 };
        typedef FECMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class fecMode

    fecMode::const_reference get_fecMode () const;
    fecMode::reference ref_fecMode (); 
    fecMode::reference select_fecMode (); 
    fecMode::reference select_fecMode (fecMode::const_reference value); 
    bool fecMode_isSelected() const;

    ModeElementType(nonStandard::Id id, nonStandard::const_reference value);
    ModeElementType(videoMode::Id id, videoMode::const_reference value);
    ModeElementType(audioMode::Id id, audioMode::const_reference value);
    ModeElementType(dataMode::Id id, dataMode::const_reference value);
    ModeElementType(encryptionMode::Id id, encryptionMode::const_reference value);
    ModeElementType(h235Mode::Id id, h235Mode::const_reference value);
    ModeElementType(multiplexedStreamMode::Id id, multiplexedStreamMode::const_reference value);
    ModeElementType(redundancyEncodingDTMode::Id id, redundancyEncodingDTMode::const_reference value);
    ModeElementType(fecMode::Id id, fecMode::const_reference value);
    void swap(ModeElementType & other);
    ModeElementType(const ModeElementType & other)
    : Inherited(other) {} 

    ModeElementType & operator = (const ModeElementType & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    ModeElementType * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[9];
    static const char* selectionNames[9];
};

//
// ModeElement
//

class ModeElement : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    ModeElement(const void* info) : Inherited(info) {}
  public:
    ModeElement() : Inherited(&theInfo) {}
    ModeElement(const ModeElement & other) : Inherited(other)
    {}
    ModeElement& operator = (const ModeElement& other)
    { Inherited::operator = (other); return *this; } 
    enum OptionalFields {
      e_h223ModeParameters,
      e_v76ModeParameters,
      e_h2250ModeParameters,
      e_genericModeParameters,
      e_multiplexedStreamModeParameters,
      e_logicalChannelNumber
    };

    class type {
      public:
        typedef ModeElementType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    class h223ModeParameters {
      public:
        typedef H223ModeParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223ModeParameters
    h223ModeParameters::const_reference get_h223ModeParameters () const;
    h223ModeParameters::reference ref_h223ModeParameters ();
    h223ModeParameters::reference set_h223ModeParameters ();
    h223ModeParameters::reference set_h223ModeParameters (h223ModeParameters::const_reference value);
    void omit_h223ModeParameters ();
    bool h223ModeParameters_isPresent () const;
    class v76ModeParameters {
      public:
        typedef V76ModeParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class v76ModeParameters
    v76ModeParameters::const_reference get_v76ModeParameters () const;
    v76ModeParameters::reference ref_v76ModeParameters ();
    v76ModeParameters::reference set_v76ModeParameters ();
    v76ModeParameters::reference set_v76ModeParameters (v76ModeParameters::const_reference value);
    void omit_v76ModeParameters ();
    bool v76ModeParameters_isPresent () const;
    class h2250ModeParameters {
      public:
        typedef H2250ModeParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250ModeParameters
    h2250ModeParameters::const_reference get_h2250ModeParameters () const;
    h2250ModeParameters::reference ref_h2250ModeParameters ();
    h2250ModeParameters::reference set_h2250ModeParameters ();
    h2250ModeParameters::reference set_h2250ModeParameters (h2250ModeParameters::const_reference value);
    void omit_h2250ModeParameters ();
    bool h2250ModeParameters_isPresent () const;
    class genericModeParameters {
      public:
        typedef GenericCapability value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericModeParameters
    genericModeParameters::const_reference get_genericModeParameters () const;
    genericModeParameters::reference ref_genericModeParameters ();
    genericModeParameters::reference set_genericModeParameters ();
    genericModeParameters::reference set_genericModeParameters (genericModeParameters::const_reference value);
    void omit_genericModeParameters ();
    bool genericModeParameters_isPresent () const;
    class multiplexedStreamModeParameters {
      public:
        typedef MultiplexedStreamModeParameters value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexedStreamModeParameters
    multiplexedStreamModeParameters::const_reference get_multiplexedStreamModeParameters () const;
    multiplexedStreamModeParameters::reference ref_multiplexedStreamModeParameters ();
    multiplexedStreamModeParameters::reference set_multiplexedStreamModeParameters ();
    multiplexedStreamModeParameters::reference set_multiplexedStreamModeParameters (multiplexedStreamModeParameters::const_reference value);
    void omit_multiplexedStreamModeParameters ();
    bool multiplexedStreamModeParameters_isPresent () const;
    class logicalChannelNumber {
      public:
        typedef LogicalChannelNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelNumber
    logicalChannelNumber::const_reference get_logicalChannelNumber () const;
    logicalChannelNumber::reference ref_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber ();
    logicalChannelNumber::reference set_logicalChannelNumber (logicalChannelNumber::value_type::int_type value);
    void omit_logicalChannelNumber ();
    bool logicalChannelNumber_isPresent () const;
    void swap(ModeElement& other);
    ModeElement * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[7];
    static int fieldIds[7];
    static const char* fieldNames[7];
};

//
// MultiplePayloadStreamElementMode
//

class MultiplePayloadStreamElementMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplePayloadStreamElementMode(const void* info) : Inherited(info) {}
  public:
    MultiplePayloadStreamElementMode() : Inherited(&theInfo) {}
    MultiplePayloadStreamElementMode(const MultiplePayloadStreamElementMode & other) : Inherited(other)
    {}
    MultiplePayloadStreamElementMode& operator = (const MultiplePayloadStreamElementMode& other)
    { Inherited::operator = (other); return *this; } 
    class type {
      public:
        typedef ModeElementType value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class type
    type::const_reference get_type () const;
    type::reference ref_type ();
    type::reference set_type ();
    type::reference set_type (type::const_reference value);
    void swap(MultiplePayloadStreamElementMode& other);
    MultiplePayloadStreamElementMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

typedef ASN1::SET_OF<ModeElement,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  ModeDescription;

//
// MultiplePayloadStreamMode
//

class MultiplePayloadStreamMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultiplePayloadStreamMode(const void* info) : Inherited(info) {}
  public:
    MultiplePayloadStreamMode() : Inherited(&theInfo) {}
    MultiplePayloadStreamMode(const MultiplePayloadStreamMode & other) : Inherited(other)
    {}
    MultiplePayloadStreamMode& operator = (const MultiplePayloadStreamMode& other)
    { Inherited::operator = (other); return *this; } 
    class elements {
      public:
        typedef ASN1::SEQUENCE_OF<MultiplePayloadStreamElementMode>  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class elements
    elements::const_reference get_elements () const;
    elements::reference ref_elements ();
    elements::reference set_elements ();
    elements::reference set_elements (elements::const_reference value);
    void swap(MultiplePayloadStreamMode& other);
    MultiplePayloadStreamMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[1];
    static int fieldIds[1];
    static const char* fieldNames[1];
};

//
// RequestMode
//

class RequestMode : public ASN1::SEQUENCE
{
    typedef ASN1::SEQUENCE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMode(const void* info) : Inherited(info) {}
  public:
    RequestMode() : Inherited(&theInfo) {}
    RequestMode(const RequestMode & other) : Inherited(other)
    {}
    RequestMode& operator = (const RequestMode& other)
    { Inherited::operator = (other); return *this; } 
    class sequenceNumber {
      public:
        typedef SequenceNumber value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class sequenceNumber
    sequenceNumber::const_reference get_sequenceNumber () const;
    sequenceNumber::reference ref_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber ();
    sequenceNumber::reference set_sequenceNumber (sequenceNumber::value_type::int_type value);
    class requestedModes {
      public:
        typedef ASN1::SEQUENCE_OF<ModeDescription,  ASN1::SizeConstraint<ASN1::FixedConstraint, 1, 256> >  value_type;

        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestedModes
    requestedModes::const_reference get_requestedModes () const;
    requestedModes::reference ref_requestedModes ();
    requestedModes::reference set_requestedModes ();
    requestedModes::reference set_requestedModes (requestedModes::const_reference value);
    void swap(RequestMode& other);
    RequestMode * clone() const;
    static const InfoType theInfo;
  private:
    static const void* fieldInfos[2];
    static int fieldIds[2];
    static const char* fieldNames[2];
};

//
// RequestMessage
//

class RequestMessage : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    RequestMessage(const void* info) : Inherited(info) {}
  public:
    RequestMessage() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class masterSlaveDetermination {
      public:
        enum Id { id_ = 1 };
        typedef MasterSlaveDetermination value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterSlaveDetermination

    masterSlaveDetermination::const_reference get_masterSlaveDetermination () const;
    masterSlaveDetermination::reference ref_masterSlaveDetermination (); 
    masterSlaveDetermination::reference select_masterSlaveDetermination (); 
    masterSlaveDetermination::reference select_masterSlaveDetermination (masterSlaveDetermination::const_reference value); 
    bool masterSlaveDetermination_isSelected() const;

    class terminalCapabilitySet {
      public:
        enum Id { id_ = 2 };
        typedef TerminalCapabilitySet value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalCapabilitySet

    terminalCapabilitySet::const_reference get_terminalCapabilitySet () const;
    terminalCapabilitySet::reference ref_terminalCapabilitySet (); 
    terminalCapabilitySet::reference select_terminalCapabilitySet (); 
    terminalCapabilitySet::reference select_terminalCapabilitySet (terminalCapabilitySet::const_reference value); 
    bool terminalCapabilitySet_isSelected() const;

    class openLogicalChannel {
      public:
        enum Id { id_ = 3 };
        typedef OpenLogicalChannel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class openLogicalChannel

    openLogicalChannel::const_reference get_openLogicalChannel () const;
    openLogicalChannel::reference ref_openLogicalChannel (); 
    openLogicalChannel::reference select_openLogicalChannel (); 
    openLogicalChannel::reference select_openLogicalChannel (openLogicalChannel::const_reference value); 
    bool openLogicalChannel_isSelected() const;

    class closeLogicalChannel {
      public:
        enum Id { id_ = 4 };
        typedef CloseLogicalChannel value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class closeLogicalChannel

    closeLogicalChannel::const_reference get_closeLogicalChannel () const;
    closeLogicalChannel::reference ref_closeLogicalChannel (); 
    closeLogicalChannel::reference select_closeLogicalChannel (); 
    closeLogicalChannel::reference select_closeLogicalChannel (closeLogicalChannel::const_reference value); 
    bool closeLogicalChannel_isSelected() const;

    class requestChannelClose {
      public:
        enum Id { id_ = 5 };
        typedef RequestChannelClose value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestChannelClose

    requestChannelClose::const_reference get_requestChannelClose () const;
    requestChannelClose::reference ref_requestChannelClose (); 
    requestChannelClose::reference select_requestChannelClose (); 
    requestChannelClose::reference select_requestChannelClose (requestChannelClose::const_reference value); 
    bool requestChannelClose_isSelected() const;

    class multiplexEntrySend {
      public:
        enum Id { id_ = 6 };
        typedef MultiplexEntrySend value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexEntrySend

    multiplexEntrySend::const_reference get_multiplexEntrySend () const;
    multiplexEntrySend::reference ref_multiplexEntrySend (); 
    multiplexEntrySend::reference select_multiplexEntrySend (); 
    multiplexEntrySend::reference select_multiplexEntrySend (multiplexEntrySend::const_reference value); 
    bool multiplexEntrySend_isSelected() const;

    class requestMultiplexEntry {
      public:
        enum Id { id_ = 7 };
        typedef RequestMultiplexEntry value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestMultiplexEntry

    requestMultiplexEntry::const_reference get_requestMultiplexEntry () const;
    requestMultiplexEntry::reference ref_requestMultiplexEntry (); 
    requestMultiplexEntry::reference select_requestMultiplexEntry (); 
    requestMultiplexEntry::reference select_requestMultiplexEntry (requestMultiplexEntry::const_reference value); 
    bool requestMultiplexEntry_isSelected() const;

    class requestMode {
      public:
        enum Id { id_ = 8 };
        typedef RequestMode value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestMode

    requestMode::const_reference get_requestMode () const;
    requestMode::reference ref_requestMode (); 
    requestMode::reference select_requestMode (); 
    requestMode::reference select_requestMode (requestMode::const_reference value); 
    bool requestMode_isSelected() const;

    class roundTripDelayRequest {
      public:
        enum Id { id_ = 9 };
        typedef RoundTripDelayRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class roundTripDelayRequest

    roundTripDelayRequest::const_reference get_roundTripDelayRequest () const;
    roundTripDelayRequest::reference ref_roundTripDelayRequest (); 
    roundTripDelayRequest::reference select_roundTripDelayRequest (); 
    roundTripDelayRequest::reference select_roundTripDelayRequest (roundTripDelayRequest::const_reference value); 
    bool roundTripDelayRequest_isSelected() const;

    class maintenanceLoopRequest {
      public:
        enum Id { id_ = 10 };
        typedef MaintenanceLoopRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class maintenanceLoopRequest

    maintenanceLoopRequest::const_reference get_maintenanceLoopRequest () const;
    maintenanceLoopRequest::reference ref_maintenanceLoopRequest (); 
    maintenanceLoopRequest::reference select_maintenanceLoopRequest (); 
    maintenanceLoopRequest::reference select_maintenanceLoopRequest (maintenanceLoopRequest::const_reference value); 
    bool maintenanceLoopRequest_isSelected() const;

    class communicationModeRequest {
      public:
        enum Id { id_ = 11 };
        typedef CommunicationModeRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class communicationModeRequest

    communicationModeRequest::const_reference get_communicationModeRequest () const;
    communicationModeRequest::reference ref_communicationModeRequest (); 
    communicationModeRequest::reference select_communicationModeRequest (); 
    communicationModeRequest::reference select_communicationModeRequest (communicationModeRequest::const_reference value); 
    bool communicationModeRequest_isSelected() const;

    class conferenceRequest {
      public:
        enum Id { id_ = 12 };
        typedef ConferenceRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceRequest

    conferenceRequest::const_reference get_conferenceRequest () const;
    conferenceRequest::reference ref_conferenceRequest (); 
    conferenceRequest::reference select_conferenceRequest (); 
    conferenceRequest::reference select_conferenceRequest (conferenceRequest::const_reference value); 
    bool conferenceRequest_isSelected() const;

    class multilinkRequest {
      public:
        enum Id { id_ = 13 };
        typedef MultilinkRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multilinkRequest

    multilinkRequest::const_reference get_multilinkRequest () const;
    multilinkRequest::reference ref_multilinkRequest (); 
    multilinkRequest::reference select_multilinkRequest (); 
    multilinkRequest::reference select_multilinkRequest (multilinkRequest::const_reference value); 
    bool multilinkRequest_isSelected() const;

    class logicalChannelRateRequest {
      public:
        enum Id { id_ = 14 };
        typedef LogicalChannelRateRequest value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelRateRequest

    logicalChannelRateRequest::const_reference get_logicalChannelRateRequest () const;
    logicalChannelRateRequest::reference ref_logicalChannelRateRequest (); 
    logicalChannelRateRequest::reference select_logicalChannelRateRequest (); 
    logicalChannelRateRequest::reference select_logicalChannelRateRequest (logicalChannelRateRequest::const_reference value); 
    bool logicalChannelRateRequest_isSelected() const;

    class genericRequest {
      public:
        enum Id { id_ = 15 };
        typedef GenericMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericRequest

    genericRequest::const_reference get_genericRequest () const;
    genericRequest::reference ref_genericRequest (); 
    genericRequest::reference select_genericRequest (); 
    genericRequest::reference select_genericRequest (genericRequest::const_reference value); 
    bool genericRequest_isSelected() const;

    RequestMessage(nonStandard::Id id, nonStandard::const_reference value);
    RequestMessage(masterSlaveDetermination::Id id, masterSlaveDetermination::const_reference value);
    RequestMessage(terminalCapabilitySet::Id id, terminalCapabilitySet::const_reference value);
    RequestMessage(openLogicalChannel::Id id, openLogicalChannel::const_reference value);
    RequestMessage(closeLogicalChannel::Id id, closeLogicalChannel::const_reference value);
    RequestMessage(requestChannelClose::Id id, requestChannelClose::const_reference value);
    RequestMessage(multiplexEntrySend::Id id, multiplexEntrySend::const_reference value);
    RequestMessage(requestMultiplexEntry::Id id, requestMultiplexEntry::const_reference value);
    RequestMessage(requestMode::Id id, requestMode::const_reference value);
    RequestMessage(roundTripDelayRequest::Id id, roundTripDelayRequest::const_reference value);
    RequestMessage(maintenanceLoopRequest::Id id, maintenanceLoopRequest::const_reference value);
    RequestMessage(communicationModeRequest::Id id, communicationModeRequest::const_reference value);
    RequestMessage(conferenceRequest::Id id, conferenceRequest::const_reference value);
    RequestMessage(multilinkRequest::Id id, multilinkRequest::const_reference value);
    RequestMessage(logicalChannelRateRequest::Id id, logicalChannelRateRequest::const_reference value);
    RequestMessage(genericRequest::Id id, genericRequest::const_reference value);
    void swap(RequestMessage & other);
    RequestMessage(const RequestMessage & other)
    : Inherited(other) {} 

    RequestMessage & operator = (const RequestMessage & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    RequestMessage * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[16];
    static const char* selectionNames[16];
};

//
// FunctionNotUnderstood
//

class FunctionNotUnderstood : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    FunctionNotUnderstood(const void* info) : Inherited(info) {}
  public:
    FunctionNotUnderstood() : Inherited(&theInfo) {}
    class request {
      public:
        enum Id { id_ = 0 };
        typedef RequestMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class request

    request::const_reference get_request () const;
    request::reference ref_request (); 
    request::reference select_request (); 
    request::reference select_request (request::const_reference value); 
    bool request_isSelected() const;

    class response {
      public:
        enum Id { id_ = 1 };
        typedef ResponseMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class response

    response::const_reference get_response () const;
    response::reference ref_response (); 
    response::reference select_response (); 
    response::reference select_response (response::const_reference value); 
    bool response_isSelected() const;

    class command {
      public:
        enum Id { id_ = 2 };
        typedef CommandMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class command

    command::const_reference get_command () const;
    command::reference ref_command (); 
    command::reference select_command (); 
    command::reference select_command (command::const_reference value); 
    bool command_isSelected() const;

    FunctionNotUnderstood(request::Id id, request::const_reference value);
    FunctionNotUnderstood(response::Id id, response::const_reference value);
    FunctionNotUnderstood(command::Id id, command::const_reference value);
    void swap(FunctionNotUnderstood & other);
    FunctionNotUnderstood(const FunctionNotUnderstood & other)
    : Inherited(other) {} 

    FunctionNotUnderstood & operator = (const FunctionNotUnderstood & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    FunctionNotUnderstood * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[3];
    static const char* selectionNames[3];
};

//
// IndicationMessage
//

class IndicationMessage : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    IndicationMessage(const void* info) : Inherited(info) {}
  public:
    IndicationMessage() : Inherited(&theInfo) {}
    class nonStandard {
      public:
        enum Id { id_ = 0 };
        typedef NonStandardMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class nonStandard

    nonStandard::const_reference get_nonStandard () const;
    nonStandard::reference ref_nonStandard (); 
    nonStandard::reference select_nonStandard (); 
    nonStandard::reference select_nonStandard (nonStandard::const_reference value); 
    bool nonStandard_isSelected() const;

    class functionNotUnderstood {
      public:
        enum Id { id_ = 1 };
        typedef FunctionNotUnderstood value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class functionNotUnderstood

    functionNotUnderstood::const_reference get_functionNotUnderstood () const;
    functionNotUnderstood::reference ref_functionNotUnderstood (); 
    functionNotUnderstood::reference select_functionNotUnderstood (); 
    functionNotUnderstood::reference select_functionNotUnderstood (functionNotUnderstood::const_reference value); 
    bool functionNotUnderstood_isSelected() const;

    class masterSlaveDeterminationRelease {
      public:
        enum Id { id_ = 2 };
        typedef MasterSlaveDeterminationRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class masterSlaveDeterminationRelease

    masterSlaveDeterminationRelease::const_reference get_masterSlaveDeterminationRelease () const;
    masterSlaveDeterminationRelease::reference ref_masterSlaveDeterminationRelease (); 
    masterSlaveDeterminationRelease::reference select_masterSlaveDeterminationRelease (); 
    masterSlaveDeterminationRelease::reference select_masterSlaveDeterminationRelease (masterSlaveDeterminationRelease::const_reference value); 
    bool masterSlaveDeterminationRelease_isSelected() const;

    class terminalCapabilitySetRelease {
      public:
        enum Id { id_ = 3 };
        typedef TerminalCapabilitySetRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class terminalCapabilitySetRelease

    terminalCapabilitySetRelease::const_reference get_terminalCapabilitySetRelease () const;
    terminalCapabilitySetRelease::reference ref_terminalCapabilitySetRelease (); 
    terminalCapabilitySetRelease::reference select_terminalCapabilitySetRelease (); 
    terminalCapabilitySetRelease::reference select_terminalCapabilitySetRelease (terminalCapabilitySetRelease::const_reference value); 
    bool terminalCapabilitySetRelease_isSelected() const;

    class openLogicalChannelConfirm {
      public:
        enum Id { id_ = 4 };
        typedef OpenLogicalChannelConfirm value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class openLogicalChannelConfirm

    openLogicalChannelConfirm::const_reference get_openLogicalChannelConfirm () const;
    openLogicalChannelConfirm::reference ref_openLogicalChannelConfirm (); 
    openLogicalChannelConfirm::reference select_openLogicalChannelConfirm (); 
    openLogicalChannelConfirm::reference select_openLogicalChannelConfirm (openLogicalChannelConfirm::const_reference value); 
    bool openLogicalChannelConfirm_isSelected() const;

    class requestChannelCloseRelease {
      public:
        enum Id { id_ = 5 };
        typedef RequestChannelCloseRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestChannelCloseRelease

    requestChannelCloseRelease::const_reference get_requestChannelCloseRelease () const;
    requestChannelCloseRelease::reference ref_requestChannelCloseRelease (); 
    requestChannelCloseRelease::reference select_requestChannelCloseRelease (); 
    requestChannelCloseRelease::reference select_requestChannelCloseRelease (requestChannelCloseRelease::const_reference value); 
    bool requestChannelCloseRelease_isSelected() const;

    class multiplexEntrySendRelease {
      public:
        enum Id { id_ = 6 };
        typedef MultiplexEntrySendRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multiplexEntrySendRelease

    multiplexEntrySendRelease::const_reference get_multiplexEntrySendRelease () const;
    multiplexEntrySendRelease::reference ref_multiplexEntrySendRelease (); 
    multiplexEntrySendRelease::reference select_multiplexEntrySendRelease (); 
    multiplexEntrySendRelease::reference select_multiplexEntrySendRelease (multiplexEntrySendRelease::const_reference value); 
    bool multiplexEntrySendRelease_isSelected() const;

    class requestMultiplexEntryRelease {
      public:
        enum Id { id_ = 7 };
        typedef RequestMultiplexEntryRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestMultiplexEntryRelease

    requestMultiplexEntryRelease::const_reference get_requestMultiplexEntryRelease () const;
    requestMultiplexEntryRelease::reference ref_requestMultiplexEntryRelease (); 
    requestMultiplexEntryRelease::reference select_requestMultiplexEntryRelease (); 
    requestMultiplexEntryRelease::reference select_requestMultiplexEntryRelease (requestMultiplexEntryRelease::const_reference value); 
    bool requestMultiplexEntryRelease_isSelected() const;

    class requestModeRelease {
      public:
        enum Id { id_ = 8 };
        typedef RequestModeRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class requestModeRelease

    requestModeRelease::const_reference get_requestModeRelease () const;
    requestModeRelease::reference ref_requestModeRelease (); 
    requestModeRelease::reference select_requestModeRelease (); 
    requestModeRelease::reference select_requestModeRelease (requestModeRelease::const_reference value); 
    bool requestModeRelease_isSelected() const;

    class miscellaneousIndication {
      public:
        enum Id { id_ = 9 };
        typedef MiscellaneousIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class miscellaneousIndication

    miscellaneousIndication::const_reference get_miscellaneousIndication () const;
    miscellaneousIndication::reference ref_miscellaneousIndication (); 
    miscellaneousIndication::reference select_miscellaneousIndication (); 
    miscellaneousIndication::reference select_miscellaneousIndication (miscellaneousIndication::const_reference value); 
    bool miscellaneousIndication_isSelected() const;

    class jitterIndication {
      public:
        enum Id { id_ = 10 };
        typedef JitterIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class jitterIndication

    jitterIndication::const_reference get_jitterIndication () const;
    jitterIndication::reference ref_jitterIndication (); 
    jitterIndication::reference select_jitterIndication (); 
    jitterIndication::reference select_jitterIndication (jitterIndication::const_reference value); 
    bool jitterIndication_isSelected() const;

    class h223SkewIndication {
      public:
        enum Id { id_ = 11 };
        typedef H223SkewIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h223SkewIndication

    h223SkewIndication::const_reference get_h223SkewIndication () const;
    h223SkewIndication::reference ref_h223SkewIndication (); 
    h223SkewIndication::reference select_h223SkewIndication (); 
    h223SkewIndication::reference select_h223SkewIndication (h223SkewIndication::const_reference value); 
    bool h223SkewIndication_isSelected() const;

    class newATMVCIndication {
      public:
        enum Id { id_ = 12 };
        typedef NewATMVCIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class newATMVCIndication

    newATMVCIndication::const_reference get_newATMVCIndication () const;
    newATMVCIndication::reference ref_newATMVCIndication (); 
    newATMVCIndication::reference select_newATMVCIndication (); 
    newATMVCIndication::reference select_newATMVCIndication (newATMVCIndication::const_reference value); 
    bool newATMVCIndication_isSelected() const;

    class userInput {
      public:
        enum Id { id_ = 13 };
        typedef UserInputIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class userInput

    userInput::const_reference get_userInput () const;
    userInput::reference ref_userInput (); 
    userInput::reference select_userInput (); 
    userInput::reference select_userInput (userInput::const_reference value); 
    bool userInput_isSelected() const;

    class h2250MaximumSkewIndication {
      public:
        enum Id { id_ = 14 };
        typedef H2250MaximumSkewIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class h2250MaximumSkewIndication

    h2250MaximumSkewIndication::const_reference get_h2250MaximumSkewIndication () const;
    h2250MaximumSkewIndication::reference ref_h2250MaximumSkewIndication (); 
    h2250MaximumSkewIndication::reference select_h2250MaximumSkewIndication (); 
    h2250MaximumSkewIndication::reference select_h2250MaximumSkewIndication (h2250MaximumSkewIndication::const_reference value); 
    bool h2250MaximumSkewIndication_isSelected() const;

    class mcLocationIndication {
      public:
        enum Id { id_ = 15 };
        typedef MCLocationIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mcLocationIndication

    mcLocationIndication::const_reference get_mcLocationIndication () const;
    mcLocationIndication::reference ref_mcLocationIndication (); 
    mcLocationIndication::reference select_mcLocationIndication (); 
    mcLocationIndication::reference select_mcLocationIndication (mcLocationIndication::const_reference value); 
    bool mcLocationIndication_isSelected() const;

    class conferenceIndication {
      public:
        enum Id { id_ = 16 };
        typedef ConferenceIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class conferenceIndication

    conferenceIndication::const_reference get_conferenceIndication () const;
    conferenceIndication::reference ref_conferenceIndication (); 
    conferenceIndication::reference select_conferenceIndication (); 
    conferenceIndication::reference select_conferenceIndication (conferenceIndication::const_reference value); 
    bool conferenceIndication_isSelected() const;

    class vendorIdentification {
      public:
        enum Id { id_ = 17 };
        typedef VendorIdentification value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class vendorIdentification

    vendorIdentification::const_reference get_vendorIdentification () const;
    vendorIdentification::reference ref_vendorIdentification (); 
    vendorIdentification::reference select_vendorIdentification (); 
    vendorIdentification::reference select_vendorIdentification (vendorIdentification::const_reference value); 
    bool vendorIdentification_isSelected() const;

    class functionNotSupported {
      public:
        enum Id { id_ = 18 };
        typedef FunctionNotSupported value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class functionNotSupported

    functionNotSupported::const_reference get_functionNotSupported () const;
    functionNotSupported::reference ref_functionNotSupported (); 
    functionNotSupported::reference select_functionNotSupported (); 
    functionNotSupported::reference select_functionNotSupported (functionNotSupported::const_reference value); 
    bool functionNotSupported_isSelected() const;

    class multilinkIndication {
      public:
        enum Id { id_ = 19 };
        typedef MultilinkIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class multilinkIndication

    multilinkIndication::const_reference get_multilinkIndication () const;
    multilinkIndication::reference ref_multilinkIndication (); 
    multilinkIndication::reference select_multilinkIndication (); 
    multilinkIndication::reference select_multilinkIndication (multilinkIndication::const_reference value); 
    bool multilinkIndication_isSelected() const;

    class logicalChannelRateRelease {
      public:
        enum Id { id_ = 20 };
        typedef LogicalChannelRateRelease value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class logicalChannelRateRelease

    logicalChannelRateRelease::const_reference get_logicalChannelRateRelease () const;
    logicalChannelRateRelease::reference ref_logicalChannelRateRelease (); 
    logicalChannelRateRelease::reference select_logicalChannelRateRelease (); 
    logicalChannelRateRelease::reference select_logicalChannelRateRelease (logicalChannelRateRelease::const_reference value); 
    bool logicalChannelRateRelease_isSelected() const;

    class flowControlIndication {
      public:
        enum Id { id_ = 21 };
        typedef FlowControlIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class flowControlIndication

    flowControlIndication::const_reference get_flowControlIndication () const;
    flowControlIndication::reference ref_flowControlIndication (); 
    flowControlIndication::reference select_flowControlIndication (); 
    flowControlIndication::reference select_flowControlIndication (flowControlIndication::const_reference value); 
    bool flowControlIndication_isSelected() const;

    class mobileMultilinkReconfigurationIndication {
      public:
        enum Id { id_ = 22 };
        typedef MobileMultilinkReconfigurationIndication value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class mobileMultilinkReconfigurationIndication

    mobileMultilinkReconfigurationIndication::const_reference get_mobileMultilinkReconfigurationIndication () const;
    mobileMultilinkReconfigurationIndication::reference ref_mobileMultilinkReconfigurationIndication (); 
    mobileMultilinkReconfigurationIndication::reference select_mobileMultilinkReconfigurationIndication (); 
    mobileMultilinkReconfigurationIndication::reference select_mobileMultilinkReconfigurationIndication (mobileMultilinkReconfigurationIndication::const_reference value); 
    bool mobileMultilinkReconfigurationIndication_isSelected() const;

    class genericIndication {
      public:
        enum Id { id_ = 23 };
        typedef GenericMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class genericIndication

    genericIndication::const_reference get_genericIndication () const;
    genericIndication::reference ref_genericIndication (); 
    genericIndication::reference select_genericIndication (); 
    genericIndication::reference select_genericIndication (genericIndication::const_reference value); 
    bool genericIndication_isSelected() const;

    IndicationMessage(nonStandard::Id id, nonStandard::const_reference value);
    IndicationMessage(functionNotUnderstood::Id id, functionNotUnderstood::const_reference value);
    IndicationMessage(masterSlaveDeterminationRelease::Id id, masterSlaveDeterminationRelease::const_reference value);
    IndicationMessage(terminalCapabilitySetRelease::Id id, terminalCapabilitySetRelease::const_reference value);
    IndicationMessage(openLogicalChannelConfirm::Id id, openLogicalChannelConfirm::const_reference value);
    IndicationMessage(requestChannelCloseRelease::Id id, requestChannelCloseRelease::const_reference value);
    IndicationMessage(multiplexEntrySendRelease::Id id, multiplexEntrySendRelease::const_reference value);
    IndicationMessage(requestMultiplexEntryRelease::Id id, requestMultiplexEntryRelease::const_reference value);
    IndicationMessage(requestModeRelease::Id id, requestModeRelease::const_reference value);
    IndicationMessage(miscellaneousIndication::Id id, miscellaneousIndication::const_reference value);
    IndicationMessage(jitterIndication::Id id, jitterIndication::const_reference value);
    IndicationMessage(h223SkewIndication::Id id, h223SkewIndication::const_reference value);
    IndicationMessage(newATMVCIndication::Id id, newATMVCIndication::const_reference value);
    IndicationMessage(userInput::Id id, userInput::const_reference value);
    IndicationMessage(h2250MaximumSkewIndication::Id id, h2250MaximumSkewIndication::const_reference value);
    IndicationMessage(mcLocationIndication::Id id, mcLocationIndication::const_reference value);
    IndicationMessage(conferenceIndication::Id id, conferenceIndication::const_reference value);
    IndicationMessage(vendorIdentification::Id id, vendorIdentification::const_reference value);
    IndicationMessage(functionNotSupported::Id id, functionNotSupported::const_reference value);
    IndicationMessage(multilinkIndication::Id id, multilinkIndication::const_reference value);
    IndicationMessage(logicalChannelRateRelease::Id id, logicalChannelRateRelease::const_reference value);
    IndicationMessage(flowControlIndication::Id id, flowControlIndication::const_reference value);
    IndicationMessage(mobileMultilinkReconfigurationIndication::Id id, mobileMultilinkReconfigurationIndication::const_reference value);
    IndicationMessage(genericIndication::Id id, genericIndication::const_reference value);
    void swap(IndicationMessage & other);
    IndicationMessage(const IndicationMessage & other)
    : Inherited(other) {} 

    IndicationMessage & operator = (const IndicationMessage & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    IndicationMessage * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[24];
    static const char* selectionNames[24];
};

//
// MultimediaSystemControlMessage
//

class MultimediaSystemControlMessage : public ASN1::CHOICE
{
    typedef ASN1::CHOICE Inherited;
  protected:
    typedef Inherited::InfoType InfoType;
    MultimediaSystemControlMessage(const void* info) : Inherited(info) {}
  public:
    MultimediaSystemControlMessage() : Inherited(&theInfo) {}
    class request {
      public:
        enum Id { id_ = 0 };
        typedef RequestMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class request

    request::const_reference get_request () const;
    request::reference ref_request (); 
    request::reference select_request (); 
    request::reference select_request (request::const_reference value); 
    bool request_isSelected() const;

    class response {
      public:
        enum Id { id_ = 1 };
        typedef ResponseMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class response

    response::const_reference get_response () const;
    response::reference ref_response (); 
    response::reference select_response (); 
    response::reference select_response (response::const_reference value); 
    bool response_isSelected() const;

    class command {
      public:
        enum Id { id_ = 2 };
        typedef CommandMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class command

    command::const_reference get_command () const;
    command::reference ref_command (); 
    command::reference select_command (); 
    command::reference select_command (command::const_reference value); 
    bool command_isSelected() const;

    class indication {
      public:
        enum Id { id_ = 3 };
        typedef IndicationMessage value_type;
        typedef value_type&	reference;
        typedef const value_type&	const_reference;
        typedef value_type*	pointer;
        typedef const value_type*	const_pointer;
    }; // end class indication

    indication::const_reference get_indication () const;
    indication::reference ref_indication (); 
    indication::reference select_indication (); 
    indication::reference select_indication (indication::const_reference value); 
    bool indication_isSelected() const;

    MultimediaSystemControlMessage(request::Id id, request::const_reference value);
    MultimediaSystemControlMessage(response::Id id, response::const_reference value);
    MultimediaSystemControlMessage(command::Id id, command::const_reference value);
    MultimediaSystemControlMessage(indication::Id id, indication::const_reference value);
    void swap(MultimediaSystemControlMessage & other);
    MultimediaSystemControlMessage(const MultimediaSystemControlMessage & other)
    : Inherited(other) {} 

    MultimediaSystemControlMessage & operator = (const MultimediaSystemControlMessage & other)
    {
      Inherited::operator=(other);
      return *this;
    }

    MultimediaSystemControlMessage * clone() const;
    static bool equal_type(const ASN1::AbstractData&);
    static const InfoType theInfo;
  private:
    static const void* selectionInfos[4];
    static const char* selectionNames[4];
};

#include "multimedia_system_control.inl"
} // namespace MULTIMEDIA_SYSTEM_CONTROL

#endif // __MULTIMEDIA_SYSTEM_CONTROL_H


// End of multimedia_system_control.h
